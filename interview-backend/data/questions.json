[{"_id":"60c81027da9b3346d469d65f","title":"JavaScript变量有哪些数据类型？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul>\n<li>\n<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: Tahoma; mso-hansi-font-family: Tahoma; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: Tahoma;\">undefined</span><span style=\"font-family: 微软雅黑;\">（未定义类型）</span></span></p>\n</li>\n<li>\n<p class=\"MsoNormal\"><span style=\"font-size: 11pt;\"><span style=\"font-family: Tahoma;\">null</span><span style=\"font-family: 微软雅黑;\">（空类型）</span></span></p>\n</li>\n<li>\n<p class=\"MsoNormal\"><span style=\"font-size: 11pt;\"><span style=\"font-family: Tahoma;\">number</span><span style=\"font-family: 微软雅黑;\">（数值类型）</span></span></p>\n</li>\n<li>\n<p class=\"MsoNormal\"><span style=\"font-size: 11pt;\"><span style=\"font-family: Tahoma;\">string</span><span style=\"font-family: 微软雅黑;\">（字符串类型）</span></span></p>\n</li>\n<li>\n<p class=\"MsoNormal\"><span style=\"font-size: 11pt;\"><span style=\"font-family: Tahoma;\">boolean</span><span style=\"font-family: 微软雅黑;\">（布尔类型）</span></span></p>\n</li>\n</ul>","rank_id":1,"createdAt":"2021-06-15T02:27:51.219Z","updatedAt":"2021-06-15T02:27:51.219Z","__v":0},{"_id":"60c810e2da9b3346d469d660","title":"JavaScript中常用的系统函数其作用？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">parselnt()</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">: &nbsp;</span><span style=\"font-family: 微软雅黑;\">可解析一个字符串，并返回一个整数。</span></span></p>\n</li>\n<li>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">parseFloat()</span><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">:</span><span style=\"font-family: 微软雅黑;\">可解析一个字符串，并返回一个浮点数。</span></span></p>\n</li>\n<li>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">isNaN()</span><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">:</span><span style=\"font-family: 微软雅黑;\">用于检查其参数是否是数字，不是数字为</span><span style=\"font-family: 宋体;\">true</span><span style=\"font-family: 微软雅黑;\">，反之为</span><span style=\"font-family: 宋体;\">false</span><span style=\"font-family: 微软雅黑;\">。</span></span></p>\n</li>\n<li>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">prompt(); </span><span style=\"font-family: 微软雅黑;\">显示用户输入的对话框。</span></span></p>\n</li>\n<li>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">alert(); </span><span style=\"font-family: 微软雅黑;\">显示带有一个&ldquo;确定&rdquo;按钮的警示框。</span></span></p>\n</li>\n<li>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">confirm(); </span><span style=\"font-family: 微软雅黑;\">显示带有一个&ldquo;确定&rdquo;&ldquo;取消&rdquo;按钮的对话框。</span></span></p>\n</li>\n<li>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">close(); </span><span style=\"font-family: 微软雅黑;\">关闭浏览器窗口。</span></span></p>\n</li>\n<li>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">open(); </span><span style=\"font-family: 微软雅黑;\">弹出新的浏览器窗口。</span></span></p>\n</li>\n<li>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">setTimeout(); </span><span style=\"font-family: 微软雅黑;\">在指定毫秒数后调用函数或计算表达式。</span></span></p>\n</li>\n<li><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 微软雅黑;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 微软雅黑;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 微软雅黑;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 微软雅黑;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 微软雅黑;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 微软雅黑;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 微软雅黑;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 微软雅黑;\"><span style=\"font-family: 宋体;\">&nbsp; &nbsp;setInterval(); </span><span style=\"font-family: 微软雅黑;\">按照指定的周期（以毫秒计）来调用函数或表达式</span><span style=\"font-size: 11pt; font-family: 宋体;\"><span style=\"font-family: 微软雅黑;\">。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></li>\n</ol>","rank_id":2,"createdAt":"2021-06-15T02:30:58.834Z","updatedAt":"2021-06-15T02:30:58.834Z","__v":0},{"_id":"60c8120ada9b3346d469d661","title":"js中的3种弹出式消息提醒(警告窗口，确认窗口，信息输入窗口)的命令是什么？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoBodyText\" style=\"margin-left: 22pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.5000pt;\"><span style=\"font-family: 宋体;\">弹出警告窗口</span><span style=\"font-family: 宋体;\">&ldquo;输入数据无效&rdquo;</span></span></p>\n<p class=\"MsoBodyText\" style=\"margin-left: 22pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.5000pt;\"><span style=\"font-family: 宋体;\">弹出确认窗口</span><span style=\"font-family: 宋体;\">&ldquo;确认保存吗？&rdquo;</span></span></p>\n<p class=\"MsoBodyText\" style=\"margin-left: 22pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.5000pt;\"><span style=\"font-family: 宋体;\">弹出信息输入窗口</span><span style=\"font-family: 宋体;\">&ldquo;请在此输入你的姓名&rdquo;</span></span></p>\n<p class=\"MsoBodyText\" style=\"margin-left: 22pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.5000pt;\">&ldquo;输入数据无效&rdquo;：</span></p>\n<p class=\"MsoBodyText\" style=\"margin-left: 22pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.5000pt;\"><span style=\"font-family: Verdana;\">alert(\"</span><span style=\"font-family: 宋体;\">输入数据无效</span><span style=\"font-family: Verdana;\">\");</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.5000pt;\"><span style=\"font-family: Verdana;\">//</span><span style=\"font-family: 宋体;\">警告</span></span></p>\n<p class=\"MsoBodyText\" style=\"text-indent: 21pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.5000pt;\">&ldquo;确认保存吗？&rdquo;：</span></p>\n<p class=\"MsoBodyText\" style=\"text-indent: 21pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.5000pt;\"><span style=\"font-family: Verdana;\">confirm(\"</span><span style=\"font-family: 宋体;\">你是菜鸟吗</span><span style=\"font-family: Verdana;\">\");</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.5000pt;\"><span style=\"font-family: Verdana;\">//</span><span style=\"font-family: 宋体;\">确认</span></span></p>\n<p class=\"MsoBodyText\" style=\"text-indent: 21pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.5000pt;\">&ldquo;请在此输入你的姓名&rdquo;：</span></p>\n<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: Verdana;\">prompt(\"</span><span style=\"font-family: 微软雅黑;\">请在此输入你的姓名</span><span style=\"font-family: Verdana;\">\")</span></span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: Verdana;\">//</span><span style=\"font-family: 微软雅黑;\">信息输入</span></span></p>","rank_id":3,"createdAt":"2021-06-15T02:35:54.871Z","updatedAt":"2021-06-15T02:35:54.871Z","__v":0},{"_id":"60c81221da9b3346d469d662","title":"什么是BOM？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">BOM</span><span style=\"font-family: 微软雅黑;\">是</span><span style=\"font-family: 宋体;\">Browser &nbsp;Object &nbsp;Model</span><span style=\"font-family: 微软雅黑;\">（浏览器对象模型）的简称，提供了独立于内容与浏览器窗口进行交互的对象。</span></span></p>","rank_id":4,"createdAt":"2021-06-15T02:36:17.969Z","updatedAt":"2021-06-15T02:36:17.969Z","__v":0},{"_id":"60c81278da9b3346d469d663","title":"什么是DOM?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">DOM</span><span style=\"font-family: 微软雅黑;\">即</span><span style=\"font-family: 宋体;\">Document &nbsp;Object &nbsp;Model</span><span style=\"font-family: 微软雅黑;\">（文档对象模型），如果需要对</span><span style=\"font-family: 宋体;\">HTML</span><span style=\"font-family: 微软雅黑;\">文档中的元素进行访问，添加，删除，移动或重排，</span><span style=\"font-family: 宋体;\">JavaScript</span><span style=\"font-family: 微软雅黑;\">就是通过</span><span style=\"font-family: 宋体;\">DOM</span><span style=\"font-family: 微软雅黑;\">来实现的，</span><span style=\"font-family: 宋体;\">DOM</span><span style=\"font-family: 微软雅黑;\">可被</span><span style=\"font-family: 宋体;\">JavaScript</span><span style=\"font-family: 微软雅黑;\">用来读取，改变</span><span style=\"font-family: 宋体;\">HTML,XHTML</span><span style=\"font-family: 微软雅黑;\">及</span><span style=\"font-family: 宋体;\">XML</span><span style=\"font-family: 微软雅黑;\">文档，所以</span><span style=\"font-family: 宋体;\">DOM</span><span style=\"font-family: 微软雅黑;\">是由三部分组成的。</span></span></p>\n<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">分别是：</span></strong></p>\n<ol>\n<li class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-weight: 400; font-family: 宋体;\">Core DOM</span><span style=\"font-weight: 400; font-family: 微软雅黑;\">，即核心</span><span style=\"font-weight: 400; font-family: 宋体;\">DOM</span><span style=\"font-weight: 400; font-family: 微软雅黑;\">编程，定义了一套标准的针对任何结构化文档的对象。</span></span></strong></li>\n<li class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-weight: 400; font-family: 微软雅黑;\"><span style=\"font-family: 宋体;\">XML DOM</span><span style=\"font-family: 微软雅黑;\">：定义了一套标准的针对</span><span style=\"font-family: 宋体;\">XML</span><span style=\"font-family: 微软雅黑;\">文档的对象。</span></span></span></strong></li>\n<li class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-weight: 400; font-family: 微软雅黑;\"><span style=\"font-family: 微软雅黑;\"><span style=\"font-family: 宋体;\">HTML DOM</span><span style=\"font-family: 微软雅黑;\">：定义了一套标准的针对</span><span style=\"font-family: 宋体;\">HTML</span><span style=\"font-family: 微软雅黑;\">文档的对象。</span></span></span></span></strong></li>\n</ol>","rank_id":5,"createdAt":"2021-06-15T02:37:44.639Z","updatedAt":"2021-06-15T02:37:44.639Z","__v":0},{"_id":"60c812acda9b3346d469d664","title":"Javascript中定时执行如何实现，JavaScript如何实现一段代码在执行时间后运行？如何指定一段代码每隔指定时间就运行？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoBodyText\" style=\"text-indent: 21pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 0.5000pt;\"><span style=\"font-family: 宋体;\">定时执行有两种函数，</span><span style=\"font-family: Verdana;\">setTimeout()</span><span style=\"font-family: 宋体;\">和</span><span style=\"font-family: Verdana;\">setInterval()</span><span style=\"font-family: 宋体;\">，</span><span style=\"font-family: Verdana;\">setTimeout()</span><span style=\"font-family: 宋体;\">是在一段时间后执行指定方法，而</span><span style=\"font-family: Verdana;\">setInterval()</span><span style=\"font-family: 宋体;\">是每隔一段时间后执行指定的方法</span></span></p>","rank_id":6,"createdAt":"2021-06-15T02:38:36.469Z","updatedAt":"2021-06-15T02:38:36.469Z","__v":0},{"_id":"60c8141eda9b3346d469d665","title":"DOM模型中的常用对象及其方法？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li>document对象常用的方法有：write()\n<p class=\"MsoNormal\" style=\"margin-left: 11.0000pt; mso-para-margin-left: 1.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"> </span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">getElementById()</span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 11.0000pt; mso-para-margin-left: 1.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"> </span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">getElementByName()</span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 11.0000pt; mso-para-margin-left: 1.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"> </span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">getElementByTagName()</span></p>\n</li>\n<li><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">location对象提供了当前页面的URL信息，常用的方法有：</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-size: 11pt; font-family: 宋体;\">reload()</span><span style=\"font-family: 微软雅黑; font-size: 11pt;\">是用于重新加载当前文档。</span></span></span>\n<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"> </span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">replace()</span><span style=\"font-family: 微软雅黑;\">是用新的文档替换当前文档。</span></span></p>\n</li>\n<li><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">history对象提供了用户最近浏览的URL列表，主要方法有：</span></span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">back()<span style=\"font-size: 11pt;\"><span style=\"font-family: 微软雅黑;\">：实现浏览器后退页面功能</span></span></span></span></span></span>\n<p class=\"MsoNormal\" style=\"margin-left: 11.0000pt; mso-para-margin-left: 1.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"> </span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">forwarc()</span><span style=\"font-size: 11pt;\"><span style=\"font-family: 微软雅黑;\">：实现浏览器前进页面功能</span></span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 11.0000pt; mso-para-margin-left: 1.0000gd;\"><span style=\"font-size: 11pt;\"> </span><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">go()</span><span style=\"font-family: 微软雅黑;\">：在页面上实现前进、后退的功能。</span></span></p>\n</li>\n</ol>","rank_id":7,"createdAt":"2021-06-15T02:44:46.110Z","updatedAt":"2021-06-15T02:44:46.110Z","__v":0},{"_id":"60c8149dda9b3346d469d666","title":"如何设置页面元素的显示和隐藏？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp; &nbsp; 主要用到两个属性，</span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">visibility</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">和</span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">display</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">，区别在于：属性的值不同：</span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">visibility</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">属性的值有：</span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">visible</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">（可见），</span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">hidden</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">（不可见），</span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">Display</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">属性的值有：</span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">none</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">(</span><span style=\"font-family: 微软雅黑;\">不可见</span><span style=\"font-family: 宋体;\">),</span></span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">block</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">（可见）。</span></p>\n<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;&nbsp;</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"> </span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">visibility</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">属性设置元素不可见时，元素仍然占据页面上的空间，而</span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">display</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">属性设置元素不可见不会占据页面上的空间。</span></p>\n<p class=\"MsoNormal\" style=\"margin-bottom: 0.0000pt; margin-left: 21.2500pt; text-indent: -21.2500pt; mso-hyphenate: none; mso-pagination: none; text-align: justify; text-justify: inter-ideograph; mso-list: l0 level1 lfo1;\" align=\"justify\"><!-- [if !supportLists]--><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 宋体; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">document.getElementById('</span><span style=\"font-family: 微软雅黑;\">对象</span><span style=\"font-family: 宋体;\">1').style.display = \"none\";(</span><span style=\"font-family: 微软雅黑;\">会释放元素所在页面上所占的空间</span><span style=\"font-family: 宋体;\">)</span></span></p>\n<p class=\"MsoNormal\" style=\"margin-bottom: 0.0000pt; margin-left: 21.2500pt; text-indent: -21.2500pt; mso-hyphenate: none; mso-pagination: none; text-align: justify; text-justify: inter-ideograph; mso-list: l0 level1 lfo1;\" align=\"justify\"><!-- [if !supportLists]--><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 宋体; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">document.getElementById('</span><span style=\"font-family: 微软雅黑;\">对象</span><span style=\"font-family: 宋体;\">1').style.visibility= \"visible\";(</span><span style=\"font-family: 微软雅黑;\">不会释放元素所在页面上所占的空间</span><span style=\"font-family: 宋体;\">)</span></span></p>","rank_id":8,"createdAt":"2021-06-15T02:46:53.853Z","updatedAt":"2021-06-15T02:46:53.853Z","__v":0},{"_id":"60c814f2da9b3346d469d667","title":"使用什么事件可以实现当鼠标移动某文本上时，文本样式改变，当鼠标离开时文本样式恢复为原来的样式？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">onmouseover/enter</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">事件可以将鼠标移动到某文本上时改变文本的样式。</span></p>\n<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">onmouseout/leave</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">事件可以当鼠标离开文本是恢复原来的样式。</span></p>","rank_id":9,"createdAt":"2021-06-15T02:48:18.304Z","updatedAt":"2021-06-15T02:48:18.304Z","__v":0},{"_id":"60c81567da9b3346d469d668","title":"DOM如何操作文档的标准节点？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">查看节点：使用</span><span style=\"font-family: 宋体;\">getElementById()</span><span style=\"font-family: 微软雅黑;\">，</span><span style=\"font-family: 宋体;\">getElementByName(),getElementByTagName</span><span style=\"font-family: 微软雅黑;\">可以查看</span><span style=\"font-family: 宋体;\">HTML</span><span style=\"font-family: 微软雅黑;\">文档中的任何元素。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">创建和增加节点：创建节点要用到</span><span style=\"font-family: 宋体;\">createElement(</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&ldquo;</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">标签名</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&rdquo;</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">)</span><span style=\"font-family: 微软雅黑;\">，例如：</span><span style=\"font-family: 宋体;\">createElement(</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&ldquo;</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">img</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&rdquo;</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">)</span><span style=\"font-family: 微软雅黑;\">。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">增加节点有三种方式：</span></li>\n</ul>\n<ol>\n<li style=\"list-style-type: none;\">\n<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;&nbsp;<span style=\"font-family: 宋体;\">appendChild(nodeName)</span><span style=\"font-family: 微软雅黑;\">向已经存在节点列表的末尾添加新的子节点。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;&nbsp;<span style=\"font-family: 宋体;\">insertBefore(newNode,oldNode)</span><span style=\"font-family: 微软雅黑;\">向指定的节点前插入一个新的子节点。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;&nbsp;<span style=\"font-family: 宋体;\">cloneNode(deep)</span><span style=\"font-family: 微软雅黑;\">复制某个指定的节点，</span><span style=\"font-family: 宋体;\">deep</span><span style=\"font-family: 微软雅黑;\">是布尔值，当</span><span style=\"font-family: 宋体;\">deep</span><span style=\"font-family: 微软雅黑;\">为</span><span style=\"font-family: 宋体;\">true</span><span style=\"font-family: 微软雅黑;\">时，会复制指定的节点和所有子节点，当</span><span style=\"font-family: 宋体;\">deep</span><span style=\"font-family: 微软雅黑;\">为</span><span style=\"font-family: 宋体;\">false</span><span style=\"font-family: 微软雅黑;\">时，只复制指定的节点和它的属性。</span></span></li>\n</ol>\n</li>\n</ol>\n<ul>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">删除和替换节点：分别用</span><span style=\"font-family: 宋体;\">removeChild(none),replaceChild(newNode,oldNode)</span><span style=\"font-family: 微软雅黑;\">。</span></span></li>\n</ul>","rank_id":10,"createdAt":"2021-06-15T02:50:15.895Z","updatedAt":"2021-06-15T02:50:15.895Z","__v":0},{"_id":"60c815cbda9b3346d469d669","title":"什么是jQuery ","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\" style=\"margin-left: 11.0000pt; mso-para-margin-left: 1.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">jQuery</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">也就是</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">JavaScript</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">和</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">Query(</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">查询</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">),</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">即是辅助</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">JavaScript</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">开发的库。</span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 11.0000pt; mso-para-margin-left: 1.0000gd;\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">jQuery</span></strong><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">优势：</span></strong></p>\n<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">轻量级</span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">强大的选择器</span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">出色的</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">DOM</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">操作封装</span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">可靠的事件处理机制</span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">出色的浏览器兼容性</span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">完善的</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">Ajax</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">支持</span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">出色的浏览器兼容性等</span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">理念：写的少，做的多</span></span></li>\n</ol>","rank_id":11,"createdAt":"2021-06-15T02:51:55.294Z","updatedAt":"2021-06-15T02:51:55.294Z","__v":0},{"_id":"60c815edda9b3346d469d66a","title":"你为什么要使用jQuery？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">因为</span><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">是轻量级的框架，大小不到</span><span style=\"font-family: 宋体;\">30kb,</span><span style=\"font-family: 微软雅黑;\">它有强大的选择器，出色的</span><span style=\"font-family: 宋体;\">DOM</span><span style=\"font-family: 微软雅黑;\">操作的封装，有可靠的事件处理机制</span><span style=\"font-family: 宋体;\">(jQuery</span><span style=\"font-family: 微软雅黑;\">在处理事件绑定的时候相当的可靠</span><span style=\"font-family: 宋体;\">)</span><span style=\"font-family: 微软雅黑;\">，完善的</span><span style=\"font-family: 宋体;\">ajax(</span><span style=\"font-family: 微软雅黑;\">它的</span><span style=\"font-family: 宋体;\">ajax</span><span style=\"font-family: 微软雅黑;\">封装的非常的好，不需要考虑复杂浏览器的兼容性和</span><span style=\"font-family: 宋体;\">XMLHttpRequest</span><span style=\"font-family: 微软雅黑;\">对象的创建和使用的问题。</span><span style=\"font-family: 宋体;\">) </span><span style=\"font-family: 微软雅黑;\">出色的浏览器的兼容性。 而且支持链式操作，隐式迭代。行为层和结构层的分离，还支持丰富的插件，</span><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">的文档也非常的丰富。</span></span></p>","rank_id":12,"createdAt":"2021-06-15T02:52:29.756Z","updatedAt":"2021-06-15T02:52:29.756Z","__v":0},{"_id":"60c816e5da9b3346d469d66b","title":"你在公司是怎么用jQuery的？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">下载</span><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">类库，在</span><span style=\"font-family: 宋体;\">jsp</span><span style=\"font-family: 微软雅黑;\">页面引用</span><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">类库即可</span></span></span>\n<pre class=\"language-markup\"><code>&lt;script type=\"text/javascript\" src=\"jQuery/jQuery-1.7.2.min.js\"/&gt;</code></pre>\n</li>\n<li class=\"MsoNormal\">&nbsp;<span style=\"font-size: 11pt; font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑; font-size: 11pt;\"><span style=\"font-family: 微软雅黑; font-size: 11pt;\">的调用示例：</span></span>\n<pre class=\"language-markup\"><code>&lt;script&gt;\n\t//创建一个页面默认启动调用的特效\n\t\t$(document).ready(\n\t\t\tfunction(){ \n\t\t\t\talert(\"页面启动时调用该方法!\"); \n\t\t}\n\t);\n\t\n\t//以上代码也可以写成如下的简写方式\n\t$(function(){\n\t\talert(\"页面启动时调用该方法!\");\n\t\t});\n&lt;/script&gt;</code></pre>\n<p class=\"MsoNormal\" style=\"margin-left: 11.0000pt; mso-para-margin-left: 1.0000gd;\">&nbsp;</p>\n</li>\n</ol>","rank_id":13,"createdAt":"2021-06-15T02:56:37.490Z","updatedAt":"2021-06-15T02:56:37.490Z","__v":0},{"_id":"60c81730da9b3346d469d66c","title":"jQuery 能做什么？ ","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;<span style=\"font-family: 微软雅黑;\">获取页面的元素</span> </span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;<span style=\"font-family: 微软雅黑;\">修改页面的外观</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;<span style=\"font-family: 微软雅黑;\">改变页面大的内容</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;<span style=\"font-family: 微软雅黑;\">响应用户的页面操作</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;<span style=\"font-family: 微软雅黑;\">为页面添加动态效果</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;<span style=\"font-family: 微软雅黑;\">无需刷新页面，即可以从服务器获取信息</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;<span style=\"font-family: 微软雅黑;\">简化常见的</span><span style=\"font-family: 宋体;\">javascript</span><span style=\"font-family: 微软雅黑;\">任务</span></span></li>\n</ol>","rank_id":14,"createdAt":"2021-06-15T02:57:52.542Z","updatedAt":"2021-06-15T02:57:52.542Z","__v":0},{"_id":"60c81769da9b3346d469d66d","title":"$(document).ready()方法和window.onload有什么区别？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">两个方法有相似的功能，但是在执行时机方面是有区别的。</span></p>\n<ol>\n<li class=\"MsoNormal\">\n<p class=\"MsoNormal\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">window.onload</span><span style=\"font-family: 微软雅黑;\">方法是在网页中所有的元素</span><span style=\"font-family: 宋体;\">(</span><span style=\"font-family: 微软雅黑;\">包括元素的所有关联文件</span><span style=\"font-family: 宋体;\">)</span><span style=\"font-family: 微软雅黑;\">完全加载到浏览器后才执行的。</span></span></p>\n</li>\n<li class=\"MsoNormal\">\n<p class=\"MsoNormal\" style=\"margin-left: 11.0000pt; mso-para-margin-left: 1.0000gd;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">$(document).ready() </span><span style=\"font-family: 微软雅黑;\">方法可以在</span><span style=\"font-family: 宋体;\">DOM</span><span style=\"font-family: 微软雅黑;\">载入就绪时就对其进行操纵，并调用执行绑定的函数。</span></span></p>\n</li>\n</ol>","rank_id":15,"createdAt":"2021-06-15T02:58:49.102Z","updatedAt":"2021-06-15T02:58:49.102Z","__v":0},{"_id":"60c817a0da9b3346d469d66e","title":"Jquery对象和dom对象的区别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"15\" style=\"margin-left: 18.0000pt; text-indent: 0.0000pt; mso-char-indent-count: 0.0000;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;\">Jquery对象才能调用jquery中特有的方法。例如jqueryObj.html()、jqueryObj.val()等方法，而不能使用dom对象特有的属性和方法，例如domObj.value,domObj.innerHTML等。</span></p>\n<p class=\"15\" style=\"margin-left: 18.0000pt; text-indent: 0.0000pt; mso-char-indent-count: 0.0000;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;\">Jquery对象可以和dom对象相互转化</span></p>","rank_id":16,"createdAt":"2021-06-15T02:59:44.396Z","updatedAt":"2021-06-15T02:59:44.396Z","__v":0},{"_id":"60c81837da9b3346d469d66f","title":"jQuery对象和dom对象是怎样转换的？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\" style=\"margin-left: 11.0000pt; mso-para-margin-left: 1.0000gd;\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">转</span><span style=\"font-family: 宋体;\">DOM</span><span style=\"font-family: 微软雅黑;\">对象</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">:</span></span></p>\n<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">jQuery </span><span style=\"font-family: 微软雅黑;\">对象是一个数组对象，可以通过</span><span style=\"font-family: 宋体;\">[index]</span><span style=\"font-family: 微软雅黑;\">的方式得到相应的</span><span style=\"font-family: 宋体;\">DOM</span><span style=\"font-family: 微软雅黑;\">对象，例如页面有个</span><span style=\"font-family: 宋体;\">id</span><span style=\"font-family: 微软雅黑;\">为</span><span style=\"font-family: 宋体;\">myDiv</span><span style=\"font-family: 微软雅黑;\">的</span><span style=\"font-family: 宋体;\">DIV</span><span style=\"font-family: 微软雅黑;\">对象，可以使用</span><span style=\"font-family: 宋体;\">var domObj = $(</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&ldquo;</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">#myDiv</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&rdquo;</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">)[0]</span><span style=\"font-family: 微软雅黑;\">这种方式来获取该</span><span style=\"font-family: 宋体;\">DIV</span><span style=\"font-family: 微软雅黑;\">对应的</span><span style=\"font-family: 宋体;\">dom</span><span style=\"font-family: 微软雅黑;\">对象</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">通过</span><span style=\"font-family: 宋体;\">get(index)</span><span style=\"font-family: 微软雅黑;\">去得到相应的</span><span style=\"font-family: 宋体;\">DOM</span><span style=\"font-family: 微软雅黑;\">对象，</span><span style=\"font-family: 宋体;\">var domObj = $(</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&ldquo;</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">#myDiv</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&rdquo;</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">).get(0);</span></span></li>\n</ol>\n<p class=\"MsoNormal\" style=\"margin-left: 11.0000pt; mso-para-margin-left: 1.0000gd;\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">DOM</span><span style=\"font-family: 微软雅黑;\">对象转</span><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">对象</span><span style=\"font-family: 宋体;\">:</span></span></strong></p>\n<p class=\"MsoNormal\" style=\"margin-left: 33pt; line-height: 1;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">直接使用</span><span style=\"font-family: 宋体;\">$(DOM</span><span style=\"font-family: 微软雅黑;\">对象</span><span style=\"font-family: 宋体;\">)</span><span style=\"font-family: 微软雅黑;\">来转换</span><span style=\"font-family: 宋体;\">,</span><span style=\"font-family: 微软雅黑;\">示例代码：</span></span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 33pt; line-height: 1;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">var &nbsp;domObj = document.getElementById(</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&ldquo;</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">myDiv</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&rdquo;</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">); </span></span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 33pt; line-height: 1;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">var &nbsp;jQueryObj = $(domObj);</span></span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 33pt; line-height: 1;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">$()</span><span style=\"font-family: 微软雅黑;\">就相当于一个</span><span style=\"font-family: 宋体;\">jquery</span><span style=\"font-family: 微软雅黑;\">对象的构造函数</span></span></p>","rank_id":17,"createdAt":"2021-06-15T03:02:15.615Z","updatedAt":"2021-06-15T03:02:15.615Z","__v":0},{"_id":"60c818b9da9b3346d469d670","title":"解决jQuery和其它库的冲突","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">调用</span><span style=\"font-family: 宋体;\">jQuery.noConflict()</span><span style=\"font-family: 微软雅黑;\">放弃对变量</span><span style=\"font-family: 宋体;\">$</span><span style=\"font-family: 微软雅黑;\">的控制权，然后可以直接使用</span><span style=\"font-family: 宋体;\">jQuery()</span><span style=\"font-family: 微软雅黑;\">来代替</span><span style=\"font-family: 宋体;\">$()</span><span style=\"font-family: 微软雅黑;\">的调用方式。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">两全其美的方式：</span></li>\n</ol>\n<pre class=\"language-javascript\"><code>jQuery.noConflict();//移交变量$控制权\n\n(function($){\n\n    $(&ldquo;#myTable&rdquo;).show();//此处又可以直接使用变量$来执行jQuery的代码\n\n})(jQuery)</code></pre>","rank_id":18,"createdAt":"2021-06-15T03:04:25.531Z","updatedAt":"2021-06-15T03:04:25.531Z","__v":0},{"_id":"60c81978da9b3346d469d671","title":"什么是jQuery选择器","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">jQuery</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">选择器继承了</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">CSS</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">与</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">Path</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">语言的部分语法，允许通过标签名、属性名或内容对</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">DOM</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">元素进行快速、准确的选择，而不必担心浏览器的兼容性，通过</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">jQuery</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">选择器对页面的元素的精准定位，才能完成元素属性和行为的处理。</span><span style=\"font-family: 微软雅黑; font-size: 11pt;\">选择器是</span><span style=\"font-family: 宋体; font-size: 11pt;\">jQuery</span><span style=\"font-family: 微软雅黑; font-size: 11pt;\">的根基，在</span><span style=\"font-family: 宋体; font-size: 11pt;\">jQuery</span><span style=\"font-family: 微软雅黑; font-size: 11pt;\">中，对象的事件处理，遍历</span><span style=\"font-family: 宋体; font-size: 11pt;\">DOM</span><span style=\"font-family: 微软雅黑; font-size: 11pt;\">和</span><span style=\"font-family: 宋体; font-size: 11pt;\">Ajax</span><span style=\"font-family: 微软雅黑; font-size: 11pt;\">操作都依赖于选择器</span><span style=\"font-family: 宋体; font-size: 11pt;\">&nbsp;</span></li>\n<li class=\"MsoNormal\"><span style=\"font-family: 'arial black', sans-serif; font-size: 11pt;\"><span style=\"font-family: 'courier new', courier, monospace;\">jQuery</span>选择器的优点：</span></li>\n</ol>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">简洁的写法</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">完善的事件处理机制</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">支持</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">CSS1</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">到</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">CSS3</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">选择器</span></span></li>\n</ul>\n</li>\n</ul>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\">&nbsp;</p>","rank_id":19,"createdAt":"2021-06-15T03:07:36.936Z","updatedAt":"2021-06-15T03:07:36.936Z","__v":0},{"_id":"60c81a80da9b3346d469d672","title":"jQuery选择器的种类","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">基本选择器</span></strong></p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">基本选择器是</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">jQuery</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">中最常见的选择器，也是最简单的选择器，它通过元素</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">id,class</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">和标记名来查找</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">DOM</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">元素</span></li>\n</ul>\n</li>\n</ul>\n<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">层次选择器</span></strong></p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">如果想通过</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">DOM</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">元素之间的层次关系来获取特定元素，就需要使用层次选择器</span></li>\n</ul>\n</li>\n</ul>\n<p><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">过滤器选择器</span></strong></p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">过滤选择器主要是通过特定的过滤规则来筛选出所需的</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">DOM</span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">元素，该选择器都以</span><span style=\"font-family: 微软雅黑;\">&ldquo;：&rdquo;开头，过滤选择器又分以下几种</span></span></li>\n</ul>\n</li>\n</ul>\n<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">表单选择器</span></strong></p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">表单选择器主要是通过所选择的表单元素进行过滤</span></li>\n</ul>\n</li>\n</ul>\n<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">属性选择器</span></strong></p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">属性过滤选择器的过滤规则是通过元素的属性来获取相应的元素</span></li>\n</ul>\n</li>\n</ul>\n<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">内容过滤器选择器</span></strong></p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li class=\"MsoNormal\"><span style=\"font-family: 微软雅黑; font-size: 11pt;\">内容过滤选择器的过滤规则主要体现在它所包含的子元素和和文本内容上</span></li>\n</ul>\n</li>\n</ul>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\">&nbsp;</p>\n<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">可见性过滤选择器</span></strong></p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul>\n<li class=\"MsoNormal\"><span style=\"font-family: 微软雅黑; font-size: 11pt;\">可见性过滤选择器是根据元素的可见和不可见状态来选择相应的元素</span></li>\n</ul>\n</li>\n</ul>","rank_id":20,"createdAt":"2021-06-15T03:12:00.540Z","updatedAt":"2021-06-15T03:12:00.540Z","__v":0},{"_id":"60c81acada9b3346d469d673","title":"Query中的选择器 和 css中的选择器有区别吗？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">选择器支持</span><span style=\"font-family: 宋体;\">CSS</span><span style=\"font-family: 微软雅黑;\">里的选择器，</span><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">选择器可用来添加样式和添加相应的为</span><span style=\"font-family: 宋体;\">CSS </span><span style=\"font-family: 微软雅黑;\">中的选择器是只能添加相应的样式。</span></span></p>","rank_id":21,"createdAt":"2021-06-15T03:13:14.311Z","updatedAt":"2021-06-15T03:13:14.311Z","__v":0},{"_id":"60c81b1bda9b3346d469d674","title":"siblings() 方法 和 $('prev~div')选择器是一样的嘛？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">$('prev~div') </span><span style=\"font-family: 微软雅黑;\">只能选择</span><span style=\"font-family: 宋体;\">'#prev'</span><span style=\"font-family: 微软雅黑;\">元素后面的同辈</span><span style=\"font-family: 宋体;\">&lt;div&gt;</span><span style=\"font-family: 微软雅黑;\">元素而</span><span style=\"font-family: 宋体;\">siblings()</span><span style=\"font-family: 微软雅黑;\">方法与前后的位置无关，只要是同辈节点就都能匹配。</span></span></p>","rank_id":22,"createdAt":"2021-06-15T03:14:35.540Z","updatedAt":"2021-06-15T03:14:35.540Z","__v":0},{"_id":"60c81b44da9b3346d469d675","title":"jQuery中的hover()和toggle()有什么区别？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">hover()</span><span style=\"font-family: 微软雅黑;\">和</span><span style=\"font-family: 宋体;\">toggle()</span><span style=\"font-family: 微软雅黑;\">都是</span><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">中两个合成事件：</span></span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">hover()</span><span style=\"font-family: 微软雅黑;\">方法用于模拟光标悬停事件。</span></span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">toggle()</span><span style=\"font-family: 微软雅黑;\">方法是连续点击事件。</span></span></p>","rank_id":23,"createdAt":"2021-06-15T03:15:16.172Z","updatedAt":"2021-06-15T03:15:16.172Z","__v":0},{"_id":"60c81b76da9b3346d469d676","title":"你是如何使用jQuery中的ajax的？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">如果是一些常规的</span><span style=\"font-family: 宋体;\">ajax</span><span style=\"font-family: 微软雅黑;\">程序的话，使用</span><span style=\"font-family: 宋体;\">$.load(),$.get(),$.post(),</span><span style=\"font-family: 微软雅黑;\">就可以搞定了，</span></span><span style=\"font-family: 微软雅黑; font-size: 11pt;\">一般我会使用的是</span><span style=\"font-size: 11pt; font-family: 宋体;\">$.get() </span><span style=\"font-family: 微软雅黑; font-size: 11pt;\">方法。</span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">如果需要设定</span><span style=\"font-family: 宋体;\">beforeSend(</span><span style=\"font-family: 微软雅黑;\">提交前回调函数</span><span style=\"font-family: 宋体;\">),error(</span><span style=\"font-family: 微软雅黑;\">失败后处理</span><span style=\"font-family: 宋体;\">),success(</span><span style=\"font-family: 微软雅黑;\">成功后处理</span><span style=\"font-family: 宋体;\">)</span></span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">及</span><span style=\"font-family: 宋体;\">complete(</span><span style=\"font-family: 微软雅黑;\">请求完成后处理</span><span style=\"font-family: 宋体;\">)</span><span style=\"font-family: 微软雅黑;\">回调函数等，这个时候我会使用</span><span style=\"font-family: 宋体;\">$.ajax()</span></span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\">&nbsp;</p>","rank_id":24,"createdAt":"2021-06-15T03:16:06.463Z","updatedAt":"2021-06-15T03:16:06.463Z","__v":0},{"_id":"60c81b9fda9b3346d469d677","title":"jQuery中$.get()提交和$.post()提交有区别吗？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">$.get() </span><span style=\"font-family: 微软雅黑;\">方法使用</span><span style=\"font-family: 宋体;\">GET</span><span style=\"font-family: 微软雅黑;\">方法来进行异步请求的，</span><span style=\"font-family: 宋体;\">$.post() </span><span style=\"font-family: 微软雅黑;\">方法使用</span><span style=\"font-family: 宋体;\">POST</span><span style=\"font-family: 微软雅黑;\">方法来进行异步请求的。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">get</span><span style=\"font-family: 微软雅黑;\">请求会将参数跟在</span><span style=\"font-family: 宋体;\">URL</span><span style=\"font-family: 微软雅黑;\">后进行传递，而</span><span style=\"font-family: 宋体;\">POST</span><span style=\"font-family: 微软雅黑;\">请求则是作为</span><span style=\"font-family: 宋体;\">HTTP</span><span style=\"font-family: 微软雅黑;\">消息的实体正文内容发送给</span><span style=\"font-family: 宋体;\">Web</span><span style=\"font-family: 微软雅黑;\">服务器的，这种传递是对用户不可见的。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">get</span><span style=\"font-family: 微软雅黑;\">方式传输的数据大小不能超过</span><span style=\"font-family: 宋体;\">2KB </span><span style=\"font-family: 微软雅黑;\">而</span><span style=\"font-family: 宋体;\">POST</span><span style=\"font-family: 微软雅黑;\">要大的多</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">GET </span><span style=\"font-family: 微软雅黑;\">方式请求的数据会被浏览器缓存起来，因此有安全问题。</span></span></li>\n</ol>","rank_id":25,"createdAt":"2021-06-15T03:16:47.822Z","updatedAt":"2021-06-15T03:16:47.822Z","__v":0},{"_id":"60c81bcada9b3346d469d678","title":"jQuery中的load方法一般怎么用的？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">load</span><span style=\"font-family: 微软雅黑;\">方法一般在 载入远程</span><span style=\"font-family: 宋体;\">HTML </span><span style=\"font-family: 微软雅黑;\">代码并插入到</span><span style=\"font-family: 宋体;\">DOM</span><span style=\"font-family: 微软雅黑;\">中的时候用通常用来从</span><span style=\"font-family: 宋体;\">Web</span><span style=\"font-family: 微软雅黑;\">服务器上获取静态的数据文件。</span></span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">如果要传递参数的话，可以使用</span><span style=\"font-family: 宋体;\">$.get() </span><span style=\"font-family: 微软雅黑;\">或 </span><span style=\"font-family: 宋体;\">$.post()</span><span style=\"font-family: 微软雅黑;\">。</span></span></p>","rank_id":26,"createdAt":"2021-06-15T03:17:30.483Z","updatedAt":"2021-06-15T03:17:30.483Z","__v":0},{"_id":"60c81bedda9b3346d469d679","title":"在jQuery执行ajax中，提交的data（数据）主要有几种方式？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">三种，</span><span style=\"font-family: 宋体;\">html</span><span style=\"font-family: 微软雅黑;\">拼接的，</span><span style=\"font-family: 宋体;\">json</span><span style=\"font-family: 微软雅黑;\">数组，</span><span style=\"font-family: 宋体;\">form</span><span style=\"font-family: 微软雅黑;\">表单经</span><span style=\"font-family: 宋体;\">serialize()</span><span style=\"font-family: 微软雅黑;\">序列化的。</span></span></p>","rank_id":27,"createdAt":"2021-06-15T03:18:05.084Z","updatedAt":"2021-06-15T03:18:05.084Z","__v":0},{"_id":"60c81c4fda9b3346d469d67a","title":"jQuery是如何处理缓存的？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">通过</span><span style=\"font-family: 宋体;\">$.post()</span><span style=\"font-family: 微软雅黑;\">方法来获取数据，那么默认就是禁用缓存的。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">通过</span><span style=\"font-family: 宋体;\">$.get()</span><span style=\"font-family: 微软雅黑;\">方法来获取数据，可以通过设置时间戳来避免缓存。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">可以在</span><span style=\"font-family: 宋体;\">URL</span><span style=\"font-family: 微软雅黑;\">后面加上</span><span style=\"font-family: 宋体;\">+(+new Date)</span><span style=\"font-family: 微软雅黑;\">来增加上时间戳参数</span></span></span>\n<pre class=\"language-javascript\"><code>例：\n$.get('ajax.xml?'+(+new Date),function () {\n    //函数内容代码\n});</code></pre>\n</li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">通过</span><span style=\"font-family: 宋体;\">$.ajax</span><span style=\"font-family: 微软雅黑;\">方法来获取数据，只要设置参数</span><span style=\"font-family: 宋体;\">cache:false</span><span style=\"font-family: 微软雅黑;\">即可。</span></span></li>\n</ol>","rank_id":28,"createdAt":"2021-06-15T03:19:43.489Z","updatedAt":"2021-06-15T03:19:43.489Z","__v":0},{"_id":"60c81c69da9b3346d469d67b","title":"你知道jQuery中的事件冒泡吗，它是怎么执行的，何如来停止冒泡事件？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">事件冒泡是从里面的往外面开始触发。</span></span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">在</span><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">中提供了</span><span style=\"font-family: 宋体;\">stopPropagation()</span><span style=\"font-family: 微软雅黑;\">方法可以停止冒泡。</span></span></p>","rank_id":29,"createdAt":"2021-06-15T03:20:09.989Z","updatedAt":"2021-06-15T03:20:09.989Z","__v":0},{"_id":"60c81c8eda9b3346d469d67c","title":"单击超链接后会自动跳转，单击\"提交\"按钮后表单会提交等，有时候我想阻止这些默认的行为，该怎么办？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">可以用</span> <span style=\"font-family: 宋体;\">event.preventDefault()</span></span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">或</span> <span style=\"font-family: 微软雅黑;\">在事件处理函数中返回</span><span style=\"font-family: 宋体;\">false</span><span style=\"font-family: 微软雅黑;\">，即 </span><span style=\"font-family: 宋体;\">return false;</span></span></p>","rank_id":30,"createdAt":"2021-06-15T03:20:46.716Z","updatedAt":"2021-06-15T03:20:46.716Z","__v":0},{"_id":"60c81caada9b3346d469d67d","title":"你使用过jQuery中的动画吗，是怎样用的？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">hide() </span><span style=\"font-family: 微软雅黑;\">和 </span><span style=\"font-family: 宋体;\">show() </span><span style=\"font-family: 微软雅黑;\">同时修改多个样式属性。像高度，宽度，不透明度。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">fadeIn() </span><span style=\"font-family: 微软雅黑;\">和</span><span style=\"font-family: 宋体;\">fadeOut() fadeTo() </span><span style=\"font-family: 微软雅黑;\">只改变不透明度</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">slideUp() </span><span style=\"font-family: 微软雅黑;\">和 </span><span style=\"font-family: 宋体;\">slideDown() slideToggle() </span><span style=\"font-family: 微软雅黑;\">只改变高度</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">animate() </span><span style=\"font-family: 微软雅黑;\">属于自定义动画的方法</span><span style=\"font-family: 宋体;\">.</span></span></li>\n</ol>","rank_id":31,"createdAt":"2021-06-15T03:21:14.348Z","updatedAt":"2021-06-15T03:21:14.348Z","__v":0},{"_id":"60c81cd2da9b3346d469d67e","title":"怎样给jQuery动态附加新的元素?那么怎样给新生成的元素绑定事件呢？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">的</span><span style=\"font-family: 宋体;\">html()</span><span style=\"font-family: 微软雅黑;\">可以给现有元素附加新的元素。</span></span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">直接在元素还未生成前就绑定肯定是无效的，因为所绑定的元素目前根本不存在。</span></p>\n<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">所以我们可以通过</span><span style=\"font-family: 宋体;\">live</span><span style=\"font-family: 微软雅黑;\">和</span><span style=\"font-family: 宋体;\">livequery</span><span style=\"font-family: 微软雅黑;\">来动态绑定事件，这种绑定方式对现有和新生成的元素都有效。</span></span></p>","rank_id":32,"createdAt":"2021-06-15T03:21:54.309Z","updatedAt":"2021-06-15T03:21:54.309Z","__v":0},{"_id":"60c81d26da9b3346d469d67f","title":"$(\"#msg\").text()和 $(\"#msg\").text(\"<b>new content</b>\")有什么区别？ $(\"#msg\").html()及$(\"#msg\").html(\"<b>new content</b>\")的区别呢？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"MsoNormal\" style=\"line-height: 2;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">$(\"#msg\").text() </span><span style=\"font-family: 微软雅黑;\">是 返回</span><span style=\"font-family: 宋体;\">id</span><span style=\"font-family: 微软雅黑;\">为</span><span style=\"font-family: 宋体;\">msg</span><span style=\"font-family: 微软雅黑;\">的元素节点的文本内容</span></span></li>\n<li class=\"MsoNormal\" style=\"line-height: 2;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"> </span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">$(\"#msg\").text(\"&lt;b&gt;new content&lt;/b&gt;\"); </span><span style=\"font-family: 微软雅黑;\">是 将&ldquo;</span><span style=\"font-family: 宋体;\">&lt;b&gt;new content&lt;/b&gt;</span><span style=\"font-family: 微软雅黑;\">&rdquo; 作为普通文本串写入</span><span style=\"font-family: 宋体;\">id</span><span style=\"font-family: 微软雅黑;\">为</span><span style=\"font-family: 宋体;\">msg</span><span style=\"font-family: 微软雅黑;\">的元素节点内容中</span><span style=\"font-family: 宋体;\">,</span><span style=\"font-family: 微软雅黑;\">页面直接显示&ldquo;</span></span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">&lt;b&gt;new content&lt;/b&gt;</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">&rdquo;，</span><span style=\"font-family: 宋体;\">text()</span><span style=\"font-family: 微软雅黑;\">方法</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">对</span>HTML<span style=\"font-family: 微软雅黑;\">和</span><span style=\"font-family: 宋体;\">XML</span><span style=\"font-family: 微软雅黑;\">文档都有效</span></span></li>\n<li class=\"MsoNormal\" style=\"line-height: 2;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"> </span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">$(\"#msg\").html()</span><span style=\"font-family: 微软雅黑;\">则是</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">取得</span></span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">id</span><span style=\"font-family: 微软雅黑;\">为</span><span style=\"font-family: 宋体;\">msg</span><span style=\"font-family: 微软雅黑;\">的元素节点</span></span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">的</span>html<span style=\"font-family: 微软雅黑;\">内容。这个函数</span></span><strong><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">不能用于</span>XML</span></strong><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-fareast-font-family: 微软雅黑; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">文档。但可以用于</span>XHTML<span style=\"font-family: 微软雅黑;\">文档</span></span></li>\n<li class=\"MsoNormal\" style=\"line-height: 2;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"> </span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">$(\"#msg\").html(\"&lt;b&gt;new content&lt;/b&gt;\")</span><span style=\"font-family: 微软雅黑;\">，是将&ldquo;</span><span style=\"font-family: 宋体;\">&lt;b&gt;new content&lt;/b&gt;</span><span style=\"font-family: 微软雅黑;\">&rdquo;作为</span><span style=\"font-family: 宋体;\">HTML</span><span style=\"font-family: 微软雅黑;\">内容写入</span><span style=\"font-family: 宋体;\">id</span><span style=\"font-family: 微软雅黑;\">为</span><span style=\"font-family: 宋体;\">msg</span><span style=\"font-family: 微软雅黑;\">的元素节点内容中</span><span style=\"font-family: 宋体;\">,</span><span style=\"font-family: 微软雅黑;\">页面直接显示</span></span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">粗体</span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">的</span><span style=\"font-family: 微软雅黑;\">&ldquo;</span></span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">new content</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&rdquo;内容</span></li>\n</ol>","rank_id":33,"createdAt":"2021-06-15T03:23:18.662Z","updatedAt":"2021-06-15T03:23:18.662Z","__v":0},{"_id":"60c81d53da9b3346d469d680","title":"jQuery中有几种方法可以来设置和获取 样式","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h4><strong><span style=\"font-family: 宋体; font-size: 14pt;\"><span style=\"font-family: Cambria;\">addClass() </span><span style=\"font-family: 宋体;\">方法，</span><span style=\"font-family: Cambria;\">attr() </span><span style=\"font-family: 宋体;\">方法</span></span></strong></h4>","rank_id":34,"createdAt":"2021-06-15T03:24:03.548Z","updatedAt":"2021-06-15T03:24:03.548Z","__v":0},{"_id":"60c81d6cda9b3346d469d681","title":"jQuery中如何来获取或和设置属性？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\" style=\"margin-left: 22.0000pt; mso-para-margin-left: 2.0000gd;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">jQuery</span><span style=\"font-family: 微软雅黑;\">中可以用</span><span style=\"font-family: 宋体;\">attr()</span><span style=\"font-family: 微软雅黑;\">方法来获取和设置元素属性</span></span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">removeAttr() </span><span style=\"font-family: 微软雅黑;\">方法来删除元素属性</span></span></p>","rank_id":35,"createdAt":"2021-06-15T03:24:28.082Z","updatedAt":"2021-06-15T03:24:28.082Z","__v":0},{"_id":"60c81f7fda9b3346d469d682","title":"Javascript中String对象常用方法？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">属性</span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">length</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">的用法：字符串对象</span><span style=\"font-family: 宋体;\">.length</span><span style=\"font-family: 微软雅黑;\">。</span></span></p>\n<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">字符串对象常用方法：</span></p>\n<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"> </span><span style=\"font-family: 'courier new', courier, monospace;\"><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">tolowerCase() </span><span style=\"font-family: 微软雅黑;\">：把字符串转换为小写。</span></span></span></li>\n<li class=\"MsoNormal\"><span style=\"font-family: 'courier new', courier, monospace;\"><span style=\"font-size: 11pt;\"> </span><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">toUpperCase( )</span><span style=\"font-family: 微软雅黑;\">：把字符串转换为大写。</span></span></span></li>\n<li class=\"MsoNormal\"><span style=\"font-family: 'courier new', courier, monospace;\"><span style=\"font-size: 11pt;\"> </span><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">charAt(index) </span><span style=\"font-family: 微软雅黑;\">：返回在指定位置中的字符。</span></span></span></li>\n<li class=\"MsoNormal\"><span style=\"font-family: 'courier new', courier, monospace;\"><span style=\"font-size: 11pt;\"> </span><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">indexOf(str</span><span style=\"font-family: 微软雅黑;\">，</span><span style=\"font-family: 宋体;\">index)</span><span style=\"font-family: 微软雅黑;\">： 查找某个指定的字符串在字符串中首次出现的位置。</span></span></span></li>\n<li class=\"MsoNormal\"><span style=\"font-family: 'courier new', courier, monospace;\"><span style=\"font-size: 11pt;\"> </span><span style=\"font-size: 11pt;\"><span style=\"font-family: 宋体;\">substring(index1,index2)</span><span style=\"font-family: 微软雅黑;\">： 返回位于指定索引</span><span style=\"font-family: 宋体;\">index1</span><span style=\"font-family: 微软雅黑;\">和</span><span style=\"font-family: 宋体;\">index2</span><span style=\"font-family: 微软雅黑;\">之间的字符串，并且包括索引</span><span style=\"font-family: 宋体;\">index1</span><span style=\"font-family: 微软雅黑;\">的位置，不包括</span><span style=\"font-family: 宋体;\">index2</span><span style=\"font-family: 微软雅黑;\">对应的位置。</span></span></span></li>\n<li><span style=\"font-family: 'courier new', courier, monospace;\">str.split(str) 把字符串转换为数组</span></li>\n<li><span style=\"color: rgba(0, 0, 0, 0.75); font-family: 'courier new', courier, monospace; font-size: 16px; font-variant-ligatures: common-ligatures; background-color: #ffffff;\">str.trim(str) 删除字符串两端的空白符</span></li>\n<li><span style=\"font-family: 'courier new', courier, monospace;\"><span style=\"color: rgba(0, 0, 0, 0.75); font-size: 16px; font-variant-ligatures: common-ligatures; background-color: #ffffff;\">str.concat(str1,str2,...) concat() 连接两个或多个字符串 ;方法可用于代替加运算符</span></span></li>\n<li><span style=\"font-family: 'courier new', courier, monospace;\"><span style=\"color: rgba(0, 0, 0, 0.75); font-size: 16px; font-variant-ligatures: common-ligatures; background-color: #ffffff;\">str.replace(reg,target) 用另一个值替换在字符串中指定的值,不会改变调用它的字符串。它返回的是新字符串</span></span></li>\n<li><span style=\"font-family: 'courier new', courier, monospace;\"><span style=\"color: rgba(0, 0, 0, 0.75); font-size: 16px; font-variant-ligatures: common-ligatures; background-color: #ffffff;\">str.substr(start,length) 方法 substr() 类似于 slice()。不同之处在于第二个参数规定被提取部分的长度。如果首个参数为负，则从字符串的结尾计算位置。第二个参数不能为负，因为它定义的是长度。</span></span></li>\n<li><span style=\"color: rgba(0, 0, 0, 0.75); font-family: 'courier new', courier, monospace; font-size: 16px; font-variant-ligatures: common-ligatures; background-color: #ffffff;\">str.slice(start, end) 提取字符串的某个部分并在新字符串中返回被提取的部分。如果某个参数为负，则从字符串的结尾开始计数;如果省略第二个参数，则该方法将裁剪字符串的剩余部分.</span></li>\n<li><span style=\"color: rgba(0, 0, 0, 0.75); font-family: 'courier new', courier, monospace; font-size: 16px; font-variant-ligatures: common-ligatures; background-color: #ffffff;\">str.substring() 方法 substring() 类似于 slice()。不同之处在于 substring() 无法接受负的索引</span></li>\n<li><span style=\"color: rgba(0, 0, 0, 0.75); font-family: 'courier new', courier, monospace; font-size: 16px; font-variant-ligatures: common-ligatures; background-color: #ffffff;\">str.lastIndexOf() 方法返回指定文本在字符串中最后一次出现的索引</span></li>\n</ol>","rank_id":36,"createdAt":"2021-06-15T03:33:19.430Z","updatedAt":"2021-06-15T03:33:19.430Z","__v":0},{"_id":"60c82066da9b3346d469d683","title":"文本框对象常用的方法和事件","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">事件：</span></strong></p>\n<ul>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">onblur</span><span style=\"font-family: 微软雅黑;\">：失去焦点，当光标离开某个文本框时触发。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">onfocus</span><span style=\"font-family: 微软雅黑;\">：获得焦点，当光标进入某个文本框时触发。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">onkeypress</span><span style=\"font-family: 微软雅黑;\">：某个键盘按键被按下并松开。</span></span></li>\n</ul>\n<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">方法：</span></strong></p>\n<ul>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">blur</span><span style=\"font-family: 微软雅黑;\">：从文本框中移开焦点。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">focus</span><span style=\"font-family: 微软雅黑;\">：在文本框中设置焦点，即获得鼠标光标。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">select</span><span style=\"font-family: 微软雅黑;\">：选取文本域中的内容。</span></span></li>\n</ul>\n<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\">属性：</span></strong></p>\n<ul>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">id</span><span style=\"font-family: 微软雅黑;\">：设置或返回文本域的</span><span style=\"font-family: 宋体;\">ID</span><span style=\"font-family: 微软雅黑;\">。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">value</span><span style=\"font-family: 微软雅黑;\">：设置返回文本域的</span><span style=\"font-family: 宋体;\">value</span><span style=\"font-family: 微软雅黑;\">属性的值。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">name</span><span style=\"font-family: 微软雅黑;\">：控件的名称</span></span></li>\n</ul>\n<p><span style=\"font-family: 微软雅黑; font-size: 11pt; text-indent: 33pt;\">制作文本输入提示特效，使用</span><span style=\"font-size: 11pt; text-indent: 33pt; font-family: 宋体;\">innerHTML</span><span style=\"font-family: 微软雅黑; font-size: 11pt; text-indent: 33pt;\">属性动态改变层中的提示内容。</span></p>","rank_id":37,"createdAt":"2021-06-15T03:37:10.701Z","updatedAt":"2021-06-15T03:37:10.701Z","__v":0},{"_id":"60c820adda9b3346d469d684","title":"正则表达式的概念","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个</span><span style=\"font-family: 微软雅黑;\">&ldquo;规则字符串&rdquo;，这个&ldquo;规则字符串&rdquo;用来表达对字符串的一种过滤逻辑。&nbsp;</span></span></p>\n<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">正则表达式作用：</span></p>\n<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"> </span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">测试给定的字符串是否符合正则表达式的过滤逻辑（称作&ldquo;匹配&rdquo;）；</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">可以通过正则表达式，从字符串中获取我们想要的特定部分。 　　</span></span></li>\n</ol>\n<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">正则表达式的特点是：</span></p>\n<ol>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"> </span><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">灵活性、逻辑性和功能性非常的强；</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">可以迅速地用极简单的方式达到字符串的复杂控制。</span></span></li>\n<li class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">对于刚接触的人来说，比较晦涩难懂。 　　</span></span></li>\n</ol>\n<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用，小到著名编辑器</span><span style=\"font-family: 宋体;\">EditPlus</span><span style=\"font-family: 微软雅黑;\">，大到</span><span style=\"font-family: 宋体;\">Microsoft Word</span><span style=\"font-family: 微软雅黑;\">、</span><span style=\"font-family: 宋体;\">Visual Studio</span><span style=\"font-family: 微软雅黑;\">等大型编辑器，都可以使用正则表达式来处理文本内容。</span></span></p>","rank_id":38,"createdAt":"2021-06-15T03:38:21.510Z","updatedAt":"2021-06-15T03:38:21.510Z","__v":0},{"_id":"60c820c6da9b3346d469d685","title":"正则表达式有几种构造方式，分别是什么？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">一种是普通方式</span> &nbsp;<span style=\"font-family: 宋体;\">var reg = /</span><span style=\"font-family: 微软雅黑;\">表达式</span><span style=\"font-family: 宋体;\">/;</span></span></p>\n<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;&nbsp;<span style=\"font-family: 微软雅黑;\">一种是构造方式</span> &nbsp;<span style=\"font-family: 宋体;\">var reg = new RegExp(</span><span style=\"font-family: 微软雅黑;\">&lsquo;表达式&rsquo;</span><span style=\"font-family: 宋体;\">,</span><span style=\"font-family: 微软雅黑;\">&rsquo;参数&rsquo;</span><span style=\"font-family: 宋体;\">);</span></span></p>","rank_id":39,"createdAt":"2021-06-15T03:38:46.156Z","updatedAt":"2021-06-15T03:38:46.156Z","__v":0},{"_id":"60c820f9da9b3346d469d686","title":"RegExp对象使用什么方法匹配正则表达式？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">test()</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\"><span style=\"font-family: 微软雅黑;\">：检索字符串中指定的值，返回</span><span style=\"font-family: 宋体;\">true</span><span style=\"font-family: 微软雅黑;\">或 </span><span style=\"font-family: 宋体;\">false</span></span></p>\n<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">&nbsp;&nbsp;</span><strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; mso-ansi-font-weight: bold; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">exec()</span></span></strong><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 'Times New Roman'; font-size: 11.0000pt;\">：检索字符中是正则表达式的匹配，返回找到的值，并确定位置。</span></p>","rank_id":40,"createdAt":"2021-06-15T03:39:37.651Z","updatedAt":"2021-06-15T03:39:37.651Z","__v":0},{"_id":"60c8211fda9b3346d469d687","title":"用正则表达式写出HTTP的url格式","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\" style=\"text-indent: 21.0000pt;\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 宋体; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">/^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$/</span></span></p>\n<p class=\"MsoNormal\"><span style=\"mso-spacerun: 'yes'; font-family: 微软雅黑; mso-ascii-font-family: 宋体; mso-hansi-font-family: 宋体; mso-bidi-font-family: 宋体; font-size: 11.0000pt;\"><span style=\"font-family: 宋体;\">http://baike.baidu.com/view/94238.htm?fr=aladdin</span></span></p>","rank_id":41,"createdAt":"2021-06-15T03:40:15.557Z","updatedAt":"2021-06-15T03:40:15.557Z","__v":0},{"_id":"60c821c4da9b3346d469d689","title":"v-show和v-if指令的共同点和不同点?","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><!-- [if !supportLists]--><span style=\"font-size: 12pt;\"><span class=\"15\" style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">v-show</span></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">指令是通过修改元素的</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">display</span></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">CSS属性让其显示或者隐藏</span></span></span></li>\n<li><span style=\"font-size: 12pt;\"><!--[endif]--><span class=\"15\" style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">v-if</span></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">指令是直接销毁和重建</span><span style=\"font-family: 微软雅黑;\">DOM达到让元素显示和隐藏的效果</span></span></span></li>\n</ul>","rank_id":43,"createdAt":"2021-06-15T03:43:00.461Z","updatedAt":"2021-06-15T03:43:00.461Z","__v":0},{"_id":"60c821f8da9b3346d469d68a","title":"如何让CSS只在当前组件中起作用?","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p class=\"p\" style=\"padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-size: 12pt;\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">将当前组件的</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">&lt;style&gt;</span></span><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">修改为</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">&lt;style scoped&gt;</span></span></span></p>","rank_id":44,"createdAt":"2021-06-15T03:43:52.124Z","updatedAt":"2021-06-15T03:43:52.124Z","__v":0},{"_id":"60c82273da9b3346d469d68c","title":"<keep-alive></keep-alive>的作用是什么?","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"p\" style=\"word-break: break-all; text-align: justify; line-height: 15.6pt;\"><span class=\"15\" style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">&lt;keep-alive&gt;&lt;/keep-alive&gt;</span></span><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">&nbsp;包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。</span></span></li>\n<li class=\"p\" style=\"word-break: break-all; text-align: justify; line-height: 15.6pt;\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">大白话</span><span style=\"font-family: 微软雅黑;\">: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情&hellip;这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">&lt;keep-alive&gt;&lt;/keep-alive&gt;</span></span><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</span></span></li>\n</ul>","rank_id":45,"createdAt":"2021-06-15T03:45:55.368Z","updatedAt":"2021-06-15T03:45:55.368Z","__v":0},{"_id":"60c822f4da9b3346d469d68d","title":"Vue中引入组件的步骤?","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p class=\"p\" style=\"padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-size: 12pt;\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">1.采用ES6的</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">import ... from ...</span></span><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">语法或</span><span style=\"font-family: 微软雅黑;\">CommonJS的</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">require()</span></span><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">方法引入组件</span></span><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><br /></span><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">2.对组件进行注册,代码如</span></span><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">下:</span></span></span></p>\n<pre class=\"language-javascript\"><code>Vue.component('my-component', {\n  template: '&lt;div&gt;A custom component!&lt;/div&gt;'\n})</code></pre>\n<p><span style=\"font-size: 12pt;\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">3.使用组件</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">&lt;my-component&gt;&lt;/my-component&gt;</span></span></span></p>","rank_id":46,"createdAt":"2021-06-15T03:48:04.846Z","updatedAt":"2021-06-15T03:48:04.846Z","__v":0},{"_id":"60c8231bda9b3346d469d68e","title":"在Vue中使用插件的步骤","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"MsoNormal\" style=\"text-indent: -18pt; word-break: break-all;\"><!-- [if !supportLists]--><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 12pt; background: #ffffff;\">1.&nbsp;</span><!--[endif]--><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">采用</span><span style=\"font-family: 微软雅黑;\">ES6的</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">import ... from ...</span></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">语法或</span><span style=\"font-family: 微软雅黑;\">CommonJSd的</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">require()</span></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">方法引入插件</span></span></li>\n<li class=\"MsoNormal\" style=\"text-indent: -18pt; word-break: break-all;\"><!-- [if !supportLists]--><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 12pt; background: #ffffff;\">2.&nbsp;</span><!--[endif]--><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">使用全局方法</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">Vue.use( plugin )</span></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">使用插件</span><span style=\"font-family: 微软雅黑;\">,可以传入一个选项对象</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">Vue.use(MyPlugin, { someOption: true })</span></span></li>\n</ol>","rank_id":47,"createdAt":"2021-06-15T03:48:43.217Z","updatedAt":"2021-06-15T03:48:43.217Z","__v":0},{"_id":"60c826cfda9b3346d469d68f","title":"什么是Vue生命周期？Vue生命周期的作用是什么？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\">vue生命周期是指vue是对象从创建到销毁的过程。</span></p>\n<div>\n<div>在vue生命周期的不同阶段通过对应的钩子函数来实现组件数据管理和DOM渲染两大重要功能。</div>\n<p>创建阶段：</p>\n<ul>\n<li><code>beforecreate：</code>实例已经初始化，但不能获取DOM节点。(没有data，没有el)</li>\n<li><code>created:</code>实例已经创建，仍然不能获取DOM节点。(有data，没有el)</li>\n</ul>\n<div>载入阶段：</div>\n<ul>\n<li><code>beforemount：</code>模板编译完成，但还没挂载到界面上。(有data，有el)</li>\n<li><code>mounted：</code>编译好的模板已挂载到页面中(数据和DOM都已经渲染出来)</li>\n</ul>\n<div>更新阶段：</div>\n<ul>\n<li><code>beforeupdate：</code>数据发生变化立即调用，此时data中数据是最新的，但页面上数据仍然是旧的(检测到数据更新时，但DOM更新前执行)</li>\n<li><code>updated：</code>更新结束后执行，此时data中的值和页面上的值都是最新的</li>\n</ul>\n<div>销毁阶段：</div>\n<ul>\n<li><code>beforedestroy：</code>当要销毁vue实例时，在销毁之前执行</li>\n<li><code>destroy：</code>在销毁vue实例时执行</li>\n</ul>\n</div>","rank_id":48,"createdAt":"2021-06-15T04:04:31.240Z","updatedAt":"2021-06-15T04:04:31.240Z","__v":0},{"_id":"60c826f6da9b3346d469d690","title":"第一次页面加载会触发哪几个钩子函数？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">beforeCreate</code><span style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\">,&nbsp;</span><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">created</code><span style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\">,&nbsp;</span><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">beforeMount</code><span style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\">,&nbsp;</span><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">mounted</code></p>","rank_id":49,"createdAt":"2021-06-15T04:05:10.373Z","updatedAt":"2021-06-15T04:05:10.373Z","__v":0},{"_id":"60c82771da9b3346d469d691","title":"简述每个生命周期具体适合哪些场景？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<div>\n<ol>\n<li><code>beforecreate：</code>可以加Loading事件。</li>\n<li><code>create：</code>初始化完成时的事件写在这里，异步请求也适宜在这里调用（请求不宜过多，避免白屏时间太长）。<br />可以在这里结束loading事件，还做一些初始化，或实现函数的自执行。<br />此时未挂载DOM，若在此阶段进行DOM操作一定要放在Vue.nextTick()的回调函数中。</li>\n<li><code>mounted：</code>此时完成挂载DOM和渲染，需要操作DOM的方法可以放在这里，也可在这发起后端请求，拿回数据，配合路由钩子做一些事情。</li>\n<li><code>beforeupdate：</code>可在更新前访问现有的DOM，如手动移出添加的事件监听器。</li>\n<li><code>updated:</code>组件DOM已完成更新，可执行依赖的DOM操作。<br />注意：不要在此函数中操作数据（修改属性），会陷入死循环。</li>\n<li><code>activated：</code>在使用vue-router时有时需要使用&lt;keep-alive&gt;&lt;/keep-alive&gt;来缓存组件状态，这个时候created钩子就不会被重复调用了。<br />如果我们的子组件需要在每次加载的时候进行某些操作，可以使用activated钩子触发。</li>\n<li>deactivated：&lt;keep-alive&gt;&lt;/keep-alive&gt;组件被移除时使用。</li>\n<li><code>beforedestroy：</code>销毁前，可以做一些删除提示，如：您确定删除xx吗？</li>\n<li><code>destroy：</code>销毁后，这时组件已经没有了，无法操作里面的任何东西了。</li>\n</ol>\n</div>","rank_id":50,"createdAt":"2021-06-15T04:07:13.596Z","updatedAt":"2021-06-15T04:07:13.596Z","__v":0},{"_id":"60c8278eda9b3346d469d692","title":"created和mounted的区别？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">created:</code><span style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\">实例已经创建，但不能获取DOM节点。</span><br style=\"box-sizing: border-box; color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\" /><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">mounted：</code><span style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\">模板已经挂载到页面上，可以操作DOM元素。</span></p>","rank_id":51,"createdAt":"2021-06-15T04:07:42.546Z","updatedAt":"2021-06-15T04:07:42.546Z","__v":0},{"_id":"60c8294dda9b3346d469d693","title":"vue组件间通信方式？（尽量详细）","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\">组件之间的传值通信</span><br style=\"box-sizing: border-box; color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\" /><span style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\">组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯;</span></p>\n<p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 20px; word-break: break-word; color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px;\"><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">props/$emit</code></p>\n<ul style=\"box-sizing: border-box; margin: 0px 0px 20px 20px; padding-left: 0px; list-style-position: initial; list-style-image: initial; word-break: break-word; color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px;\">\n<li style=\"box-sizing: border-box; line-height: 30px;\">父传子：<code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">props</code></li>\n<li style=\"box-sizing: border-box; line-height: 30px; margin-bottom: 0px;\">子传父：父组件向子组件传递事件方法，子组件通过<code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">$emit</code>触发事件，回调给父组件</li>\n</ul>\n<p style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 20px; word-break: break-word; color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px;\"><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">$eimt/$on</code></p>\n<ul style=\"box-sizing: border-box; margin: 0px 0px 20px 20px; padding-left: 0px; list-style-position: initial; list-style-image: initial; word-break: break-word; color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px;\">\n<li style=\"box-sizing: border-box; line-height: 30px; margin-bottom: 0px;\">这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。<br style=\"box-sizing: border-box;\" />具体实现方式：\n<pre class=\"language-javascript\"><code>var Event=new Vue();\n   Event.$emit(事件名,数据);\n   Event.$on(事件名,data =&gt; {});\n// 假设兄弟组件有三个，分别是A、B、C组件，C组件如何获取A或者B组件的数据\n// 组件A、B通过Event.$emit(事件名,数据)将数据传递，组件C通过 Event.$on(事件名,data =&gt; {})接受组件A、B传递的数据</code></pre>\n</li>\n</ul>\n<div>\n<div>\n<p><code>Vuex</code></p>\n<ul>\n<li>vuex 就是一个仓库，仓库里放了很多对象。在state中存放数据源，当组件要更改state中的数据时，必须通过mutation进行，mutation储存的是改变state中数据的操作方法，之后通过actions储存的操作去触发mutation中的方法,由组件中的$store.dispatch('action 名称', data1)来触发。然后由commit()来触发mutation的调用 , 间接更新 state。</li>\n</ul>\n</div>\n<br />\n<div>\n<div>\n<p><code>Vuex + localstorage</code></p>\n<ul>\n<li>vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state。</li>\n<li>这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换。</li>\n</ul>\n</div>\n<br />\n<div>\n<div>\n<p><code>$attrs/$listeners</code></p>\n<ul>\n<li><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23vm-attrs\" target=\"_blank\" rel=\"noopener\"><code>$attrs:</code></a>包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=\"<code>$attrs</code>\" 传入内部组件&mdash;&mdash;在创建高级别的组件时非常有用。</li>\n<li><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23vm-listeners\" target=\"_blank\" rel=\"noopener\"><code>$listeners:</code></a>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=\"<code>$listeners</code>\" 传入内部组件&mdash;&mdash;在创建更高层次的组件时非常有用。</li>\n</ul>\n</div>\n<br />\n<div>\n<div>\n<p><code>provide/inject</code></p>\n<ul>\n<li><a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23provide-inject\" target=\"_blank\" rel=\"noopener\"><code>provide/inject</code></a>:vue2.2.0 新增API,<strong>以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</strong></li>\n<li>总而言之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。</li>\n<li><strong><code>provide / inject API</code>主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</strong></li>\n</ul>\n</div>\n<pre class=\"language-javascript\"><code>// A.vue\nexport default {\n provide: {\n   name: 'nora'\n }\n}\n/**************************************/\n// B.vue\nexport default {\n inject: ['name'],\n mounted () {\n   console.log(this.name);  // nora\n }\n}</code></pre>\n<div>\n<ul>\n<li>\n<p>需要注意的是：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的----<a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23Vue-observable\" target=\"_blank\" rel=\"noopener\">vue官方文档</a><br />provide与inject 怎么实现数据响应式?<br />使用2.6最新API <a href=\"https://links.jianshu.com/go?to=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23Vue-observable\" target=\"_blank\" rel=\"noopener\">Vue.observable</a> 优化响应式 provide(推荐)</p>\n</li>\n<li>\n<p>我们来看个例子：孙组件D、E和F获取A组件传递过来的color值，并能实现数据响应式变化，即A组件的color变化后，组件D、E、F会跟着变（核心代码如下：）</p>\n<pre class=\"language-javascript\"><code>//A组件\n&lt;div&gt;\n     &lt;h1&gt;A 组件&lt;/h1&gt;\n     &lt;button @click=\"() =&gt; changeColor()\"&gt;改变color&lt;/button&gt;\n     &lt;ChildrenB /&gt;\n     &lt;ChildrenC /&gt;\n&lt;/div&gt;\n......\n// provide() {\n //   return {\n //     theme: {\n //       color: this.color //这种方式绑定的数据并不是可响应的\n //     } // 即A组件的color变化后，组件D、E、F不会跟着变\n //   };\n // },\n\n// 方法二:使用2.6最新API Vue.observable 优化响应式 provide\nprovide() {\n   this.theme = Vue.observable({\n      color: \"blue\"\n    });\n    return {\n      theme: this.theme\n    };\n  },\n  methods: {\n    changeColor(color) {\n      if (color) {\n        this.theme.color = color;\n      } else {\n        this.theme.color = this.theme.color === \"blue\" ? \"red\" : \"blue\";\n      }\n    }\n  }\n/******************************************************************/\n// F 组件 \n&lt;template functional&gt;\n &lt;div class=\"border2\"&gt;\n   &lt;h3 :style=\"{ color: injections.theme.color }\"&gt;F 组件&lt;/h3&gt;\n &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n inject: {\n   theme: {\n     //函数式组件取值不一样\n     default: () =&gt; ({})\n   }\n }\n};\n&lt;/script&gt;</code></pre>\n</li>\n</ul>\n<div>\n<div>\n<p><code>$parent / $children与 ref</code></p>\n<ul>\n<li><code>ref：</code>如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li>\n<li><code>$parent / $children：</code>访问父 / 子实例</li>\n<li>需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。</li>\n<li><code>$parent ：</code>访问父实例，如果当前实例有的话。</li>\n<li><code>$children:</code>当前实例的直接子组件。需要注意 <code>$children</code>并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 <code>$children</code>来进行数据绑定，考虑使用一个数组配合 v-for 来生成子组件，并且使用 Array 作为真正的来源。</li>\n<li>这两种方法的弊端是，无法在跨级或兄弟间通信。\n<pre class=\"language-javascript\"><code>// component-a 子组件\nexport default {\n data () {\n   return {\n     title: 'Vue.js'\n   }\n },\n methods: {\n   sayHello () {\n     window.alert('Hello');\n   }\n }\n}\n/***********************************/\n// 父组件\n&lt;template&gt;\n &lt;component-a ref=\"comA\"&gt;&lt;/component-a&gt;\n&lt;/template&gt;\n&lt;script&gt;\n export default {\n   mounted () {\n     const comA = this.$refs.comA;\n     console.log(comA.title);  // Vue.js\n     comA.sayHello();  // 弹窗\n   }\n }\n&lt;/script&gt;</code></pre>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>","rank_id":52,"createdAt":"2021-06-15T04:15:09.603Z","updatedAt":"2021-06-15T04:15:09.603Z","__v":0},{"_id":"60c82bcbda9b3346d469d694","title":"vuex是什么？怎么使用？哪种功能场景使用它？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li>vuex 就是一个仓库，仓库里放了很多对象。</li>\n<li>其中 state 存放的是数据状态，不可以直接修改里面的数据。</li>\n<li>getters类似vue的计算属性，主要用来过滤一些数据。</li>\n<li>mutations:存放的是动态修改Vuex的state中保存的数据状态的方法。</li>\n<li>actions:保存的触发mutations中方法的方法，可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。</li>\n</ul>\n<div>\n<div>一般什么样的数据会放在 State 中呢？<br />目前主要有两种数据会使用 vuex 进行管理： 、</div>\n<ol>\n<li>组件之间全局共享的数据</li>\n<li>通过后端异步请求的数据 比如做加入购物车、登录状态等都可以使用Vuex来管理数据状态</li>\n</ol>\n<ul>\n<li>怎么使用Vuex? 在main.js引入store，注入。新建了一个目录store，&hellip; export</li>\n<li>场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车</li>\n</ul>\n</div>","rank_id":53,"createdAt":"2021-06-15T04:25:47.930Z","updatedAt":"2021-06-15T04:25:47.930Z","__v":0},{"_id":"60c82e6ada9b3346d469d695","title":"开发时，改变数组或者对象的数据，但是页面没有更新如何解决？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<div><a title=\"对于数组\" href=\"https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E6%95%B0%E7%BB%84\" target=\"_blank\" rel=\"noopener\">对于数组：</a><br />Vue 不能检测以下数组的变动：<br />1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue<br />2.当你修改数组的长度时，例如：vm.items.length = newLength</div>\n<div>\n<pre class=\"language-javascript\"><code>//举个例子：\nvar vm = new Vue({\n data: {\n   items: ['a', 'b', 'c']\n }\n})\nvm.items[1] = 'x' // 不是响应性的\nvm.items.length = 2 // 不是响应性的\n\n//为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将在响应式系统内触发状态更新：\n// Vue.set\nVue.set(vm.items, indexOfItem, newValue)\n// Array.prototype.splice\nvm.items.splice(indexOfItem, 1, newValue)\n// 你也可以使用 [`vm.$set`](https://cn.vuejs.org/v2/api/#vm-set) 实例方法，该方法是全局方法 `Vue.set` 的一个别名：\nvm.$set(vm.items, indexOfItem, newValue)\n// 为了解决第二类问题，你可以使用 `splice`：\nvm.items.splice(newLength)</code></pre>\n<p><a title=\"数组通过变异方法变化数据才能被检测到\" href=\"https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">数组通过变异方法变化数据才能被检测到：</a></p>\n<p style=\"word-spacing: 0.05em; line-height: 1.6em; margin: 1.2em 0px -1.2em; padding-bottom: 1.2em; position: relative; z-index: 1; color: #304455; font-family: 'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif; font-size: 16px; background-color: #ffffff;\">Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul style=\"line-height: 1.6em; margin: 1.2em 0px -1.2em; padding-bottom: 1.2em; position: inherit; z-index: 1; padding-left: 1.5em; color: #304455; font-family: 'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif; font-size: 16px; background-color: #ffffff;\">\n<li><code style=\"font-family: 'Roboto Mono', Monaco, courier, monospace; font-size: 0.85em; background-color: #f8f8f8; -webkit-font-smoothing: initial; color: #d63200; padding: 3px 5px; margin: 0px 2px; border-radius: 2px; white-space: nowrap;\">push()</code></li>\n<li><code style=\"font-family: 'Roboto Mono', Monaco, courier, monospace; font-size: 0.85em; background-color: #f8f8f8; -webkit-font-smoothing: initial; color: #d63200; padding: 3px 5px; margin: 0px 2px; border-radius: 2px; white-space: nowrap;\">pop()</code></li>\n<li><code style=\"font-family: 'Roboto Mono', Monaco, courier, monospace; font-size: 0.85em; background-color: #f8f8f8; -webkit-font-smoothing: initial; color: #d63200; padding: 3px 5px; margin: 0px 2px; border-radius: 2px; white-space: nowrap;\">shift()</code></li>\n<li><code style=\"font-family: 'Roboto Mono', Monaco, courier, monospace; font-size: 0.85em; background-color: #f8f8f8; -webkit-font-smoothing: initial; color: #d63200; padding: 3px 5px; margin: 0px 2px; border-radius: 2px; white-space: nowrap;\">unshift()</code></li>\n<li><code style=\"font-family: 'Roboto Mono', Monaco, courier, monospace; font-size: 0.85em; background-color: #f8f8f8; -webkit-font-smoothing: initial; color: #d63200; padding: 3px 5px; margin: 0px 2px; border-radius: 2px; white-space: nowrap;\">splice()</code></li>\n<li><code style=\"font-family: 'Roboto Mono', Monaco, courier, monospace; font-size: 0.85em; background-color: #f8f8f8; -webkit-font-smoothing: initial; color: #d63200; padding: 3px 5px; margin: 0px 2px; border-radius: 2px; white-space: nowrap;\">sort()</code></li>\n<li><code style=\"font-family: 'Roboto Mono', Monaco, courier, monospace; font-size: 0.85em; background-color: #f8f8f8; -webkit-font-smoothing: initial; color: #d63200; padding: 3px 5px; margin: 0px 2px; border-radius: 2px; white-space: nowrap;\">reverse()</code></li>\n</ul>\n</li>\n</ul>\n<p style=\"word-spacing: 0.05em; line-height: 1.6em; margin: 1.2em 0px -1.2em; padding-bottom: 1.2em; position: relative; z-index: 1; color: #304455; font-family: 'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif; font-size: 16px; background-color: #ffffff;\">你可以打开控制台，然后对前面例子的&nbsp;<code style=\"font-family: 'Roboto Mono', Monaco, courier, monospace; font-size: 0.85em; background-color: #f8f8f8; -webkit-font-smoothing: initial; color: #d63200; padding: 3px 5px; margin: 0px 2px; border-radius: 2px; white-space: nowrap;\">items</code>&nbsp;数组尝试调用变更方法。比如&nbsp;<code style=\"font-family: 'Roboto Mono', Monaco, courier, monospace; font-size: 0.85em; background-color: #f8f8f8; -webkit-font-smoothing: initial; color: #d63200; padding: 3px 5px; margin: 0px 2px; border-radius: 2px; white-space: nowrap;\">example1.items.push({ message: 'Baz' })</code>。</p>\n<p style=\"word-spacing: 0.05em; line-height: 1.6em; margin: 1.2em 0px -1.2em; padding-bottom: 1.2em; position: relative; z-index: 1; color: #304455; font-family: 'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif; font-size: 16px; background-color: #ffffff;\"><a title=\"对于对象\" href=\"https://cn.vuejs.org/v2/guide/reactivity.html#%E5%AF%B9%E4%BA%8E%E5%AF%B9%E8%B1%A1\" target=\"_blank\" rel=\"noopener\">对于对象：</a></p>\n<p style=\"word-spacing: 0.05em; line-height: 1.6em; margin: 1.2em 0px -1.2em; padding-bottom: 1.2em; position: relative; z-index: 1; color: #304455; font-family: 'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif; font-size: 16px; background-color: #ffffff;\"><span style=\"word-spacing: 0.8px;\">Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在&nbsp;</span><code style=\"font-family: 'Roboto Mono', Monaco, courier, monospace; font-size: 0.85em; background-color: #f8f8f8; -webkit-font-smoothing: initial; color: #d63200; padding: 3px 5px; margin: 0px 2px; border-radius: 2px; white-space: nowrap; word-spacing: 0.8px;\">data</code><span style=\"word-spacing: 0.8px;\">&nbsp;对象上存在才能让 Vue 将它转换为响应式的。</span></p>\n<pre class=\"language-javascript\"><code>var vm = new Vue({\n  data:{\n    a:1\n  }\n})\n\n// `vm.a` 是响应式的\n\nvm.b = 2\n// `vm.b` 是非响应式的</code></pre>\n</div>","rank_id":54,"createdAt":"2021-06-15T04:36:58.071Z","updatedAt":"2021-06-15T04:36:58.071Z","__v":0},{"_id":"60c82eb4da9b3346d469d696","title":"简单说下nextTick？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><code>nextTick</code>可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM</li>\n<li>nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用<br />Promise<br />MutationObserver<br />setImmediate<br />如果以上都不行则采用setTimeout</li>\n<li>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列</li>\n</ul>","rank_id":55,"createdAt":"2021-06-15T04:38:12.570Z","updatedAt":"2021-06-15T04:38:12.570Z","__v":0},{"_id":"60c82eddda9b3346d469d697","title":"computed和watch区别？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><code>computed</code>是计算属性,具有缓存性。<br />当页面中有某些数据依赖其他数据进行变动的时候，可以使用计算属性<code>computed</code>。<br />用于依赖发生变化时，触发属性重新计算。<br /><code>Computed</code>本质是一个具备缓存的<code>watcher</code>，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。</li>\n<li><code>watch</code>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察<code>props</code>,<code>$emit</code>或者本组件的值,当数据变化时来执行回调进行后续操作。<br />无缓存性，页面重新渲染时值不变化也会执行。<br /><code>Watch</code>没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开<code>deep：true</code>选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用<code>unWatch</code>手动注销。</li>\n<li>应用场景：<br />当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed。<br />如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化。</li>\n</ul>","rank_id":56,"createdAt":"2021-06-15T04:38:53.312Z","updatedAt":"2021-06-15T04:38:53.312Z","__v":0},{"_id":"60c836c1da9b3346d469d698","title":"Vue是如何实现双向绑定的?","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><code>Observer</code>遍历数据对象，给所有属性加上<code>setter</code>和 <code>getter</code>，监听数据的变化</li>\n<li><code>compile</code>解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>\n<li><code>Watcher</code> 订阅者是 <code>Observer</code>和 <code>Compile</code> 之间通信的桥梁，主要做的事情:<br />在自身实例化时往属性订阅器 <code>(dep)</code>里面添加自己<br />待属性变动 <code>dep.notice()</code>通知时，调用自身的 <code>update()</code>方法，并触发<code>Compile</code>中绑定的回调</li>\n</ul>\n<div>\n<ul>\n<li><code>vue</code>实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 <code>Vue</code>实例来作为它的 <code>data</code>选项时，<code>Vue</code>将遍历它的属性，用<code>Object.defineProperty()</code>将它们转为<code>getter/setter</code>。用户看不到<code>getter/setter</code>，但是在内部它们让<code>Vue</code>追踪依赖，在属性被访问和修改时通知变化。</li>\n<li><code>vue</code>的数据双向绑定 将<code>MVVM</code>作为数据绑定的入口，整合<code>Observer，Compile</code>和<code>Watcher</code>三者，通过<code>Observer</code>来监听自己的<code>model</code>的数据变化，通过<code>Compile</code>来解析编译模板指令（<code>vue</code>中是用来解析 <code>{{}}</code>），最终利用<code>watcher</code>搭起<code>observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化 &mdash;&gt;视图更新；视图交互变化（<code>input</code>）&mdash;&gt;数据<code>model</code>变更双向绑定效果。</li>\n</ul>\n</div>","rank_id":57,"createdAt":"2021-06-15T05:12:33.621Z","updatedAt":"2021-06-15T05:12:33.621Z","__v":0},{"_id":"60c83764da9b3346d469d699","title":"Vue的v-model双向绑定原理? ","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li>v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性</li>\n<li style=\"box-sizing: border-box; word-break: break-word;\">text 和 textarea 元素使用 value 属性和 input 事件</li>\n<li style=\"box-sizing: border-box; word-break: break-word;\">checkbox 和 radio 使用 checked 属性和 change 事件</li>\n<li style=\"box-sizing: border-box; word-break: break-word;\">select 字段将 value 作为 prop 并将 change 作为事件</li>\n<li style=\"box-sizing: border-box; word-break: break-word;\">可以将v-model进行如下改写：\n<pre class=\"language-markup\"><code>&lt;input v-model=\"sth\" /&gt;\n//  等同于\n&lt;input :value=\"sth\" @input=\"sth = $event.target.value\" /&gt;\n//这个语法糖必须是固定的，也就是说属性必须为value，方法名必须为：input。</code></pre>\n</li>\n</ul>","rank_id":58,"createdAt":"2021-06-15T05:15:16.455Z","updatedAt":"2021-06-15T05:15:16.455Z","__v":0},{"_id":"60c83788da9b3346d469d69a","title":"ref的作用","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li>绑定到普通元素上：获取dom元素<code>this.$refs.box</code></li>\n<li>绑定到子组件上：<br />获取子组件中的data，<code>this.$refs.box.msg</code><br />调用子组件中的方法<code>this.$refs.box.open()</code></li>\n</ul>","rank_id":59,"createdAt":"2021-06-15T05:15:52.054Z","updatedAt":"2021-06-15T05:15:52.054Z","__v":0},{"_id":"60c83a74da9b3346d469d69b","title":"说一下导航守卫？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; box-sizing: border-box; line-height: 30px;\"><span style=\"font-family: tahoma, arial, helvetica, sans-serif;\">全局守卫：<code style=\"box-sizing: border-box; font-size: 12px; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">beforeEach</code>,<code style=\"box-sizing: border-box; font-size: 12px; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">afterEach</code></span></li>\n<li style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; box-sizing: border-box; line-height: 30px;\"><span style=\"font-family: tahoma, arial, helvetica, sans-serif;\">路由独享守卫：<code style=\"color: #476582; padding: 0.25rem 0.5rem; margin: 0px; font-size: 0.85em; background-color: rgba(27, 31, 35, 0.05); border-radius: 3px;\">beforeEnter</code><span style=\"color: #2c3e50; background-color: #ffffff;\">&nbsp;</span></span></li>\n<li style=\"box-sizing: border-box; line-height: 30px;\"><span style=\"font-family: tahoma, arial, helvetica, sans-serif;\"><span style=\"color: #2c3e50; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\"><span style=\"background-color: #ffffff;\">组件内守卫：</span></span></span>\n<ul>\n<li><code>beforeRouteEnter</code>:因为当守卫执行前，组件实例还没被创建,不能获取组件实例的<code>this</code></li>\n<li><code>beforeRouteUpdate</code>: 在当前路由改变，但是该组件被复用时调用，可以访问组件实例 <code>this</code></li>\n<li><code>beforeRouteLeave</code>:导航离开该组件的对应路由时调用，可以访问组件实例 <code>this</code></li>\n</ul>\n</li>\n<li style=\"box-sizing: border-box; line-height: 30px;\">每个守卫方法接收三个参数：<br style=\"box-sizing: border-box;\" /><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">to:</code>目标路由对象<br style=\"box-sizing: border-box;\" /><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">from:</code>准备要离开的路由<br style=\"box-sizing: border-box;\" /><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">next():</code>进行管道中的下一个钩子。可传递参数有布尔值<code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">false</code>，直接写路径'/'或<code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">{path:'/'}</code>,回调函数</li>\n<li style=\"box-sizing: border-box; line-height: 30px;\"><span style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\">注意：后置钩子函数</span><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">afterEach</code><span style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\">不会接受</span><code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">next</code><span style=\"color: #404040; font-family: -apple-system, BlinkMacSystemFont, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; background-color: #fafafa;\">函数也不会改变导航本身</span></li>\n</ul>\n<p><br /><br /></p>","rank_id":60,"createdAt":"2021-06-15T05:28:20.852Z","updatedAt":"2021-06-15T05:28:20.852Z","__v":0},{"_id":"60c83aa5da9b3346d469d69c","title":"$route和$router的区别","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><code>$route</code>是&ldquo;路由信息对象&rdquo;，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li>\n<li>而<code>$router</code>是&ldquo;路由实例&rdquo;对象包括了路由的跳转方法，钩子函数等</li>\n</ul>","rank_id":61,"createdAt":"2021-06-15T05:29:09.311Z","updatedAt":"2021-06-15T05:29:09.311Z","__v":0},{"_id":"60c83b1bda9b3346d469d69d","title":"<keep-alive></keep-alive>的作用？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li>keep-alive可以实现组件缓存，当组件切换时,主要用于保留组件状态或避免重新渲染</li>\n<li>使用场景：比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情&hellip;这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</li>\n<li>常用的两个属性<code>include/exclude</code>，允许组件有条件的进行缓存</li>\n<li>两个生命周期<code>activated/deactivated</code>，用来得知当前组件是否处于活跃状态</li>\n</ul>","rank_id":62,"createdAt":"2021-06-15T05:31:07.752Z","updatedAt":"2021-06-15T05:31:07.752Z","__v":0},{"_id":"60c83b42da9b3346d469d69e","title":"指令v-el的作用是什么?","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li>提供一个在页面上已存在的<code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">DOM</code>元素作为<code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">Vue</code>实例的挂载目标</li>\n</ul>","rank_id":63,"createdAt":"2021-06-15T05:31:46.289Z","updatedAt":"2021-06-15T05:31:46.289Z","__v":0},{"_id":"60c83b6eda9b3346d469d69f","title":"组件中的data为什么是一个函数？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p>如果<code>data</code>是对象的话，由于对象是引用类型，组件被复用的话，就会创建多个实例。本质上，这些实例用的都是同一个构造函数。这样就会影响到所有的实例，所以为了保证组件不同的实例之间<code>data</code>不冲突，<code>data</code>必须是一个函数。</p>","rank_id":64,"createdAt":"2021-06-15T05:32:30.865Z","updatedAt":"2021-06-15T05:32:30.865Z","__v":0},{"_id":"60c83b97da9b3346d469d6a0","title":"Vue中的key到底有什么用？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><code>key</code>是为<code>Vue</code>中的<code>vnode</code>标记的唯一<code>id</code>,通过这个<code>key</code>,我们的<code>diff</code>操作可以更准确、更快速。</li>\n<li><code>diff</code>算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的<code>key</code>与旧节点进行比对,然后超出差异。</li>\n<li>简单来说，主要是为了高效的更新虚拟<code>DOM</code>。另外<code>vue</code>中在使用相同标签名元素的过渡切换时，也会使用到<code>key</code>属性，其目的也是为了让<code>vue</code>可以区分它们</li>\n</ul>","rank_id":65,"createdAt":"2021-06-15T05:33:11.071Z","updatedAt":"2021-06-15T05:33:11.071Z","__v":0},{"_id":"60c83bc5da9b3346d469d6a1","title":"说一下vue2.x中如何监测数组变化","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<div>\n<ul>\n<li>使用了函数劫持的方式，重写了数组的方法，<code>Vue</code>将<code>data</code>中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组<code>api</code>时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</li>\n<li>重写的数组API：<code>push</code>，<code>pop</code>，<code>shift</code>，<code>unshift</code>，<code>splice</code>，<code>sort</code>，<code>reserve</code>。</li>\n</ul>\n</div>","rank_id":66,"createdAt":"2021-06-15T05:33:57.202Z","updatedAt":"2021-06-15T05:33:57.202Z","__v":0},{"_id":"60c83beeda9b3346d469d6a2","title":"你的接口请求一般放在哪个生命周期中","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li>接口请求一般放在<code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">mounted</code>中，但需要注意的是服务端渲染时不支持<code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">mounted</code>，需要放到<code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">created</code>中</li>\n</ul>","rank_id":67,"createdAt":"2021-06-15T05:34:38.609Z","updatedAt":"2021-06-15T05:34:38.609Z","__v":0},{"_id":"60c83c06da9b3346d469d6a3","title":"Vue事件绑定原理说一下","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li>原生事件绑定是通过<code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">addEventListener</code>绑定给真实元素的，组件事件绑定是通过<code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">Vue</code>自定义的<code style=\"box-sizing: border-box; font-size: 12px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; padding: 2px 4px; border: none; vertical-align: middle; white-space: pre-wrap; color: #c7254e; background-color: #f2f2f2;\">$on</code>实现的</li>\n</ul>","rank_id":68,"createdAt":"2021-06-15T05:35:02.766Z","updatedAt":"2021-06-15T05:35:02.766Z","__v":0},{"_id":"60c83c4dda9b3346d469d6a4","title":"Vue模版编译原理知道吗，能简单说一下吗？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li>简单说，<code>Vue</code>的编译过程就是将<code>template</code>转化为<code>render</code>函数的过程。</li>\n<li>会经历以下阶段：生成<code>AST</code>树(抽象语法树) --&gt; 优化 --&gt; <code>codegen</code>(代码生成器)</li>\n<li>（1）首先解析模版，生成<code>AST</code>语法树(一种用<code>JavaScript</code>对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</li>\n<li>（2）<code>Vue</code>的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的<code>DOM</code>也不会变化。那么优化过程就是深度遍历<code>AST</code>树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</li>\n<li>（3）编译的最后一步是将优化后的<code>AST</code>树转换为可执行的代码</li>\n</ul>\n<p>如何从真实DOM到虚拟DOM?</p>\n<ul>\n<li>涉及到Vue中的模板编译原理，主要过程：</li>\n</ul>\n<ol>\n<li>将模板转换成ast 树，ast 用对象来描述真实的JS语法（将真实DOM转换成虚拟DOM）</li>\n<li>优化树</li>\n<li>将ast 树生成代码</li>\n</ol>","rank_id":69,"createdAt":"2021-06-15T05:36:13.314Z","updatedAt":"2021-06-15T05:36:13.314Z","__v":0},{"_id":"60c83cccda9b3346d469d6a5","title":"Vue中hash模式和history模式的区别","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<div>\n<ul>\n<li>在最明显的显示上：<code>hash</code>模式的<code>URL</code>中会夹杂着<code>#</code>号，而<code>history</code>没有。</li>\n<li><code>Vue</code>底层对它们的实现方式不同:<br /><code>hash</code>模式是依靠<code>onhashchange</code>事件(监听<code>location.hash</code>的改变)<br /><code>history</code>模式是主要是依靠的<code>HTML5 history</code>中新增的两个方法，<code>pushState()</code>可以改变<code>url</code>地址且不会发送请求，<code>replaceState()</code>可以读取历史记录栈,还可以对浏览器记录进行修改。\n<pre class=\"language-javascript\"><code>window.onhashchange = function(event){\n // location.hash获取到的是包括#号的，如\"#heading-3\"\n // 所以可以截取一下\n  let hash = location.hash.slice(1);\n}</code></pre>\n</li>\n<li>当真正需要通过<code>URL</code>向后端发送<code>HTTP</code>请求的时候，比如常见的用户手动输入<code>URL</code>后回车，或者是刷新(重启)浏览器，这时候<code>history</code>模式需要后端的支持。因为<code>history</code>模式下，前端的<code>URL</code>必须和实际向后端发送请求的<code>URL</code>一致，例如有一个<code>URL</code>是带有路径<code>path</code>的(例如<code>www.libai.wang/blogs/id</code>)，如果后端没有对这个路径做处理的话，就会返回<code>404</code>错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个<code>404</code>页面。\n<div>&nbsp;</div>\n</li>\n</ul>\n</div>","rank_id":70,"createdAt":"2021-06-15T05:38:20.622Z","updatedAt":"2021-06-15T05:38:20.622Z","__v":0},{"_id":"60c83cfcda9b3346d469d6a6","title":"Vue 的响应式原理中 Object.defineProperty 有什么缺陷?","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<div>\n<ul>\n<li><code>Object.defineProperty</code> 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</li>\n<li><code>Object.defineProperty</code>只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。<code>Proxy</code> 可以劫持整个对象，并返回一个新的对象</li>\n<li><code>Proxy</code> 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性</li>\n</ul>\n</div>","rank_id":71,"createdAt":"2021-06-15T05:39:08.802Z","updatedAt":"2021-06-15T05:39:08.802Z","__v":0},{"_id":"60c83d63da9b3346d469d6a7","title":"说说你对 proxy 的理解","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p></p>\n<div>\n<ul>\n<li>无法监听通过索引修改数组的值的变化</li>\n<li>无法监听<code>object</code> 也就是对象的值的变化<br />所以<code>vue2.x</code>中才会有<code>$set</code> 属性的存在<br /><code>proxy</code>是 <code>es6</code>中推出的新 <code>api</code>，可以弥补以上两个缺点，所以 <code>vue3.x</code>版本用 <code>proxy</code> 替换<code>object.defineproperty</code>。</li>\n</ul>\n</div>","rank_id":72,"createdAt":"2021-06-15T05:40:51.336Z","updatedAt":"2021-06-15T05:40:51.336Z","__v":0},{"_id":"60c83d74da9b3346d469d6a8","title":"Proxy 相比于 defineProperty 的优势?","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li style=\"box-sizing: border-box; line-height: 30px;\">数组变化也能监听到</li>\n<li>不需要深度遍历监听</li>\n</ul>","rank_id":73,"createdAt":"2021-06-15T05:41:08.911Z","updatedAt":"2021-06-15T05:41:08.911Z","__v":0},{"_id":"60c87748da9b3346d469d6a9","title":"请简述下Vuex的原理和使用方法","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p class=\"p\" style=\"margin: 0pt 0pt 9.6pt; padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt;\" align=\"justify\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; background-color: #ffffff; color: #4f4f4f; letter-spacing: 0pt;\">一个应用可以看作是由三部分组成:</span><strong><span class=\"15\" style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">View, Actions,State</span></span></strong><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">,数据的流动也是从View =&gt; Actions =&gt; State =&gt;View 以此达到数据的单向流动.但是项目较大的, 组件嵌套过多的时候, 多组件共享同一个State会在数据传递时出现很多问题.Vuex就是为了解决这些问题而产生的.</span></span></span></p>\n<p class=\"p\" style=\"margin: 0pt 0pt 9.6pt; padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt;\" align=\"justify\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">Vuex可以被看作项目中所有组件的数据中心,我们将所有组件中共享的State抽离出来,任何组件都可以访问和操作我们的数据中心.</span></span></span></p>\n<p class=\"p\" style=\"margin: 0pt 0pt 9.6pt; padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt;\" align=\"justify\">&nbsp;</p>\n<p class=\"MsoNormal\" style=\"margin: 0pt; text-indent: 0pt; padding: 0pt; word-break: break-all; background: #ffffff;\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">Vuex原理:</span></span></p>\n<p class=\"p\" style=\"padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">一个实例化的</span><span style=\"font-family: 微软雅黑;\">Vuex.Store由state, mutations和actions三个属性组成:</span></span></span></p>\n<p class=\"MsoNormal\" style=\"mso-para-margin-right: 0.0000gd; mso-para-margin-left: 0.0000gd; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; margin: 4.8000pt 0.0000pt 0.0000pt 1.2000pt;\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">state中保存着共有数据</span></span></span></p>\n<p class=\"MsoNormal\" style=\"mso-para-margin-right: 0.0000gd; mso-para-margin-left: 0.0000gd; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; margin: 4.8000pt 0.0000pt 0.0000pt 1.2000pt;\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">改变</span><span style=\"font-family: 微软雅黑;\">state中的数据有且只有通过mutations中的方法,且mutations中的方法必须是同步的</span></span></span></p>\n<p class=\"MsoNormal\" style=\"margin: 0pt; text-indent: 0pt; padding: 0pt; word-break: break-all; background: #ffffff;\">&nbsp;</p>\n<p class=\"MsoNormal\" style=\"mso-para-margin-right: 0.0000gd; mso-para-margin-left: 0.0000gd; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; margin: 4.8000pt 0.0000pt 0.0000pt 1.2000pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 10pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">如果要写异步的方法</span><span style=\"font-family: 微软雅黑;\">,需要些在actions中, 并通过commit到mutations中进行state中数据的更改.</span></span></p>","rank_id":74,"createdAt":"2021-06-15T09:47:52.963Z","updatedAt":"2021-06-15T09:47:52.963Z","__v":0},{"_id":"60c877d3da9b3346d469d6aa","title":"请谈谈Vue框架和Angular.js和React的不同","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<h5 style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; line-height: 15.6000pt; background: #ffffff; margin: 4.8000pt 0.0000pt 9.6000pt 0.0000pt;\"><strong><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">1.与AngularJS的区别</span></strong></h5>\n<p class=\"p\" style=\"margin-top: 0.0000pt; margin-right: 36.0000pt; margin-bottom: 9.6000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt;\" align=\"justify\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">相同点：</span></span></span></p>\n<ul>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">都支持指令：内置指令和自定义指令。</span></span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">都支持过滤器：内置过滤器和自定义过滤器。</span></span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">都支持双向数据绑定。</span></span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">都不支持低端浏览器。</span></span></li>\n</ul>\n<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 10pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"color: #4f4f4f; letter-spacing: 0pt;\">不同点：</span></span></p>\n<p><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">1.AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观。</span></span></p>\n<p><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">2.在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢。</span></span></p>\n<p><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">Vue.js使用基于依赖追踪的观察并且使用异步队列更新。所有的数据都是独立触发的。</span></span></p>\n<p><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 10pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">对于庞大的应用来说，这个优化差异还是比较明显的。</span></p>\n<h5 style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; line-height: 15.6000pt; background: #ffffff; margin: 4.8000pt 0.0000pt 9.6000pt 0.0000pt;\"><strong><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">2.与React的区别</span></strong></h5>\n<p class=\"p\" style=\"margin-top: 0.0000pt; margin-right: 36.0000pt; margin-bottom: 9.6000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">相同点：</span></span></p>\n<ul>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用。</span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">中心思想相同：一切都是组件，组件实例之间可以嵌套。</span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">都提供合理的钩子函数，可以让开发者定制化地去处理需求。</span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">都不内置列数</span><span style=\"font-family: 微软雅黑;\">AJAX，Route等功能到核心包，而是以插件的方式加载。</span></span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">在组件开发中都支持</span><span style=\"font-family: 微软雅黑;\">mixins的特性。</span></span></li>\n</ul>\n<p class=\"p\" style=\"margin-top: 0.0000pt; margin-right: 36.0000pt; margin-bottom: 9.6000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">不同点：</span></span></p>\n<ul>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">React依赖Virtual DOM,而Vue.js使用的是DOM模板。React采用的Virtual DOM会对渲染出来的结果做脏检查。</span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作DOM。</span></li>\n</ul>","rank_id":75,"createdAt":"2021-06-15T09:50:11.872Z","updatedAt":"2021-06-15T09:50:11.872Z","__v":0},{"_id":"60c878adda9b3346d469d6ab","title":"嵌套路由怎么定义？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">因此我们需要在</span> <span style=\"font-family: 微软雅黑;\">VueRouter 的参数中使用 children 配置，这样就可以很好的实现路由嵌套。</span></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">只有一个路由出口</span></span></p>\n<pre class=\"language-markup\"><code>&lt;div id=\"app\"&gt;  \n    &lt;!-- router-view 路由出口, 路由匹配到的组件将渲染在这里 --&gt;  \n    &lt;router-view&gt;&lt;/router-view&gt;  \n&lt;/div&gt;</code></pre>\n<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 10pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">main.js，路由的重定向，就会在页面一加载的时候，就会将home组件显示出来，因为重定向指向了home组件，redirect的指向与path的必须一致。children里面是子路由，当然子路由里面还可以继续嵌套子路由。</span></p>\n<pre class=\"language-javascript\"><code>import Vue from 'vue'  \nimport VueRouter from 'vue-router'  \nVue.use(VueRouter)  \n//引入两个组件 \nimport home from \"./home.vue\"  \nimport game from \"./game.vue\"  \n//定义路由  \nconst routes = [  \n    { path: \"/\", redirect: \"/home\" },//重定向,指向了home组件  \n    {  \n        path: \"/home\", component: home,  \n        children: [  \n            { path: \"/home/game\", component: game }  \n        ]  \n    }  \n]  \n//创建路由实例  \nconst router = new VueRouter({routes})  \n \nnew Vue({  \n    el: '#app',  \n    data: {  \n    },  \n    methods: {  \n    },  \n    router  \n})</code></pre>\n<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 10pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">home.vue，点击显示就会将子路由显示在出来，子路由的出口必须在父路由里面，否则子路由无法显示。</span></p>\n<pre class=\"language-markup\"><code>&lt;template&gt;  \n    &lt;div&gt;  \n        &lt;h3&gt;首页&lt;/h3&gt;  \n        &lt;router-link to=\"/home/game\"&gt;  \n            &lt;button&gt;显示&lt;tton&gt;  \n        &lt;/router-link&gt; \n        &lt;router-view&gt;&lt;/router-view&gt;  \n    &lt;/div&gt;  \n&lt;/template&gt;</code></pre>\n<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">game.vue</span></p>\n<pre class=\"language-markup\"><code> &lt;template&gt;  \n    &lt;h3&gt;游戏&lt;/h3&gt;  \n&lt;/template&gt;</code></pre>","rank_id":76,"createdAt":"2021-06-15T09:53:49.777Z","updatedAt":"2021-06-15T09:53:49.777Z","__v":0},{"_id":"60c878d4da9b3346d469d6ac","title":"怎么定义vue-router的动态路由？怎么获取传过来的动态参数？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">在</span><span style=\"font-family: 微软雅黑;\">router目录下的index.js文件中，对path属性加上/:id。</span></span></li>\n<li><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">使用</span><span style=\"font-family: 微软雅黑;\">router对象的params.id。</span></span></li>\n</ul>","rank_id":77,"createdAt":"2021-06-15T09:54:28.315Z","updatedAt":"2021-06-15T09:54:28.315Z","__v":0},{"_id":"60c8790dda9b3346d469d6ad","title":"scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">css的预编译。</span></p>\n<p class=\"p\" style=\"padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; margin: 0.0000pt 36.0000pt 9.6000pt 36.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">使用步骤：</span></span></p>\n<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">第一步：用</span><span style=\"font-family: 微软雅黑;\">npm 下三个loader（sass-loader、css-loader、node-sass）</span></span></p>\n<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">第二步：在</span><span style=\"font-family: 微软雅黑;\">build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss</span></span></p>\n<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">第三步：还是在同一个文件，配置一个</span><span style=\"font-family: 微软雅黑;\">module属性</span></span></p>\n<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">第四步：然后在组件的</span><span style=\"font-family: 微软雅黑;\">style标签加上lang属性 ，例如：lang=&rdquo;scss&rdquo;</span></span></p>\n<p class=\"p\" style=\"padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; margin: 0.0000pt 36.0000pt 9.6000pt 36.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">有哪几大特性</span><span style=\"font-family: 微软雅黑;\">:</span></span></p>\n<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">1、可以用变量，例如（$变量名称=值）；</span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">2、可以用混合器，例如（）</span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">3、可以嵌套</span></p>","rank_id":78,"createdAt":"2021-06-15T09:55:25.356Z","updatedAt":"2021-06-15T09:55:25.356Z","__v":0},{"_id":"60c87929da9b3346d469d6ae","title":"v-model是什么？怎么使用？ vue中标签怎么绑定事件？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">可以实现双向绑定，指令（</span><span style=\"font-family: 微软雅黑;\">v-class、v-for、v-if、v-show、v-on）。vue的model层的data属性。绑定事件：</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #4e5980; letter-spacing: 0pt; font-size: 9.5pt; background: #f8f8f8;\"><span style=\"font-family: 微软雅黑;\">&lt;input @click=doLog()/&gt;</span></span></p>","rank_id":79,"createdAt":"2021-06-15T09:55:53.572Z","updatedAt":"2021-06-15T09:55:53.572Z","__v":0},{"_id":"60c8794bda9b3346d469d6af","title":"简述一下Sass、Less，且说明区别？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">他们是动态的样式语言，是</span><span style=\"font-family: 微软雅黑;\">CSS预处理器,CSS上的一种抽象层。他们是一种特殊的语法/语言而编译成CSS。</span></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">变量符不一样，</span><span style=\"font-family: 微软雅黑;\">less是@，而Sass是$;</span></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持;</span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">Sass是基于Ruby的，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出Css到浏览器</span></span></p>","rank_id":80,"createdAt":"2021-06-15T09:56:27.503Z","updatedAt":"2021-06-15T09:56:27.503Z","__v":0},{"_id":"60c87973da9b3346d469d6b0","title":"axios是什么？怎么使用？描述使用它实现登录功能的流程？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p class=\"MsoNormal\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 10pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">请求后台资源的模块。</span><span style=\"font-family: 微软雅黑;\">npm install axios -S装好，然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</span></span></p>","rank_id":81,"createdAt":"2021-06-15T09:57:07.293Z","updatedAt":"2021-06-15T09:57:07.293Z","__v":0},{"_id":"60c879ddda9b3346d469d6b1","title":"自定义指令（v-check、v-focus）的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">全局定义指令：在</span><span style=\"font-family: 微软雅黑;\">vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives</span></span></span></p>\n<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">钩子函数：</span><span style=\"font-family: 微软雅黑;\">bind（绑定事件触发）、inserted(节点插入的时候触发)、update（组件内相关更新）</span></span></span></p>\n<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 10pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">钩子函数参数：</span><span style=\"font-family: 微软雅黑;\">el、binding</span></span></p>","rank_id":82,"createdAt":"2021-06-15T09:58:53.839Z","updatedAt":"2021-06-15T09:58:53.839Z","__v":0},{"_id":"60c879fdda9b3346d469d6b2","title":"说出至少4种vue当中的指令和它的用法？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">v-if：判断是否隐藏；</span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">v-for：数据循环出来；</span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">v-bind:class：绑定一个属性；</span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">v-model：实现双向绑定</span></li>\n</ol>","rank_id":83,"createdAt":"2021-06-15T09:59:25.198Z","updatedAt":"2021-06-15T09:59:25.198Z","__v":0},{"_id":"60c87a19da9b3346d469d6b3","title":"vue-router是什么？它有哪些组件？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">vue用来写路由一个插件。router-link、router-view</span></p>","rank_id":84,"createdAt":"2021-06-15T09:59:53.303Z","updatedAt":"2021-06-15T09:59:53.303Z","__v":0},{"_id":"60c87a4dda9b3346d469d6b4","title":"Vue的双向数据绑定原理是什么？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</span></p>\n<p><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">具体步骤：</span></span></p>\n<p><strong><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">第一步：</span></strong><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">需要</span><span style=\"font-family: 微软雅黑;\">observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter</span></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">这样的话，给这个对象的某个值赋值，就会触发</span><span style=\"font-family: 微软雅黑;\">setter，那么就能监听到了数据变化</span></span></p>\n<p><strong><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">第二步：</span></strong><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</span></p>\n<p><strong><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">第三步：</span></strong><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:</span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">1、在自身实例化时往属性订阅器(dep)里面添加自己</span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">2、自身必须有一个update()方法</span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</span></p>\n<p><strong><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">第四步：</span></strong><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</span></p>","rank_id":85,"createdAt":"2021-06-15T10:00:45.572Z","updatedAt":"2021-06-15T10:00:45.572Z","__v":0},{"_id":"60c87a8eda9b3346d469d6b5","title":"请说下封装 vue 组件的过程？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-size: 10pt;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</span></span></p>\n<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 10pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">然后，使用</span><span style=\"font-family: 微软雅黑;\">Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</span></span></p>","rank_id":86,"createdAt":"2021-06-15T10:01:50.519Z","updatedAt":"2021-06-15T10:01:50.519Z","__v":0},{"_id":"60c883e9da9b3346d469d6b6","title":"你是怎么认识vuex的？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。</span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">通过状态（数据源）集中管理驱动组件的变化（好比</span><span style=\"font-family: 微软雅黑;\">spring的IOC容器对bean进行集中管理）。</span></span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">应用级的状态集中放在</span><span style=\"font-family: 微软雅黑;\">store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。</span></span></li>\n</ul>","rank_id":87,"createdAt":"2021-06-15T10:41:45.150Z","updatedAt":"2021-06-15T10:41:45.150Z","__v":0},{"_id":"60c883f9da9b3346d469d6b7","title":"请说出vue.cli项目中src目录每个文件夹和文件的用法？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p class=\"p\" style=\"text-indent: 0.0000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt; background: #ffffff; margin: 0.0000pt 0.0000pt 9.6000pt 0.0000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件</span></p>","rank_id":88,"createdAt":"2021-06-15T10:42:01.827Z","updatedAt":"2021-06-15T10:42:01.827Z","__v":0},{"_id":"60c88410da9b3346d469d6b8","title":"vue.cli中怎样使用自定义的组件？有遇到过哪些问题吗？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">第一步：在</span><span style=\"font-family: 微软雅黑;\">components目录新建你的组件文件（smithButton.vue），script一定要export default {</span></span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">第二步：在需要用的页面（组件）中导入：</span><span style=\"font-family: 微软雅黑;\">import smithButton from &lsquo;../components/smithButton.vue&rsquo;</span></span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">第三步：注入到</span><span style=\"font-family: 微软雅黑;\">vue的子组件的components属性上面,components:{smithButton}</span></span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">第四步：在</span><span style=\"font-family: 微软雅黑;\">template视图view中使用，</span></span><span class=\"15\" style=\"font-family: 微软雅黑; color: #4e5980; letter-spacing: 0pt; font-size: 9.5pt; background: #f8f8f8;\"><span style=\"font-family: 微软雅黑;\">&lt;smith-button&gt; &lt;/smith-button&gt;</span></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">问题有：</span><span style=\"font-family: 微软雅黑;\">smithButton命名，使用的时候则smith-button。</span></span></li>\n</ul>","rank_id":89,"createdAt":"2021-06-15T10:42:24.455Z","updatedAt":"2021-06-15T10:42:24.455Z","__v":0},{"_id":"60c88430da9b3346d469d6b9","title":"聊聊你对Vue.js的template编译的理解？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">简而言之，就是先转化成</span><span style=\"font-family: 微软雅黑;\">AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）</span></span></li>\n<li class=\"p\" style=\"word-break: break-all; text-align: justify; line-height: 15.6pt;\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">详情步骤：</span></span>\n<ul>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">首先，通过</span><span style=\"font-family: 微软雅黑;\">compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。</span></span></li>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">然后，</span><span style=\"font-family: 微软雅黑;\">AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</span></span></li>\n</ul>\n</li>\n</ul>","rank_id":90,"createdAt":"2021-06-15T10:42:56.014Z","updatedAt":"2021-06-15T10:42:56.014Z","__v":0},{"_id":"60c884ddda9b3346d469d6bb","title":"cancas和SVG的是什么以及区别","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"p\" style=\"word-break: break-all; text-align: justify; line-height: 15.6pt;\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">SVG</span></span>\n<ul>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">SVG 是一种使用 XML 描述 2D 图形的语言。</span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">在</span> <span style=\"font-family: 微软雅黑;\">SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</span></span></li>\n</ul>\n</li>\n<li class=\"p\" style=\"word-break: break-all; text-align: justify; line-height: 15.6pt;\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">Canvas</span></span>\n<ul>\n<li class=\"p\" style=\"text-indent: 0pt; word-break: break-all; text-align: justify; line-height: 15.6pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">Canvas 通过 JavaScript 来绘制 2D 图形。</span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">Canvas 是逐像素进行渲染的。</span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><br /></span><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">在</span> <span style=\"font-family: 微软雅黑;\">canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</span></span></li>\n</ul>\n</li>\n</ul>","rank_id":91,"createdAt":"2021-06-15T10:45:49.867Z","updatedAt":"2021-06-15T10:45:49.867Z","__v":0},{"_id":"60c88503da9b3346d469d6bc","title":"Canvas 与 SVG 的比较","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p class=\"p\" style=\"margin-top: 0.0000pt; margin-right: 36.0000pt; margin-bottom: 9.6000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">Canvas</span></span></p>\n<p class=\"MsoNormal\" style=\"margin: 0pt 36pt; text-indent: 0pt; padding: 0pt; word-break: break-all; line-height: 14.4pt; background: #f8f8f8;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">依赖分辨率</span></p>\n<p class=\"MsoNormal\" style=\"margin: 0pt 36pt; text-indent: 0pt; padding: 0pt; word-break: break-all; line-height: 14.4pt; background: #f8f8f8;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">不支持事件处理器</span></p>\n<p class=\"MsoNormal\" style=\"margin: 0pt 36pt; text-indent: 0pt; padding: 0pt; word-break: break-all; line-height: 14.4pt; background: #f8f8f8;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">弱的文本渲染能力</span></p>\n<p class=\"MsoNormal\" style=\"margin: 0pt 36pt; text-indent: 0pt; padding: 0pt; word-break: break-all; line-height: 14.4pt; background: #f8f8f8;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">能够以</span> <span style=\"font-family: 微软雅黑;\">.png 或 .jpg 格式保存结果图像</span></span></p>\n<p class=\"MsoNormal\" style=\"margin: 0pt 36pt; text-indent: 0pt; padding: 0pt; word-break: break-all; line-height: 14.4pt; background: #f8f8f8;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">最适合图像密集型的游戏，其中的许多对象会被频繁重绘</span></p>\n<p class=\"MsoNormal\" style=\"margin: 0pt 36pt; text-indent: 0pt; padding: 0pt; word-break: break-all; line-height: 14.4pt; background: #f8f8f8;\">&nbsp;</p>\n<p class=\"p\" style=\"margin-top: 0.0000pt; margin-right: 36.0000pt; margin-bottom: 9.6000pt; padding: 0pt 0pt 0pt 0pt; word-break: break-all; mso-pagination: widow-orphan; text-align: justify; text-justify: inter-ideograph; line-height: 15.6000pt;\" align=\"justify\"><span style=\"font-family: 微软雅黑; color: #4f4f4f; letter-spacing: 0pt; font-size: 9.5pt; background: #ffffff;\"><span style=\"font-family: 微软雅黑;\">SVG</span></span></p>\n<p class=\"MsoNormal\" style=\"margin: 0pt 36pt; text-indent: 0pt; padding: 0pt; word-break: break-all; line-height: 14.4pt; background: #f8f8f8;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">不依赖分辨率</span></p>\n<p class=\"MsoNormal\" style=\"margin: 0pt 36pt; text-indent: 0pt; padding: 0pt; word-break: break-all; line-height: 14.4pt; background: #f8f8f8;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">支持事件处理器</span></p>\n<p class=\"MsoNormal\" style=\"margin: 0pt 36pt; text-indent: 0pt; padding: 0pt; word-break: break-all; line-height: 14.4pt; background: #f8f8f8;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">最适合带有大型渲染区域的应用程序（比如谷歌地图）</span></p>\n<p class=\"MsoNormal\" style=\"margin: 0pt 36pt; text-indent: 0pt; padding: 0pt; word-break: break-all; line-height: 14.4pt; background: #f8f8f8;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\"><span style=\"font-family: 微软雅黑;\">复杂度高会减慢渲染速度（任何过度使用</span> <span style=\"font-family: 微软雅黑;\">DOM 的应用都不快）</span></span></p>\n<p class=\"MsoNormal\" style=\"margin: 0pt 36pt; text-indent: 0pt; padding: 0pt; word-break: break-all; line-height: 14.4pt; background: #f8f8f8;\">&nbsp;</p>\n<p class=\"MsoNormal\" style=\"margin: 0pt 36pt; text-indent: 0pt; padding: 0pt; word-break: break-all; line-height: 14.4pt; background: #f8f8f8;\"><span style=\"font-family: 微软雅黑; color: #333333; letter-spacing: 0pt; font-size: 9.5pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;\">不适合游戏应用</span></p>","rank_id":92,"createdAt":"2021-06-15T10:46:27.885Z","updatedAt":"2021-06-15T10:46:27.885Z","__v":0},{"_id":"60c88554da9b3346d469d6bd","title":"div和span的区别？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p class=\"16\" style=\"margin-left: 21.0000pt; text-indent: 0.0000pt; mso-char-indent-count: 0.0000;\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 'Times New Roman';\">div</span><span class=\"15\" style=\"font-family: 宋体;\">是块级标签，</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">span</span><span class=\"15\" style=\"font-family: 宋体;\">是行级标签</span></span></p>","rank_id":93,"createdAt":"2021-06-15T10:47:48.955Z","updatedAt":"2021-06-15T10:47:48.955Z","__v":0},{"_id":"60c88572da9b3346d469d6be","title":"在html中，position取值有哪几种，默认值是什么？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p class=\"16\" style=\"margin-left: 21.0000pt; text-indent: 0.0000pt; mso-char-indent-count: 0.0000;\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">取值：</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">static</span><span class=\"15\" style=\"font-family: 宋体;\">、</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">relative</span><span class=\"15\" style=\"font-family: 宋体;\">、</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">fixed</span><span class=\"15\" style=\"font-family: 宋体;\">、</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">absolute</span></span></p>\n<p class=\"16\" style=\"margin-left: 21.0000pt; text-indent: 0.0000pt; mso-char-indent-count: 0.0000;\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">默认值：</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">static</span></span></p>","rank_id":94,"createdAt":"2021-06-15T10:48:18.191Z","updatedAt":"2021-06-15T10:48:18.191Z","__v":0},{"_id":"60c885c4da9b3346d469d6bf","title":"前端页面由哪三层构成，分别是什么？作用是什么？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">前端页面构成：结构层、表示层、行为层</span></span></p>\n<ul>\n<li><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">结构层（</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">structural layer</span><span class=\"15\" style=\"font-family: 宋体;\">）</span></span>\n<ul>\n<li><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">由</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;HTML </span><span class=\"15\" style=\"font-family: 宋体;\">或</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;XHTML</span><span class=\"15\" style=\"font-family: 宋体;\">之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">P</span><span class=\"15\" style=\"font-family: 宋体;\"><span style=\"font-family: 宋体;\">标签表达了这样一种语义：</span><span style=\"font-family: 宋体;\">&ldquo;这是一个文本段。&rdquo;</span></span></span></li>\n</ul>\n</li>\n<li><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">表示层（</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">presentation layer</span><span class=\"15\" style=\"font-family: 宋体;\">）</span></span>\n<ul>\n<li><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">由</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;CSS </span><span class=\"15\" style=\"font-family: 宋体;\">负责创建。</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;CSS</span><span class=\"15\" style=\"font-family: 宋体;\"><span style=\"font-family: 宋体;\">对</span><span style=\"font-family: 宋体;\">&ldquo;如何显示有关内容&rdquo;的问题做出了回答。</span></span></span></li>\n</ul>\n</li>\n<li><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">行为层（</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">behaviorlayer</span><span class=\"15\" style=\"font-family: 宋体;\">）</span></span>\n<ul>\n<li><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\"><span style=\"font-family: 宋体;\">负责回答</span><span style=\"font-family: 宋体;\">&ldquo;内容应该如何对事件做出反应&rdquo;这一问题。这是</span></span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;Javascript </span><span class=\"15\" style=\"font-family: 宋体;\">语言和</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;DOM</span><span class=\"15\" style=\"font-family: 宋体;\">主宰的领域。</span></span></li>\n</ul>\n</li>\n</ul>","rank_id":95,"createdAt":"2021-06-15T10:49:40.876Z","updatedAt":"2021-06-15T10:49:40.876Z","__v":0},{"_id":"60c8863cda9b3346d469d6c0","title":"如何居中一个浮动元素？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p class=\"15\" style=\"text-indent: 0.0000pt; mso-char-indent-count: 0.0000;\"><span style=\"color: #000000;\"><span style=\"font-family: 宋体; font-size: 10.5pt;\">方式</span><span style=\"font-family: Calibri; font-size: 10.5pt;\">1:</span><span style=\"font-family: 宋体; font-size: 10.5pt; background: #ffffff;\"><span style=\"font-family: 宋体;\">设置容器的浮动方式为相对定位，然后确定容器的宽高</span></span><span style=\"font-family: Arial; font-size: 10.5pt; background: #ffffff;\">&nbsp;</span><span style=\"font-family: 宋体; font-size: 10.5pt; background: #ffffff;\"><span style=\"font-family: 宋体;\">比如宽</span></span><span style=\"font-family: Arial; font-size: 10.5pt; background: #ffffff;\">500 </span><span style=\"font-family: 宋体; font-size: 10.5pt; background: #ffffff;\"><span style=\"font-family: 宋体;\">高</span></span><span style=\"font-family: Arial; font-size: 10.5pt; background: #ffffff;\">&nbsp;300 </span><span style=\"font-family: 宋体; font-size: 10.5pt; background: #ffffff;\"><span style=\"font-family: 宋体;\">的层，然后设置层的外边距。</span></span></span></p>\n<pre class=\"language-markup\"><code>&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;style type=\"text/css\"&gt;\n        div{  \n            width: 500px;  \n            height: 300px;  \n            margin: -150px 0 0 -250px;  \n            position: absolute;  \n            left: 50%;  \n            top: 50%;  \n            background-color: yellow;   \n        }  \n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div&gt;\n        元素居中  \n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p class=\"15\" style=\"margin-left: 21.0000pt; text-indent: 0.0000pt; mso-char-indent-count: 0.0000;\"><span style=\"color: #000000;\"><span style=\"font-family: 宋体; font-size: 10.5pt;\">方式</span><span style=\"font-family: Calibri; font-size: 10.5pt;\">2</span><span style=\"font-family: 宋体; font-size: 10.5pt;\">：需要</span><span style=\"font-family: Calibri; font-size: 10.5pt;\">position:absolute;</span><span style=\"font-family: 宋体; font-size: 10.5pt;\">绝对定位。而层的定位点，使用外补丁</span><span style=\"font-family: Calibri; font-size: 10.5pt;\">margin</span><span style=\"font-family: 宋体; font-size: 10.5pt;\">负值的方法。负值的大小为层自身宽度高度除以二。</span></span></p>\n<pre class=\"language-markup\"><code>&lt;style type=\"text/css\"&gt;\n&lt;!-- \ndiv {\nposition:absolute;\ntop:50%;\nleft:50%;\nmargin:-150px 0 0 -200px;\nwidth:400px;\nheight:300px;\nborder:1px solid #008800;\n}\n--&gt;\n&lt;/style&gt;\n&lt;div&gt;让层垂直居中于浏览器窗口&lt;/div&gt;</code></pre>\n<p class=\"15\" style=\"margin-left: 21.0000pt; text-indent: 0.0000pt; mso-char-indent-count: 0.0000;\">&nbsp;</p>","rank_id":96,"createdAt":"2021-06-15T10:51:40.660Z","updatedAt":"2021-06-15T10:51:40.660Z","__v":0},{"_id":"60c88675da9b3346d469d6c1","title":"请简述HTML和XHTML最重要的4点不同？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"15\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span style=\"font-family: Calibri; font-size: 10.5pt;\">XHTML </span><span style=\"font-family: 宋体; font-size: 10.5pt;\">要求正确嵌套</span></span></li>\n<li class=\"15\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span style=\"font-family: Calibri; font-size: 10.5pt;\">XHTML </span><span style=\"font-family: 宋体; font-size: 10.5pt;\">所有元素必须关闭</span></span></li>\n<li class=\"15\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span style=\"font-family: Calibri; font-size: 10.5pt;\">XHTML </span><span style=\"font-family: 宋体; font-size: 10.5pt;\">区分大小写</span></span></li>\n<li class=\"15\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span style=\"font-family: Calibri; font-size: 10.5pt;\">XHTML </span><span style=\"font-family: 宋体; font-size: 10.5pt;\">属性值要用双引号</span></span></li>\n<li class=\"15\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span style=\"font-family: Calibri; font-size: 10.5pt;\">XHTML </span><span style=\"font-family: 宋体; font-size: 10.5pt;\">用</span><span style=\"font-family: Calibri; font-size: 10.5pt;\">&nbsp;id </span><span style=\"font-family: 宋体; font-size: 10.5pt;\">属性代替</span><span style=\"font-family: Calibri; font-size: 10.5pt;\">&nbsp;name </span><span style=\"font-family: 宋体; font-size: 10.5pt;\">属性</span></span></li>\n<li class=\"15\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span style=\"font-family: Calibri; font-size: 10.5pt;\">XHTML </span><span style=\"font-family: 宋体; font-size: 10.5pt;\">特殊字符的处理</span></span></li>\n</ul>","rank_id":97,"createdAt":"2021-06-15T10:52:37.141Z","updatedAt":"2021-06-15T10:52:37.141Z","__v":0},{"_id":"60c88697da9b3346d469d6c2","title":"页面布局中常听说的“结构与表现”分离，“结构”是指？“表现”是指？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">&ldquo;结构&rdquo;：</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">HTML</span></span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">&ldquo;表现&rdquo;：</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">CSS</span></span></li>\n</ul>","rank_id":98,"createdAt":"2021-06-15T10:53:11.429Z","updatedAt":"2021-06-15T10:53:11.429Z","__v":0},{"_id":"60c887c1da9b3346d469d6c3","title":"怎么样从web前端方面优化性能？至少列举5点？","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"16\" style=\"text-indent: 21pt;\"><!-- [if !supportLists]--><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 'Times New Roman';\">HTML</span><span class=\"15\" style=\"font-family: 宋体;\">部分</span></span>\n<ol>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!-- [if !supportLists]--><span class=\"15\" style=\"font-family: 宋体;\">语义化</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">HTML</span><span class=\"15\" style=\"font-family: 宋体;\">：好处在于可以使代码简洁清晰，支持不同设备，利于搜索引擎，便于团队开发；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">减少</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">DOM</span><span class=\"15\" style=\"font-family: 宋体;\">节点：加速页面渲染；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">给图片加上正确的宽高值：这可以减少页面重绘，同时防止图片缩放；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">防止</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">src</span><span class=\"15\" style=\"font-family: 宋体;\">属性和</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">link</span><span class=\"15\" style=\"font-family: 宋体;\">的</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">href</span><span class=\"15\" style=\"font-family: 宋体;\">属性为空：当值为空时，浏览器很可能会把当前页面当成其属性值加载；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">正确的闭合标签：如避免使用</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&lt;div/&gt;</span><span class=\"15\" style=\"font-family: 宋体;\">，浏览器会多一个将它解析成</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&lt;div\\&gt;&lt;/div\\&gt;</span><span class=\"15\" style=\"font-family: 宋体;\">的过程；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\"><span style=\"font-family: 宋体;\">链接为目录或首页的地址后面加</span><span style=\"font-family: 宋体;\">&rdquo;</span></span><span class=\"15\" style=\"font-family: 'Times New Roman';\">/</span><span class=\"15\" style=\"font-family: 宋体;\">&rdquo;，如</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">http://www.5icool.org/</span><span class=\"15\" style=\"font-family: 宋体;\">；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">用</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">LINK</span><span class=\"15\" style=\"font-family: 宋体;\">而不用</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">@import</span><span class=\"15\" style=\"font-family: 宋体;\">方式导入样式；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">样式放在页头，</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">JS</span><span class=\"15\" style=\"font-family: 宋体;\">放在页尾；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">缩小</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">favicon.ico</span><span class=\"15\" style=\"font-family: 宋体;\">并缓存；</span></span></li>\n</ol>\n</li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 'Times New Roman';\">CSS</span><span class=\"15\" style=\"font-family: 宋体;\">部分</span></span>\n<ol>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">避免使用</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;CSS Expressions(CSS</span><span class=\"15\" style=\"font-family: 宋体;\">表达式</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">)</span><span class=\"15\" style=\"font-family: 宋体;\">：如</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">background-color: expression( (new Date()).getHours()%2 ? </span><span class=\"15\" style=\"font-family: 宋体;\">&ldquo;</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">#B8D4FF</span><span class=\"15\" style=\"font-family: 宋体;\">&rdquo;</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;: </span><span class=\"15\" style=\"font-family: 宋体;\">&ldquo;</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">#F08A00</span><span class=\"15\" style=\"font-family: 宋体;\">&Prime;</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;) ;</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">避免使用</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;CSS Filter</span><span class=\"15\" style=\"font-family: 宋体;\">（</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">CSS</span><span class=\"15\" style=\"font-family: 宋体;\">滤镜）；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">使用</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">CSS</span><span class=\"15\" style=\"font-family: 宋体;\">缩写，减少代码量；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">通过</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">CSSSprites</span><span class=\"15\" style=\"font-family: 宋体;\">把同类图片合成一张，减少图片请求；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">减少查询层级：如</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">.header .logo</span><span class=\"15\" style=\"font-family: 宋体;\">要好过</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">.header .top .logo</span><span class=\"15\" style=\"font-family: 宋体;\">；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">减少查询范围：如</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">.header&gt;li</span><span class=\"15\" style=\"font-family: 宋体;\">要好过</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">.header li</span><span class=\"15\" style=\"font-family: 宋体;\">；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">避免</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">TAG</span><span class=\"15\" style=\"font-family: 宋体;\">标签与</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">CLASS</span><span class=\"15\" style=\"font-family: 宋体;\">或</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">ID</span><span class=\"15\" style=\"font-family: 宋体;\">并存：如</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">a.top</span><span class=\"15\" style=\"font-family: 宋体;\">、</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">button#submit</span><span class=\"15\" style=\"font-family: 宋体;\">；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">删除重复的</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">CSS</span><span class=\"15\" style=\"font-family: 宋体;\">；</span></span></li>\n</ol>\n</li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!-- [if !supportLists]--><span class=\"15\" style=\"font-family: 'Times New Roman';\">Javscript</span><span class=\"15\" style=\"font-family: 宋体;\">部分</span></span>\n<ol>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!-- [if !supportLists]--><span class=\"15\" style=\"font-family: 宋体;\">尽量少用全局变量；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">使用事件代理绑定事件，如将事件绑定在</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">body</span><span class=\"15\" style=\"font-family: 宋体;\">上进行代理；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">避免频繁操作</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">DOM</span><span class=\"15\" style=\"font-family: 宋体;\">节点；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">不使用</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">EVAL</span><span class=\"15\" style=\"font-family: 宋体;\">；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">减少对象查找，如</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">a.b.c.d</span><span class=\"15\" style=\"font-family: 宋体;\">这种查找方式非常耗性能，尽可能把它定义在变量里；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\"><span style=\"font-family: 宋体;\">类型转换：把数字转换成字符串使用</span><span style=\"font-family: 宋体;\">&rdquo;&rdquo;</span></span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;+ 1</span><span class=\"15\" style=\"font-family: 宋体;\">，浮点数转换成整型使用</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">Math.floor()</span><span class=\"15\" style=\"font-family: 宋体;\">或者</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">Math.round()</span><span class=\"15\" style=\"font-family: 宋体;\">；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">对字符串进行循环操作，譬如替换、查找，应使用正则表达式；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">删除重复的</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">JS</span><span class=\"15\" style=\"font-family: 宋体;\">；</span></span></li>\n</ol>\n</li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!-- [if !supportLists]--><span class=\"15\" style=\"font-family: 宋体;\">服务器部分</span></span>\n<ol>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">尽量合并</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">CSS</span><span class=\"15\" style=\"font-family: 宋体;\">、</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">JS</span><span class=\"15\" style=\"font-family: 宋体;\">文件，或将其直接写在页面上，减少</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">HTTP</span><span class=\"15\" style=\"font-family: 宋体;\">请求；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">压缩</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">CSS</span><span class=\"15\" style=\"font-family: 宋体;\">、</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">JS</span><span class=\"15\" style=\"font-family: 宋体;\">文件，缩短文件传输时间；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">避免</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">404</span><span class=\"15\" style=\"font-family: 宋体;\">错误：特别要避免给</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">404</span><span class=\"15\" style=\"font-family: 宋体;\">指定一个停摆页面，否则所有</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">404</span><span class=\"15\" style=\"font-family: 宋体;\">错误都将会加载一次页面；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">一般要求减少</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">DNS</span><span class=\"15\" style=\"font-family: 宋体;\">查询次数，如同一个页面的请求资源尽量少的使用不同的主机名，这可以减少网站并行下载的数量，但很多网站为了加速下载资源其实是特意用了多个主机名，这里要做一个权衡；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">使用</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">CDN</span><span class=\"15\" style=\"font-family: 宋体;\">加速，使用户从离自己最近的服务器下载文件；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">减少</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">Cookie</span><span class=\"15\" style=\"font-family: 宋体;\">的大小，使用无</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">cookie</span><span class=\"15\" style=\"font-family: 宋体;\">的域，客户端请求静态文件的时候，减少</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;Cookie </span><span class=\"15\" style=\"font-family: 宋体;\">的反复传输对主域名的影响；</span></span></li>\n<li class=\"16\" style=\"text-indent: 21pt;\"><span style=\"color: #000000;\"><!--[endif]--><span class=\"15\" style=\"font-family: 宋体;\">为文件头指定</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">Expires</span><span class=\"15\" style=\"font-family: 宋体;\">，使内容具有缓存性；</span></span></li>\n<li class=\"MsoNormal\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">使用</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">gzip</span><span class=\"15\" style=\"font-family: 宋体;\">压缩内容；</span></span></li>\n</ol>\n</li>\n</ul>","rank_id":99,"createdAt":"2021-06-15T10:58:09.193Z","updatedAt":"2021-06-15T10:58:09.193Z","__v":0},{"_id":"60c887ecda9b3346d469d6c4","title":"JavaScript中哪些方法获取元素?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 'Times New Roman';\">getElementById</span></span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 'Times New Roman';\">getElementsByClassName</span></span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 'Times New Roman';\">getElementsByTagName</span></span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span class=\"15\" style=\"font-family: 'Times New Roman'; color: #000000;\">getElementsByName</span></li>\n</ol>","rank_id":100,"createdAt":"2021-06-15T10:58:52.913Z","updatedAt":"2021-06-15T10:58:52.913Z","__v":0},{"_id":"60c88813da9b3346d469d6c5","title":"描述CSS hack技巧?","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"15\"><span style=\"color: #000000;\"><span style=\"font-family: 宋体; font-size: 10.5pt;\">条件注释：仅适用于</span><span style=\"font-family: Calibri; font-size: 10.5pt;\">IE</span></span></li>\n<li class=\"15\"><span style=\"color: #000000;\"><span style=\"font-family: 宋体; font-size: 10.5pt;\">特定符号：适用于能识别特定符号的浏览器</span></span></li>\n<li class=\"15\"><span style=\"font-family: 宋体; color: #000000; font-size: 10.5pt;\">内核符号：针对不同浏览器内核</span></li>\n</ol>","rank_id":101,"createdAt":"2021-06-15T10:59:31.399Z","updatedAt":"2021-06-15T10:59:31.399Z","__v":0},{"_id":"60c8884fda9b3346d469d6c6","title":"用JS截取字符串，asdfgh，要fgh;?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">方式</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">1</span><span class=\"15\" style=\"font-family: 宋体;\">：</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;&lsquo;asdfgh&rsquo;.substr(3,3)</span></span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">方式</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">2</span><span class=\"15\" style=\"font-family: 宋体;\">：</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">&nbsp;&rsquo;asdfgh&rsquo;.substring(3,5) </span><span class=\"15\" style=\"font-family: 宋体;\">或者</span><span class=\"15\" style=\"font-family: 'Times New Roman';\"> &lsquo;asdfgh&rsquo;.substring(3)</span></span></li>\n</ul>","rank_id":102,"createdAt":"2021-06-15T11:00:31.372Z","updatedAt":"2021-06-15T11:00:31.372Z","__v":0},{"_id":"60c888e3da9b3346d469d6c8","title":"IE6的双倍边距BUG指的是什么？怎么解决？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span style=\"font-family: 'courier new', courier, monospace; color: #000000;\"><span class=\"15\">双边距：</span><span style=\"font-size: 10.5pt;\">当块级元素有浮动样式的时候，给元素添加</span><span style=\"font-size: 10.5pt;\">margin-left</span><span style=\"font-size: 10.5pt;\">和</span><span style=\"font-size: 10.5pt;\">margin-right</span><span style=\"font-size: 10.5pt;\">样式，在</span><span style=\"font-size: 10.5pt;\">ie6</span><span style=\"font-size: 10.5pt;\">下就会出现双倍边距。</span></span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span style=\"font-family: 'courier new', courier, monospace; color: #000000; font-size: 10.5pt;\">解决方案：给当前元素添加样式，使当前元素不为块，如：</span><span style=\"mso-spacerun: 'yes'; font-family: Calibri; color: #ff0000; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;\"><span style=\"font-family: 'courier new', courier, monospace; color: #000000;\">display:inline;display:list-item</span> </span></li>\n</ul>","rank_id":103,"createdAt":"2021-06-15T11:02:59.830Z","updatedAt":"2021-06-15T11:02:59.830Z","__v":0},{"_id":"60c88916da9b3346d469d6c9","title":"如果制作一个访问量很大的网站，对css，js和图片应该怎么处理?","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"16\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">方法</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">1</span><span class=\"15\" style=\"font-family: 宋体;\">：资源文件按模块进行放置，有利于团队开发</span></span></li>\n<li class=\"16\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">方法</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">2</span><span class=\"15\" style=\"font-family: 宋体;\">：图片尽量采取聚合技术</span></span></li>\n<li class=\"16\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">方法</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">3</span><span class=\"15\" style=\"font-family: 宋体;\">：精简压缩</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">css</span><span class=\"15\" style=\"font-family: 宋体;\">和</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">js</span><span class=\"15\" style=\"font-family: 宋体;\">文件，减少文件大小</span></span></li>\n<li class=\"16\"><span style=\"color: #000000;\"><span class=\"15\" style=\"font-family: 宋体;\">方法</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">4</span><span class=\"15\" style=\"font-family: 宋体;\">：类库、媒体使用</span><span class=\"15\" style=\"font-family: 'Times New Roman';\">CDN</span><span class=\"15\" style=\"font-family: 宋体;\">加速，减轻服务器压力</span></span></li>\n</ul>\n<p class=\"16\" style=\"margin-left: 21.0000pt; text-indent: 0.0000pt; mso-char-indent-count: 0.0000;\"><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">&nbsp;</span></p>","rank_id":104,"createdAt":"2021-06-15T11:03:50.755Z","updatedAt":"2021-06-15T11:03:50.755Z","__v":0},{"_id":"60c8893fda9b3346d469d6ca","title":"描述ajax原理，什么是同步异步","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">Ajax</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; mso-bidi-font-family: 'Times New Roman';\">的工作原理：相当于在用户和服务器之间加了</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">&mdash;</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; mso-bidi-font-family: 'Times New Roman';\">个中间层，使用户操作与服务器响应异步化。这样把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理，减轻服务器和带宽的负担，从而达到节约</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">ISP</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; mso-bidi-font-family: 'Times New Roman';\">的空间及带宽租用成本的目的。</span></li>\n</ul>","rank_id":105,"createdAt":"2021-06-15T11:04:31.922Z","updatedAt":"2021-06-15T11:04:31.922Z","__v":0},{"_id":"60c88967da9b3346d469d6cb","title":"平时有没有使用xml和json，在ajax交互中，哪一种更易于开发和维护，js中怎么序列化JSON字符串?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"16\" style=\"margin-left: 21.0000pt; text-indent: 0.0000pt; mso-char-indent-count: 0.0000;\">&nbsp;</p>\n<ul>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; mso-bidi-font-family: 'Times New Roman';\">有，</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">json</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; mso-bidi-font-family: 'Times New Roman';\">相比</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">xml</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; mso-bidi-font-family: 'Times New Roman';\">可读性和可扩张性好、编码及解码难度较低、在数据交互中带宽占用少，并且在当下是最流行的数据交互格式。</span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; mso-bidi-font-family: 'Times New Roman';\">序列化</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">JSON</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; mso-bidi-font-family: 'Times New Roman';\">字符串：</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">eval() </span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; mso-bidi-font-family: 'Times New Roman';\">或者</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\"> JSON.parse()</span></li>\n</ul>","rank_id":106,"createdAt":"2021-06-15T11:05:11.179Z","updatedAt":"2021-06-15T11:05:11.179Z","__v":0},{"_id":"60c8898dda9b3346d469d6cc","title":"JS怎么创建一个对象?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; mso-bidi-font-family: 'Times New Roman';\">方式</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">1 : &nbsp;var obj = new Object();</span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; mso-bidi-font-family: 'Times New Roman';\">方式</span><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">2 : &nbsp;var obj = {};</span></li>\n</ul>","rank_id":107,"createdAt":"2021-06-15T11:05:49.430Z","updatedAt":"2021-06-15T11:05:49.430Z","__v":0},{"_id":"60c889bdda9b3346d469d6cd","title":"JS的typeof返回哪些数据类型?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">string</span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">number</span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">object</span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">boolean</span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">function</span></li>\n<li class=\"16\" style=\"text-indent: 0pt;\"><span class=\"15\" style=\"mso-spacerun: 'yes'; font-family: 'Times New Roman'; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri;\">undefined</span></li>\n</ol>","rank_id":108,"createdAt":"2021-06-15T11:06:37.348Z","updatedAt":"2021-06-15T11:06:37.348Z","__v":0},{"_id":"60c88a5dda9b3346d469d6ce","title":"HTTP请求有哪几种？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p>1、OPTIONS</p>\n<p>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送&lsquo;*&rsquo;的请求来测试服务器的功能性</p>\n<p>2、HEAD</p>\n<p>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。</p>\n<p>3、GET</p>\n<p>向特定的资源发出请求。注意：GET方法不应当被用于产生&ldquo;副作用&rdquo;的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url</p>\n<p>4、POST</p>\n<p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form</p>\n<p>5、PUT</p>\n<p>向指定资源位置上传其最新内容</p>\n<p>6、DELETE</p>\n<p>请求服务器删除Request-URL所标识的资源</p>\n<p>7、TRACE</p>\n<p>回显服务器收到的请求，主要用于测试或诊断</p>\n<p>8、CONNECT</p>\n<p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>","rank_id":109,"createdAt":"2021-06-15T11:09:17.723Z","updatedAt":"2021-06-15T11:09:17.723Z","__v":0},{"_id":"60c88b02da9b3346d469d6cf","title":"闭包是什么？有什么特性？请简单书写一个简单事例？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p class=\"15\" style=\"margin-left: 21.0000pt; text-indent: 0.0000pt; mso-char-indent-count: 0.0000;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;\">闭</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Calibri; mso-hansi-font-family: Calibri; font-size: 10.5000pt; mso-font-kerning: 1.0000pt;\">包：</span><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-family: Arial; color: #333333; font-size: 10.5000pt; mso-font-kerning: 1.0000pt; background: #ffffff; mso-shading: #ffffff;\"><span style=\"font-family: 宋体;\">闭包是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）</span></span></p>\n<p class=\"15\" style=\"margin-left: 21.0000pt; text-indent: 0.0000pt; mso-char-indent-count: 0.0000;\"><span style=\"mso-spacerun: 'yes'; font-family: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial; mso-bidi-font-family: Arial; color: #333333; font-size: 10.5000pt; mso-font-kerning: 1.0000pt; background: #ffffff; mso-shading: #ffffff;\"><span style=\"font-family: 宋体;\">特性：</span></span><span style=\"mso-spacerun: 'yes'; font-family: 新宋体; color: #333333; letter-spacing: 0.4000pt; font-size: 10.5000pt; mso-font-kerning: 1.0000pt; background: #ffffff; mso-shading: #ffffff;\"><span style=\"font-family: 新宋体;\">闭包是能够读取其他函数内部变量的函数，即在外面可以调用函数中的函数的变量，其实他就是将函数内外部连接起来的桥梁，示例：</span></span></p>\n<pre class=\"language-markup\"><code>&lt;script type=&rsquo;text/javascript&rsquo;&gt;\nfunction a(){\n    var i = 99;\n    iAdd = function(){\n        i++;\n    }\n    function b(){\n        alert(i);\n    }\n    return b;\n}\nvar result = a();\nresult();//结果为99\niAdd();\nresult();//结果为100 \n&lt;/script&gt;</code></pre>","rank_id":110,"createdAt":"2021-06-15T11:12:02.985Z","updatedAt":"2021-06-15T11:12:02.985Z","__v":0},{"_id":"60c88b47da9b3346d469d6d0","title":"解释jsonp的原理，以及为什么不是真正的ajax","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><!-- [if !supportLists]--><span style=\"font-family: 'courier new', courier, monospace; font-size: 12pt;\">JSONP是一种非正式传输协议，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了<span style=\"background: #ffffff;\"><span style=\"font-family: 宋体;\">。</span></span></span></li>\n</ul>","rank_id":111,"createdAt":"2021-06-15T11:13:11.641Z","updatedAt":"2021-06-15T11:13:11.641Z","__v":0},{"_id":"60c88b86da9b3346d469d6d1","title":"js延迟加载的方式有哪些？","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"MsoNormal\" style=\"background: #ffffff;\"><span style=\"font-size: 12pt;\"><span style=\"font-family: Calibri;\">defer</span><span style=\"font-family: 宋体;\">和</span><span style=\"font-family: Calibri;\">async</span><span style=\"font-family: 宋体;\">、动态创建</span><span style=\"font-family: Calibri;\">DOM</span><span style=\"font-family: 宋体;\">方式（用得最多）、按需异步载入</span><span style=\"font-family: Calibri;\">js</span></span></li>\n</ul>","rank_id":112,"createdAt":"2021-06-15T11:14:14.356Z","updatedAt":"2021-06-15T11:14:14.356Z","__v":0},{"_id":"60c88cc7da9b3346d469d6d2","title":"Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><!-- [if !supportLists]--><span style=\"font-size: 12pt;\"><span style=\"font-family: 宋体;\">用于声明文档使用那种规范（</span><span style=\"font-family: Calibri;\">html/Xhtml</span><span style=\"font-family: 宋体;\">）一般为</span><span style=\"font-family: Calibri;\">&nbsp;</span><span style=\"font-family: 宋体;\">严格</span><span style=\"font-family: Calibri;\">&nbsp;</span><span style=\"font-family: 宋体;\">过度</span><span style=\"font-family: Calibri;\">&nbsp;</span><span style=\"font-family: 宋体;\">基于框架的</span><span style=\"font-family: Calibri;\">html</span><span style=\"font-family: 宋体;\">文档</span><span style=\"font-family: Calibri;\"><br /></span><span style=\"font-family: 宋体;\">加入</span><span style=\"font-family: Calibri;\">XMl</span><span style=\"font-family: 宋体;\">声明可触发，解析方式更改为</span><span style=\"font-family: Calibri;\">IE5.5 </span><span style=\"font-family: 宋体;\">拥有</span><span style=\"font-family: Calibri;\">IE5.5</span><span style=\"font-family: 宋体;\">的</span><span style=\"font-family: Calibri;\">bug</span></span></li>\n</ul>","rank_id":113,"createdAt":"2021-06-15T11:19:35.572Z","updatedAt":"2021-06-15T11:19:35.572Z","__v":0},{"_id":"60c88cfeda9b3346d469d6d3","title":"行内元素有哪些？块级元素有哪些？CSS的盒模型？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li class=\"15\" style=\"text-indent: 0pt;\"><span style=\"font-size: 12pt;\"><span style=\"font-family: 宋体;\">块级元素：</span><span style=\"font-family: Calibri;\">div p h1 h2 h3 h4 form ul</span></span></li>\n<li class=\"15\" style=\"text-indent: 0pt;\"><span style=\"font-size: 12pt;\"><span style=\"font-family: 宋体;\">行内元素</span><span style=\"font-family: Calibri;\">: a b br i span input select</span></span></li>\n<li class=\"15\" style=\"text-indent: 0pt;\"><span style=\"font-size: 12pt;\"><span style=\"font-family: Calibri;\">Css</span><span style=\"font-family: 宋体;\">盒模型</span><span style=\"font-family: Calibri;\">:</span><span style=\"font-family: 宋体;\">内容，</span><span style=\"font-family: Calibri;\">border ,margin</span><span style=\"font-family: 宋体;\">，</span><span style=\"font-family: Calibri;\">padding</span></span></li>\n</ul>","rank_id":114,"createdAt":"2021-06-15T11:20:30.458Z","updatedAt":"2021-06-15T11:20:30.458Z","__v":0},{"_id":"60c88da6da9b3346d469d6d4","title":"html5有哪些新特性、移除了哪些元素？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li style=\"line-height: 28px;\"><span style=\"font-size: 12pt;\">HTML5 现在已经不是 SGML 的⼦集，主要是关于图像，位置，存储，多任务等功能的增加</span></li>\n<li style=\"line-height: 28px;\"><span style=\"font-size: 12pt;\">绘画 canvas</span></li>\n<li style=\"line-height: 28px;\"><span style=\"font-size: 12pt;\">⽤于媒介回放的 video 和 audio 元素</span></li>\n<li style=\"line-height: 28px;\"><span style=\"font-size: 12pt;\">本地离线存储 localStorage ⻓期存储数据，浏览器关闭后数据不丢失</span></li>\n<li style=\"line-height: 28px;\"><span style=\"font-size: 12pt;\">sessionStorage 的数据在浏览器关闭后⾃动删除</span></li>\n<li style=\"line-height: 28px;\"><span style=\"font-size: 12pt;\">语意化更好的内容元素，⽐如 article 、 footer 、 header 、 nav 、 section</span></li>\n<li style=\"line-height: 28px;\"><span style=\"font-size: 12pt;\">表单控件， calendar 、 date 、 time 、 email 、 url 、 search</span></li>\n<li style=\"line-height: 28px;\"><span style=\"font-size: 12pt;\">新的技术 webworker 、 websocket 、 Geolocation</span></li>\n</ul>\n<h2 id=\"移除的元素\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">移除的元素：</span></h2>\n<ul>\n<li><span style=\"font-size: 12pt;\">纯表现的元素： basefont 、 big 、 center 、 font 、 s 、 strike 、 tt 、 u</span></li>\n<li><span style=\"font-size: 12pt;\">对可⽤性产⽣负⾯影响的元素： frame 、 frameset 、 noframes</span></li>\n</ul>\n<h2 id=\"持-html5-新标签\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">⽀持 HTML5 新标签：</span></h2>\n<ul>\n<li><span style=\"font-size: 12pt;\">IE8/IE7/IE6 ⽀持通过 document.createElement ⽅法产⽣的标签</span></li>\n<li><span style=\"font-size: 12pt;\">可以利⽤这⼀特性让这些浏览器⽀持 HTML5 新标签</span></li>\n<li><span style=\"font-size: 12pt;\">浏览器⽀持新标签后，还需要添加标签默认的样式</span></li>\n<li><span style=\"font-size: 12pt;\">当然也可以直接使⽤成熟的框架、⽐如 html5shim</span></li>\n</ul>","rank_id":115,"createdAt":"2021-06-15T11:23:18.861Z","updatedAt":"2021-06-15T11:23:18.861Z","__v":0},{"_id":"60c88ee7da9b3346d469d6d5","title":"HTML5 引入什么新的表单属性","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\"><strong>&lt;form&gt;</strong></code><strong><span style=\"font-size: 12pt;\">新属性</span></strong>\n<ul>\n<li><span style=\"font-size: 12pt;\">autocomplete</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">属性规定表单是否应该启用自动完成功能。</span></li>\n<li><span style=\"font-size: 12pt;\">autocomplete 属性适用于&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;form&gt;</code>，以及下面的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;input&gt;</code>&nbsp;类型：</span></li>\n<li><span style=\"font-size: 12pt;\">text, search, url, telephone, email, password, date，pickers, range 以及 color。</span></li>\n<li><span style=\"font-size: 12pt;\">语法是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;form autocomplete=\"on|off\"&gt;</code></span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">novalidate</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">如果使用该属性，则提交表单时不进行内容的验证。</span></li>\n<li><span style=\"font-size: 12pt;\">novalidate 属性适用于：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;form&gt;</code>，以及以下类型的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;input&gt;</code>&nbsp;标签：</span></li>\n<li><span style=\"font-size: 12pt;\">text, search, url, telephone, email, password, date pickers, range 以及 color。</span></li>\n<li><span style=\"font-size: 12pt;\">语法：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">novalidate=\"novalidate\"</code></span></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;input&gt;</code>新属性</span></strong>\n<ul>\n<li><span style=\"font-size: 12pt;\">autocomplete</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">同上；</span></li>\n<li><span style=\"font-size: 12pt;\">演示</span></li>\n<li><span style=\"font-size: 12pt;\">autocomplete 设置off:&nbsp;<a style=\"text-decoration-line: none; color: #900b09;\" href=\"https://www.gopekka.com/console/login\">https://www.gopekka.com/console/login</a></span></li>\n<li><span style=\"font-size: 12pt;\">autocomplete 没有设置:&nbsp;<a style=\"text-decoration-line: none; color: #900b09;\" href=\"https://www.zhihu.com/signin\">https://www.zhihu.com/signin</a></span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">autofocus</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">规定输入字段在页面加载时是否获得焦点，加载完成后，光标马上定位在该 input；</span></li>\n<li><span style=\"font-size: 12pt;\">（不适用于 type=&ldquo;hidden&rdquo;）语法：autofocus=&ldquo;autofocus&rdquo;；</span></li>\n<li><span style=\"font-size: 12pt;\">或者写一个 autofocus 也可以的；</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">form</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">form 属性的值必须是其所属表单的 id。</span></li>\n<li><span style=\"font-size: 12pt;\">如需引用一个以上的表单，请使用空格分隔的列表。</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">formaction</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">属性覆盖 form 元素的 action 属性，比如两个提交按钮的时候，一个是正常提交，一个是管理员提交。该属性适用于 type=&ldquo;submit&rdquo; 以及 type=&ldquo;image&rdquo;。</span></li>\n<li><span style=\"font-size: 12pt;\">语法是 formaction=\"#\"</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">formenctype</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">formenctype 属性覆盖 form 元素的 enctype 属性。</span></li>\n<li><span style=\"font-size: 12pt;\">该属性与 type=&ldquo;submit&rdquo; 和 type=&ldquo;image&rdquo; 配合使用。</span></li>\n<li><span style=\"font-size: 12pt;\">属性规定在发送到服务器之前应该如何对表单数据进行编码。</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">formmethod</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">覆盖表单的 method 属性。</span></li>\n<li><span style=\"font-size: 12pt;\">适用于 type=&ldquo;submit&rdquo; 和 type=&ldquo;image&rdquo;</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">formnovalidate</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">formnovalidate 属性覆盖 form 元素的 novalidate 属性。</span></li>\n<li><span style=\"font-size: 12pt;\">如果使用该属性，则提交表单时按钮不会执行验证过程。</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">formtarget</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">覆盖表单的 target 属性。</span></li>\n<li><span style=\"font-size: 12pt;\">适用于 type=&ldquo;submit&rdquo; 和 type=&ldquo;image&rdquo;， 该属性规定在何处打开 action URL。</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">height 和 width</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">height 和 width 属性规定用于 image 类型的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;input&gt;</code>&nbsp;标签的图像高度和宽度。</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">min 和 max</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">min 属性与 max 属性配合使用，可创建合法值范围，两个要一对用。</span></li>\n<li><span style=\"font-size: 12pt;\">语法是 选择 0-10 数字：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;input type=\"number\" name=\"points\" min=\"0\" max=\"10\" /&gt;</code></span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">multiple</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">如果使用该属性，则允许一个以上的值，比如上传文件的时候，设置这个属性后可以一次选择几个图片；</span></li>\n<li><span style=\"font-size: 12pt;\">multiple 属性适用于以下类型的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;input&gt;</code>&nbsp;标签：email 和 file。</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">pattern (regexp)</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">描述了一个正则表达式用于验证&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;input&gt;</code>&nbsp;元素的值；注释：pattern 属性适用于以下&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;input&gt;</code>&nbsp;类型：text, search, url, telephone, email 以及 password 。</span></li>\n<li><span style=\"font-size: 12pt;\">提示：请使用标准的 &ldquo;title&rdquo; 属性来描述模式。</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">placeholder</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">提供可描述输入字段预期值的提示信息（hint）。</span></li>\n<li><span style=\"font-size: 12pt;\">该提示会在输入字段为空时显示，并会在字段获得焦点时消失。</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">required</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">规定必需在提交之前填写输入字段。&nbsp;如果使用该属性，则字段是必填（或必选）的。</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">step</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">为输入域规定合法的数字间隔。&nbsp;如果 step=&ldquo;3&rdquo;，则合法的数是 -3,0,3,6 等</span></li>\n<li><span style=\"font-size: 12pt;\">提示： step 属性可以与 max 和 min 属性创建一个区域值。</span></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","rank_id":116,"createdAt":"2021-06-15T11:28:39.832Z","updatedAt":"2021-06-15T11:28:39.832Z","__v":0},{"_id":"60c88f65da9b3346d469d6d6","title":"Doctype作⽤? 严格模式与混杂模式如何区分？它们有何意义?","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">⻚⾯被加载的时， link 会同时被加载，⽽ @imort ⻚⾯被加载的时， link 会同时被加载，⽽ @import 引⽤的 CSS 会等到⻚⾯被加载完再加载 import 只在 IE5 以上才能识别，⽽ link 是 XHTML 标签，⽆兼容问题 link ⽅式的样式的权重 ⾼于 @import 的权重</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;!DOCTYPE&gt;</code>&nbsp;声明位于⽂档中的最前⾯，处于&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;html&gt;</code>&nbsp;标签之前。告知浏览器的解析器， ⽤什么⽂档类型 规范来解析这个⽂档</li>\n<li style=\"padding: 0px; margin: 0px;\">严格模式的排版和 JS 运作模式是 以该浏览器⽀持的最⾼标准运⾏</li>\n<li style=\"padding: 0px; margin: 0px;\">在混杂模式中，⻚⾯以宽松的向后兼容的⽅式显示。模拟⽼式浏览器的⾏为以防⽌站点⽆法⼯作。 DOCTYPE 不存在或格式不正确会导致⽂档以混杂模式呈现</li>\n</ul>","rank_id":117,"createdAt":"2021-06-15T11:30:45.350Z","updatedAt":"2021-06-15T11:30:45.350Z","__v":0},{"_id":"60c88fbada9b3346d469d6d7","title":"img 中的 alt 和元素的 title 属性作用","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li id=\"img-的-alt-属性\" style=\"font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">img 的 alt 属性</span>\n<ul>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">如果无法显示图像，浏览器将显示 alt 指定的内容</span></li>\n</ul>\n</li>\n<li id=\"元素-title-属性\" style=\"font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">元素 title 属性</span>\n<ul>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在鼠标移到元素上时显示 title 的内容</span></li>\n</ul>\n</li>\n<li id=\"img-的-title-和-alt-有什么区别\" style=\"font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">img 的 title 和 alt 有什么区别</span>\n<ul>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">通常当⿏标滑动到元素上的时候显示title,</span></li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">alt 是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;img&gt;</code>&nbsp;的特有属性，是图⽚内容的等价描述，⽤于图⽚⽆法加载时显示、读屏器 阅读图⽚。可提图⽚⾼可访问性，除了纯装饰图⽚外都必须设置有意义的值，搜索引擎会重点分析。</span></li>\n</ul>\n</li>\n</ul>","rank_id":118,"createdAt":"2021-06-15T11:32:10.458Z","updatedAt":"2021-06-15T11:32:10.458Z","__v":0},{"_id":"60c88fedda9b3346d469d6d8","title":"HTML全局属性(global attribute)有哪些","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">class :为元素设置类标识</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">data-* : 为元素增加⾃定义属性</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">draggable : 设置元素是否可拖拽</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">id : 元素 id ，⽂档内唯⼀</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">lang : 元素内容的的语⾔</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">style : ⾏内 css 样式</span></li>\n<li><span style=\"font-size: 12pt;\">title : 元素相关的建议信息</span></li>\n</ul>","rank_id":119,"createdAt":"2021-06-15T11:33:01.189Z","updatedAt":"2021-06-15T11:33:01.189Z","__v":0},{"_id":"60c8905ada9b3346d469d6d9","title":"meta viewport相关","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ol class=\"linenums\" style=\"padding: 0px 0px 0px 10px; margin: 0px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace; font-size: 14px; color: #495666; white-space: pre;\">\n<li class=\"L0\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\">\n<pre class=\"language-markup\"><code>&lt;!DOCTYPE html&gt; &lt;!--H5标准声明，使⽤ HTML5 doctype，不区分⼤⼩写--&gt;\n&lt;head lang=&rdquo;en&rdquo;&gt; &lt;!--标准的 lang 属性写法--&gt;\n&lt;meta charset=&rsquo;utf-8&prime;&gt; &lt;!--声明⽂档使⽤的字符编码--&gt;\n&lt;meta http-equiv=&rdquo;X-UA-Compatible&rdquo; content=&rdquo;IE=edge,chrome=1&Prime;/&gt; &lt;!--优先使\n&lt;meta name=&rdquo;description&rdquo; content=&rdquo;不超过150个字符&rdquo;/&gt; &lt;!--⻚⾯描述--&gt;\n&lt;meta name=&rdquo;keywords&rdquo; content=&rdquo;&rdquo;/&gt; &lt;!-- ⻚⾯关键词--&gt;\n&lt;meta name=&rdquo;author&rdquo; content=&rdquo;name, email@gmail.com&rdquo;/&gt; &lt;!--⽹⻚作者--&gt;\n&lt;meta name=&rdquo;robots&rdquo; content=&rdquo;index,follow&rdquo;/&gt; &lt;!--搜索引擎抓取--&gt;\n&lt;meta name=&rdquo;viewport&rdquo; content=&rdquo;initial-scale=1, maximum-scale=3, minimum-sc\n&lt;meta name=&rdquo;apple-mobile-web-app-title&rdquo; content=&rdquo;标题&rdquo;&gt; &lt;!--iOS 设备 begin--&gt;\n&lt;meta name=&rdquo;apple-mobile-web-app-capable&rdquo; content=&rdquo;yes&rdquo;/&gt; &lt;!--添加到主屏后的标\n是否启⽤ WebApp 全屏模式，删除苹果默认的⼯具栏和菜单栏--&gt;\n&lt;meta name=&rdquo;apple-itunes-app&rdquo; content=&rdquo;app-id=myAppStoreID, affiliate-data=\n&lt;!--添加智能 App ⼴告条 Smart App Banner（iOS 6+ Safari）--&gt;\n&lt;meta name=&rdquo;apple-mobile-web-app-status-bar-style&rdquo; content=&rdquo;black&rdquo;/&gt;\n&lt;meta name=&rdquo;format-detection&rdquo; content=&rdquo;telphone=no, email=no&rdquo;/&gt; &lt;!--设置苹果\n&lt;meta name=&rdquo;renderer&rdquo; content=&rdquo;webkit&rdquo;&gt; &lt;!-- 启⽤360浏览器的极速模式(webkit)--&gt;\n&lt;meta http-equiv=&rdquo;X-UA-Compatible&rdquo; content=&rdquo;IE=edge&rdquo;&gt; &lt;!--避免IE使⽤兼容模\n&lt;meta http-equiv=&rdquo;Cache-Control&rdquo; content=&rdquo;no-siteapp&rdquo; /&gt; &lt;!--不让百度转码-\n&lt;meta name=&rdquo;HandheldFriendly&rdquo; content=&rdquo;true&rdquo;&gt; &lt;!--针对⼿持设备优化，主要是针\n&lt;meta name=&rdquo;MobileOptimized&rdquo; content=&rdquo;320&Prime;&gt; &lt;!--微软的⽼式浏览器--&gt;\n&lt;meta name=&rdquo;screen-orientation&rdquo; content=&rdquo;portrait&rdquo;&gt; &lt;!--uc强制竖屏--&gt;\n&lt;meta name=&rdquo;x5-orientation&rdquo; content=&rdquo;portrait&rdquo;&gt; &lt;!--QQ强制竖屏--&gt;\n&lt;meta name=&rdquo;full-screen&rdquo; content=&rdquo;yes&rdquo;&gt; &lt;!--UC强制全屏--&gt;\n&lt;meta name=&rdquo;x5-fullscreen&rdquo; content=&rdquo;true&rdquo;&gt; &lt;!--QQ强制全屏--&gt;\n&lt;meta name=&rdquo;browsermode&rdquo; content=&rdquo;application&rdquo;&gt; &lt;!--UC应⽤模式--&gt;\n&lt;meta name=&rdquo;x5-page-mode&rdquo; content=&rdquo;app&rdquo;&gt; &lt;!-- QQ应⽤模式--&gt;\n&lt;meta name=&rdquo;msapplication-tap-highlight&rdquo; content=&rdquo;no&rdquo;&gt; &lt;!--windows phone\n设置⻚⾯不缓存--&gt;\n&lt;meta http-equiv=&rdquo;pragma&rdquo; content=&rdquo;no-cache&rdquo;&gt;\n&lt;meta http-equiv=&rdquo;cache-control&rdquo; content=&rdquo;no-cache&rdquo;&gt;\n&lt;meta http-equiv=&rdquo;expires&rdquo; content=&rdquo;</code></pre>\n</li>\n</ol>","rank_id":120,"createdAt":"2021-06-15T11:34:50.937Z","updatedAt":"2021-06-15T11:34:50.937Z","__v":0},{"_id":"60c89073da9b3346d469d6da","title":"简述⼀下src与href的区别","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">src ⽤于替换当前元素，href⽤于在当前⽂档和引⽤资源之间确⽴联系。</li>\n<li style=\"padding: 0px; margin: 0px;\">src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌⼊到⽂档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应⽤到⽂档内，例如 js 脚本，img 图⽚和 frame 等元素\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script src =\"js.js\"&gt;&lt;/script&gt;</code>&nbsp;当浏览器解析到该元素时，会暂停其他</li>\n<li style=\"padding: 0px; margin: 0px;\">资源的下载和处理，直到将该资源加载、编译、执⾏完毕，图⽚和框架等元素</li>\n<li style=\"padding: 0px; margin: 0px;\">也如此，类似于将所指向资源嵌⼊当前标签内。这也是为什么将js脚本放在底</li>\n<li style=\"padding: 0px; margin: 0px;\">部⽽不是头部</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">href 是 Hypertext Reference 的缩写，指向⽹络资源所在位置，建⽴和当前元素（锚点）或当前⽂档（链接）之间的链接，如果我们在⽂档中添加</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;link href=\"common.css\" rel=\"stylesheet\"/&gt;</code>&nbsp;那么浏览器会识别该⽂档为 css ⽂件，就会并⾏下载资源并且不会停⽌对当前⽂档的处理。这也是为什么建议使⽤ link ⽅式来加载 css ，⽽不是使⽤ @import ⽅式</li>\n</ul>","rank_id":121,"createdAt":"2021-06-15T11:35:15.460Z","updatedAt":"2021-06-15T11:35:15.460Z","__v":0},{"_id":"60c890aeda9b3346d469d6db","title":"Cookie 有哪些弊端","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">cookie 虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。</span></p>\n<h2 id=\"cookie-数量有限制\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">cookie 数量有限制</span></h2>\n<ul>\n<li><span style=\"font-size: 12pt;\">IE6 或更低版本最多 20 个 cookie</span></li>\n<li><span style=\"font-size: 12pt;\">IE7 和之后的版本最后可以有 50 个 cookie。</span></li>\n<li><span style=\"font-size: 12pt;\">Firefox 最多 50 个 cookie</span></li>\n<li><span style=\"font-size: 12pt;\">chrome 和 Safari 没有做硬性限制</span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">IE 和 Opera&nbsp;会清理近期最少使用的 cookie，Firefox 会随机清理 cookie。</span></p>\n<h2 id=\"大小限制\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">大小限制</span></h2>\n<ul>\n<li><span style=\"font-size: 12pt;\">cookie 的最大大约为 4096 字节，为了兼容性，一般不能超过 4095 字节。</span></li>\n<li><span style=\"font-size: 12pt;\">IE&nbsp;提供了一种存储可以持久化用户数据，叫做 uerData，从 IE5.0 就开始支持。</span></li>\n<li><span style=\"font-size: 12pt;\">每个数据最多 128K，每个域名下最多 1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。</span></li>\n</ul>\n<h2 id=\"优点极高的扩展性和可用性\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">优点：极高的扩展性和可用性</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">通过良好的编程，控制保存在 cookie 中的 session 对象的大小。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">通过加密和安全传输技术（SSL），减少 cookie 被破解的可能性。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie。</span></li>\n</ul>\n<h2 id=\"缺点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">缺点</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">Cookie`数量和长度的限制。</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">每个 domain 最多只能有 20 条 cookie，每个 cookie 长度不能超过 4KB，否则会被截掉。</span></li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">安全性问题。</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">如果 cookie 被人拦截了，那人就可以取得所有的 session 信息。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">即使加密也与事无补，因为拦截者并不需要知道 cookie 的意义，他只要原样转发 cookie 就可以达到目的了。</span></li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">有些状态不可能保存在客户端。</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</span></li>\n</ul>\n</li>\n</ul>","rank_id":122,"createdAt":"2021-06-15T11:36:14.144Z","updatedAt":"2021-06-15T11:36:14.144Z","__v":0},{"_id":"60c890fbda9b3346d469d6dc","title":"cookies,sessionStorage,localStorage 的区别","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h2 id=\"共同点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">共同点</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">都是保存在浏览器端，且同源的</span></p>\n<h2 id=\"cookie-与-localstorage-的区别\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">cookie 与 localStorage 的区别</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">大小区别</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">cookie 支持的数据内容小，8k 左右。localStorage 目前能支持到 10M.</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">cookie 不能跨域访问，作为 http 请求的一部分，无意中增加带宽。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">localStorage 本地持久化。</span></li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">使用区别</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">Web Storage 拥有 setItem,getItem,removeItem,clear 等方法</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">不像 cookie 需要前端开发者自己封装 setCookie，getCookie。</span></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"sessionstorage-和-localstorage\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">sessionStorage 和 localStorage</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">localStorage 适用于长期存储数据，浏览器关闭后数据不丢失</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">sessionStorage 存储的数据在浏览器关闭后自动删除</span></li>\n</ul>\n<h2 id=\"cookie-与-sessionstorage-和-localstorage\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">cookie 与 sessionStorage 和 localStorage</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。</span></li>\n</ul>\n<h2 id=\"总结如下\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">总结如下</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">cookie 在浏览器和服务器间来回传递。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">sessionStorage 和 localStorage 不会</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">sessionStorage 和 localStorage 的存储空间更大；</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">sessionStorage 和 localStorage 有更多丰富易用的接口；</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">sessionStorage 和 localStorage 各自独立的存储空间；</span></li>\n</ul>\n<p>&nbsp;</p>\n<h2 id=\"经典的总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 14pt;\">经典的总结</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 14pt;\">cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 14pt;\">cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 14pt;\">sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</span></li>\n</ul>\n<h3 id=\"存储大小\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 14pt;\">存储大小</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 14pt;\">cookie 数据大小不能超过 4k。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 14pt;\">sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</span></li>\n</ul>\n<h3 id=\"有期时间\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 14pt;\">有期时间</span></h3>\n<p>&nbsp;</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 14pt;\">localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 14pt;\">sessionStorage 数据在当前浏览器窗口关闭后自动删除。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 14pt;\">cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭</span></li>\n</ul>","rank_id":123,"createdAt":"2021-06-15T11:37:31.074Z","updatedAt":"2021-06-15T11:37:31.074Z","__v":0},{"_id":"60c89134da9b3346d469d6dd","title":"浏览器本地存储是怎么样的","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在较高版本的浏览器中，js 提供了 sessionStorage 和 globalStorage。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在 HTML5 中提供了 localStorage 来取代 globalStorage。</span></p>\n<h2 id=\"webstorage-包括了两种存储方式\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">Web&nbsp;Storage 包括了两种存储方式</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">html5 中的 Web&nbsp;Storage 包括了两种存储方式：sessionStorage 和 localStorage。</span></p>\n<h3 id=\"localstorage\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">localStorage</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">适用于长期存储数据，浏览器关闭后数据不丢失 sessionStorage 存储的数据在浏览器关闭后自动删除</span></p>\n<h3 id=\"sessionstorage\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">sessionStorage</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">而 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</span></p>","rank_id":124,"createdAt":"2021-06-15T11:38:28.766Z","updatedAt":"2021-06-15T11:38:28.766Z","__v":0},{"_id":"60c891c4da9b3346d469d6de","title":"HTML 'data-'属性的作用是什么？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">data-xxx</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">&nbsp;为前端开发者提供自定义的属性，这些属性集可以通过对象的 dataset 属性获取，不支持该属性的浏览器可以通过 getAttribute 方法获取；</span></p>\n<pre class=\"language-javascript\"><code>ar cur = document.getElementById('cur');\n//使用attributes方法存取data-*自定义属性的值非常方便\nvar trueImg = cur.getAttribute(\"data-img\");\n//使用setAttribute设置 data- 属性\ncur.setAttribute('data-site', 'http://www.xxx');</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">需要注意的是，</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">data-</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">&nbsp;之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。</span></p>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">示例：</span></p>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">语法非常简单。所有在元素上以 data- 开头的属性为数据属性。比如说你有一篇文章，而你又想要存储一些不需要显示在浏览器上的额外信息。请使用 data 属性：</span></p>\n<pre class=\"language-markup\"><code>&lt;article\n  id=\"electriccars\"\n  data-columns=\"3\"\n  data-index-number=\"12314\"\n  data-parent=\"cars\"&gt;\n...\n&lt;/article&gt;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在外部使用 JavaScript 去访问这些属性的值同样非常简单。你可以使用 getAttribute() 配合它们完整的 HTML 名称去读取它们，但标准定义了一个更简单的方法：DOMStringMap 你可以使用 dataset 读取到数据。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">为了使用 dataset 对象去获取到数据属性，需要获取属性名中 data- 之后的部分（要注意的是破折号连接的名称需要改写为骆驼拼写法（如\"index-number\"转换为\"indexNumber\"))。</p>","rank_id":125,"createdAt":"2021-06-15T11:40:52.351Z","updatedAt":"2021-06-15T11:40:52.351Z","__v":0},{"_id":"60c891dbda9b3346d469d6df","title":"页面导入样式时，使用 link 和 @import 有什么区别？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">(1)&nbsp;link 属于 HTML 标签，而 @import 是 CSS 提供的；</li>\n<li style=\"padding: 0px; margin: 0px;\">(2)&nbsp;页面被加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载；</li>\n<li style=\"padding: 0px; margin: 0px;\">(3)&nbsp;import 只在 IE5 以上才能识别，而 link 是 HTML 标签，无兼容问题；</li>\n<li style=\"padding: 0px; margin: 0px;\">(4) link 方式的样式的权重 高于 @import 的权重。</li>\n</ul>","rank_id":126,"createdAt":"2021-06-15T11:41:15.864Z","updatedAt":"2021-06-15T11:41:15.864Z","__v":0},{"_id":"60c8920ada9b3346d469d6e0","title":"defer 和 async 的区别","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h2 id=\"defer\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">defer</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">多个 defer 脚本会按照它们在页面出现的顺序加载。<strong>渲染完再执行</strong></span></p>\n<h2 id=\"async\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">async</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。多个 async 脚本是不能保证加载顺序的。==&ldquo;下载完就执行&rdquo;==</span></p>","rank_id":127,"createdAt":"2021-06-15T11:42:02.266Z","updatedAt":"2021-06-15T11:42:02.266Z","__v":0},{"_id":"60c8922dda9b3346d469d6e1","title":"怎样处理 移动端 1px 被 渲染成 2px 问题？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">viewport 设置成等于 idealviewport 造成比例不同的原因</span></p>\n<h2 id=\"meta-标签中的-viewport-属性-initial-scale-设置为-1\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">meta 标签中的 viewport 属性 ，initial-scale 设置为 1</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">rem 按照设计稿标准走，外加利用 transfrome 的 scale(0.5) 缩小一倍即可； 2 全局处理</span></p>\n<h2 id=\"meta-标签中的-viewport-属性-initial-scale-设置为-05\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">meta 标签中的 viewport 属性 ，initial-scale 设置为 0.5</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">rem 按照设计稿标准走即可</span></p>","rank_id":128,"createdAt":"2021-06-15T11:42:37.796Z","updatedAt":"2021-06-15T11:42:37.796Z","__v":0},{"_id":"60c8926cda9b3346d469d6e2","title":"浏览器是如何渲染页面的","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h2 id=\"解析-html-文件创建-dom-树\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">解析 HTML 文件，创建 DOM 树</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。</span></p>\n<h2 id=\"解析-css\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">解析 CSS</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">优先级：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">浏览器默认设置</code>&lt;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">用户设置</code>&lt;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">外部样式</code>&lt;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">内联样式</code>&lt;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">HTML中的style样式</code>；</span></p>\n<h2 id=\"构建渲染树\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">构建渲染树</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">将 CSS 与 DOM 合并，构建渲染树（Render Tree）</span></p>\n<h2 id=\"布局和绘制\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">布局和绘制</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">布局和绘制，重绘（repaint）和重排（reflow）</span></p>","rank_id":129,"createdAt":"2021-06-15T11:43:40.137Z","updatedAt":"2021-06-15T11:43:40.137Z","__v":0},{"_id":"60c8929fda9b3346d469d6e3","title":"网页验证码是干嘛的，是为了解决什么安全问题","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h2 id=\"核心\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">核心</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">用来鉴别人还是机器的方法，防止账号被机器或者工具恶意操作。</span></p>\n<h2 id=\"安全角度说\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">安全角度说</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">是为了增加密码破解的时间成本。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">对于那些设置弱口令的用户来说，由于验证码的存在，使得破解他们帐号的（暴力 / 穷举）时间成本大大的增加。</span></p>\n<h2 id=\"总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">总结</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</span></p>","rank_id":130,"createdAt":"2021-06-15T11:44:31.064Z","updatedAt":"2021-06-15T11:44:31.064Z","__v":0},{"_id":"60c892b5da9b3346d469d6e4","title":"对 WEB 标准以及 W3C 的理解与认识","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链 css 和 js 脚本、</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性；</p>","rank_id":131,"createdAt":"2021-06-15T11:44:53.608Z","updatedAt":"2021-06-15T11:44:53.608Z","__v":0},{"_id":"60c89313da9b3346d469d6e5","title":"table 和 div+css 的区别","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><span style=\"font-size: 12pt;\">核心</span>\n<ul>\n<li><span style=\"font-size: 12pt;\">速度和加载方式方面的区别</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">div</span>\n<ul>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;div&gt;</code>：加载方式是即读即加载，遇到<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;div&gt;</code>&nbsp;没有遇到<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;/div&gt;</code>&nbsp;的时候一样加载<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;div&gt;</code>&nbsp;中的内容，读多少加载多少；</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">table</span>\n<ul>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;table&gt;</code>：加载方式是完成后加载，遇到<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;table&gt;</code>&nbsp;后，在读到<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;/table&gt;</code>&nbsp;之前，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;table&gt;</code>&nbsp;中的内容不加载</span></li>\n</ul>\n</li>\n</ul>","rank_id":132,"createdAt":"2021-06-15T11:46:27.696Z","updatedAt":"2021-06-15T11:46:27.696Z","__v":0},{"_id":"60c8935bda9b3346d469d6e6","title":"行内元素有哪些？块级元素有哪些？ 空 (void) 元素有那些？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">CSS 规范规定，每个元素都有 display 属性，确定该元素的类型，每个元素都有默认的 display 值，比如 div&nbsp;默认 display 属性值为&ldquo;block&rdquo;，成为&ldquo;块级&rdquo;元素；span 默认 display 属性值为&ldquo;inline&rdquo;，是&ldquo;行内&rdquo;元素。</span></p>\n<h2 id=\"行内元素有\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">行内元素有</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">a</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">b</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">span</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">img</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">input</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">select</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">strong（强调的语气）</span></li>\n</ul>\n<h2 id=\"块级元素有\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">块级元素有</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">div</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">ul</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">ol</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">li</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">dl</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">dt</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">dd</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">h1</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">h2</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">h3</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">h4</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">p</span></li>\n</ul>\n<h2 id=\"知名的空元素\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">知名的空元素</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;br&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;hr&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;img&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;input&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;link&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;meta&gt;</code></span></p>\n<h2 id=\"鲜为人知的\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">鲜为人知的</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;area&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;base&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;col&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;command&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;embed&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;keygen&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;param&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;source&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;track&gt;</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;wbr&gt;</code></span></p>","rank_id":133,"createdAt":"2021-06-15T11:47:39.650Z","updatedAt":"2021-06-15T11:47:39.650Z","__v":0},{"_id":"60c89390da9b3346d469d6e7","title":"如何在页面上实现一个圆形的可点击区域","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">主题没有标准答案，有几个点需要注意下；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">面试官在考察这类问题的时候，主要是看你从哪个方向入手</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">能想到用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">map+area</code>&nbsp;或者&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">svg</code>&nbsp;的，我觉得 html 可能比较熟；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">能想到&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">border-radius</code>&nbsp;的，我觉得 css 可能比较熟。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果实在想不出来什么，我就引导他回答纯 js 实现，这个时候就问问怎么求一个点在圆上这种简单算法，加上 js 的 Math 几个 api，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">怎么获取鼠标坐标什么的。</p>","rank_id":134,"createdAt":"2021-06-15T11:48:32.643Z","updatedAt":"2021-06-15T11:48:32.643Z","__v":0},{"_id":"60c893f3da9b3346d469d6e8","title":"CSS中定位的方式有哪些？position属性的值有哪些？他们之间的区别是什么？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这个题目可能的问法有两种</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">CSS中定位的方式有哪些？</li>\n<li style=\"padding: 0px; margin: 0px;\">position属性的值有哪些？他们之间的区别是什么？</li>\n</ul>\n<h2 id=\"精简的答案\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">精简的答案</h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">默认值：initial（浏览器默认值）</li>\n<li style=\"padding: 0px; margin: 0px;\">继承父级元素的定位机制：inherit</li>\n<li style=\"padding: 0px; margin: 0px;\">默认：static</li>\n<li style=\"padding: 0px; margin: 0px;\">相对定位：relative</li>\n<li style=\"padding: 0px; margin: 0px;\">绝对定位：absolute（注意<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">z-index</code>）</li>\n<li style=\"padding: 0px; margin: 0px;\">固定定位：fixed</li>\n<li style=\"padding: 0px; margin: 0px;\">粘性定位：sticky该定位基于用户滚动的位置。</li>\n</ul>\n<h2 id=\"详细解说\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">详细解说</h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><strong>initial</strong>：设置该属性为浏览器默认值</li>\n<li style=\"padding: 0px; margin: 0px;\"><strong>inherit</strong>&nbsp;：规定应该从父元素继承&nbsp;position&nbsp;属性的值。</li>\n<li style=\"padding: 0px; margin: 0px;\"><strong>static</strong>&nbsp;：默认值。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">没有定位，元素出现在正常的流中（忽略&nbsp;top,&nbsp;bottom,&nbsp;left,&nbsp;right&nbsp;或者&nbsp;z-index&nbsp;声明）。&nbsp;</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><strong>relative</strong>&nbsp;：生成相对定位的元素，相对于其正常位置进行定位。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">因此，&ldquo;left:20&rdquo;&nbsp;会向元素的&nbsp;LEFT&nbsp;位置添加&nbsp;20&nbsp;像素。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><strong>absolute</strong>：&nbsp;生成绝对定位的元素，相对于&nbsp;static&nbsp;定位以外的第一个父元素进行定位。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">元素的位置通过&nbsp;&ldquo;left&rdquo;,&nbsp;&ldquo;top&rdquo;,&nbsp;&ldquo;right&rdquo;&nbsp;以及&nbsp;&ldquo;bottom&rdquo;&nbsp;属性进行规定。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><strong>fixed</strong>&nbsp;：生成绝对定位的元素，相对于浏览器窗口进行定位。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">元素的位置通过&nbsp;&ldquo;left&rdquo;,&nbsp;&ldquo;top&rdquo;,&nbsp;&ldquo;right&rdquo;&nbsp;以及&nbsp;&ldquo;bottom&rdquo;&nbsp;属性进行规定。fixed旧版本IE不支持</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><strong>sticky</strong>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">粘性定位，该定位基于用户滚动的位置。（特定阈值指的是 top, right, bottom 或 left 之一）\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">它的行为就像 position:relative; 而当页面滚动超出目标区域时，</li>\n<li style=\"padding: 0px; margin: 0px;\">它的表现就像 position:fixed;，它会固定在目标位置。</li>\n<li style=\"padding: 0px; margin: 0px;\">注意: Internet Explorer, Edge 15 及更早 IE 版本不支</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","rank_id":135,"createdAt":"2021-06-15T11:50:11.849Z","updatedAt":"2021-06-15T11:50:11.849Z","__v":0},{"_id":"60c89416da9b3346d469d6e9","title":"position的值relative和absolute是相对于谁进行定位的？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h2 id=\"relative和absolute定位原点是\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">relative和absolute定位原点是</h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">relative 的定位原点是相对正常位置；相对于文档流；&ldquo;相对于\"它的原始起点进行移动。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">（再一点，相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其他框）</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">absolute 是定位原点是有定位属性的父元素左上角；如果没有这个父元素，则相对于body；</li>\n</ul>\n<h2 id=\"经典总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">经典总结.</h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">absolute\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">fixed （老IE不支持）\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">生成绝对定位的元素，相对于浏览器窗口进行定位。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">relative\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">生成相对定位的元素，相对于其在普通流中的位置进行定位。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">static 默认值。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">inherit\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">规定从父元素继承 position 属性的值</li>\n</ul>\n</li>\n</ul>","rank_id":136,"createdAt":"2021-06-15T11:50:46.951Z","updatedAt":"2021-06-15T11:50:46.951Z","__v":0},{"_id":"60c8944fda9b3346d469d6ea","title":"设置元素浮动后，该元素的display值是什么？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">自动变成\n<ul>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">display:block;</code></li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">absolute</code>和<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">float</code>都会隐式改变display；</li>\n</ul>\n</li>\n</ul>","rank_id":137,"createdAt":"2021-06-15T11:51:43.839Z","updatedAt":"2021-06-15T11:51:43.839Z","__v":0},{"_id":"60c89478da9b3346d469d6eb","title":"清除浮动的⼏种⽅式，各⾃的优缺点","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">⽗级 div 定义 height</li>\n<li style=\"padding: 0px; margin: 0px;\">结尾处加空 div 标签 clear:both</li>\n<li style=\"padding: 0px; margin: 0px;\">⽗级 div 定义伪类 :after 和 zoom</li>\n<li style=\"padding: 0px; margin: 0px;\">⽗级 div 定义 overflow:hidden</li>\n<li style=\"padding: 0px; margin: 0px;\">⽗级 div 也浮动，需要定义宽度</li>\n<li style=\"padding: 0px; margin: 0px;\">结尾处加 br 标签 clear:both</li>\n<li style=\"padding: 0px; margin: 0px;\">⽐较好的是第3种⽅式，好多⽹站都这么⽤</li>\n</ul>","rank_id":138,"createdAt":"2021-06-15T11:52:24.210Z","updatedAt":"2021-06-15T11:52:24.210Z","__v":0},{"_id":"60c89507da9b3346d469d6ec","title":"怎么使用浮动元素,有什么问题以及怎么解决这些问题。","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">需要浮动的元素可使用CSS中float属性来定义元素的浮动位置，</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">left：往左浮动</li>\n<li style=\"padding: 0px; margin: 0px;\">right：往右浮动</li>\n</ul>\n<h2 id=\"浮动元素引起的问题\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">浮动元素引起的问题</h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">父元素的高度无法被撑开，影响与父元素同级的元素</li>\n<li style=\"padding: 0px; margin: 0px;\">与浮动元素同级的非浮动元素会跟随其后</li>\n<li style=\"padding: 0px; margin: 0px;\">若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</li>\n</ul>\n<h2 id=\"解决方法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">解决方法：</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">使用CSS中的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">clear:both;</code>属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式：</p>\n<pre class=\"language-css\"><code>.clearfix:after{\n    content: \"\";\n    display: block;\n    height: 0;\n    clear: both;\n    visibility: hidden;\n}\n.clearfix{\n    display: inline-block;\n}  /* for IE/Mac */</code></pre>","rank_id":139,"createdAt":"2021-06-15T11:54:47.793Z","updatedAt":"2021-06-15T11:54:47.793Z","__v":0},{"_id":"60c8952dda9b3346d469d6ed","title":"position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">两个或多个毗邻的普通流中的块元素垂直方向上的&nbsp;margin&nbsp;会折叠。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">只有垂直方向的&nbsp;margin&nbsp;才会折叠，也就是说，水平方向的&nbsp;margin&nbsp;不会发生折叠的现象。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">参与折叠的&nbsp;margin&nbsp;都是正值；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在&nbsp;margin&nbsp;都是正数的情况下，取其中&nbsp;margin&nbsp;较大的值为最终&nbsp;margin&nbsp;值。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当&nbsp;margin&nbsp;都是负值的时候，取的是其中绝对值较大的，然后，从&nbsp;0&nbsp;位置，负向位移。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">元素自身的&nbsp;margin-bottom&nbsp;和&nbsp;margin-top&nbsp;相邻时也会折叠</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠</p>","rank_id":140,"createdAt":"2021-06-15T11:55:25.938Z","updatedAt":"2021-06-15T11:55:25.938Z","__v":0},{"_id":"60c89554da9b3346d469d6ee","title":"display有哪些值？说明他们的作用。","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ol>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>display&nbsp;显示状态有:</strong></li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>none</strong>&nbsp;&nbsp;隐藏，此元素不会被显示。</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>block</strong>&nbsp;块显示；此元素将显示为块级元素，此元素前后会带有换行符。</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>inline</strong>&nbsp;内嵌&nbsp;，默认。此元素会被显示为内联元素，元素前后没有换行符。</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>table</strong>&nbsp;表格显示，此元素会作为块级表格来显示（类似&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;table&gt;</code>），表格前后带有换行符。</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>inline-block</strong>：元素既具有&nbsp;block&nbsp;元素可以设置宽高的特性，同时又具有&nbsp;inline&nbsp;元素默认不换行的特性。</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>list-item</strong>:象块类型元素一样显示，并添加样式列表标记。</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>inherit</strong>&nbsp;规定应该从父元素继承 display 属性的值</li>\n</ol>","rank_id":141,"createdAt":"2021-06-15T11:56:04.800Z","updatedAt":"2021-06-15T11:56:04.800Z","__v":0},{"_id":"60c89575da9b3346d469d6ef","title":"display:none和visibility:hidden的区别？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这两个声明都可以让元素隐藏，不同之处在于display:none隐藏后的元素不占据任何空间它各边的元素会合拢，就当他从来不存在，而visibility:hidden隐藏的元素空间依旧存在。&rdquo;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">想在想想，自己实在是浮躁了点。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这种程度的答案说明你在HTML/CSS方面的造诣只是了解这个层面，并不能让面试官眼前一亮。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">目前，我所知道的不同有三点（欢迎补充）：<strong>空间占据、回流与渲染、株连性</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">第一点，想必都知道；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">第二点，display:none隐藏产生reflow和repaint(回流与重绘)，而visibility:hidden没有这个影响前端性能的问题；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">第三点估计是不少同行不知道的，就是&ldquo;株连性&rdquo;方面的差异。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">所谓&ldquo;株连性&rdquo;，就是如果祖先元素遭遇某祸害，则其子子孙孙无一例外也要遭殃。display:none就是&ldquo;株连性&rdquo;明显的声明：一旦父节点元素应用了display:none，父节点及其子孙节点元素全部不可见，而且无论其子孙元素如何不屈地挣扎都无济于事。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">何时隐藏&ldquo;失效&rdquo;？很简单，如果子孙元素应用了visibility:visible，那么这个子孙元素可以显现出来。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对比总结：这两个声明都可以让元素隐藏</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>display:none</strong>；隐藏后的元素不占据任何空间，有株连性，父级设置none，子元素就显示不出来了，回引起渲染与回流，影响性能。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>visibility:hidden</strong>；隐藏的元素空间依旧存在；伪株连性，父级设计hidden，子元素默认不现实，但是可以用过visibility:visible显示出子元素，无渲染与回流。</p>","rank_id":142,"createdAt":"2021-06-15T11:56:37.815Z","updatedAt":"2021-06-15T11:56:37.815Z","__v":0},{"_id":"60c8959ada9b3346d469d6f0","title":"display、float、position的关系","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">display、float、position的关系：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">如果 display 取值为 none ，那么 position 和 float 都不起作⽤，这种情况下元素不产⽣框</li>\n<li style=\"padding: 0px; margin: 0px;\">否则，如果 position 取值为 absolute 或者 fixed ，框就是绝对定位的， float 的计算值为 none ， display 根据下⾯的表格进⾏调整。</li>\n<li style=\"padding: 0px; margin: 0px;\">否则，如果 float 不是 none ，框是浮动的， display 根据下表进⾏调整</li>\n<li style=\"padding: 0px; margin: 0px;\">否则，如果元素是根元素， display 根据下表进⾏调整</li>\n<li style=\"padding: 0px; margin: 0px;\">其他情况下 display 的值为指定值</li>\n<li style=\"padding: 0px; margin: 0px;\">总结起来：绝对定位、浮动、根元素都需要调整 display</li>\n</ul>","rank_id":143,"createdAt":"2021-06-15T11:57:14.026Z","updatedAt":"2021-06-15T11:57:14.026Z","__v":0},{"_id":"60c895c3da9b3346d469d6f1","title":"CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">visibility:</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>visible</strong>：默认值。元素是可见的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>hidden</strong>：元素是不可见的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>collapse</strong>：当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为&nbsp;&ldquo;hidden&rdquo;。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">建议说不要使用这个值，因为浏览器的不统一。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。</p>","rank_id":144,"createdAt":"2021-06-15T11:57:55.466Z","updatedAt":"2021-06-15T11:57:55.466Z","__v":0},{"_id":"60c895ecda9b3346d469d6f2","title":"CSS3有哪些新特性？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h2 id=\"精简的总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">精简的总结</h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">CSS3实现圆角（border-radius），阴影（box-shadow），</li>\n<li style=\"padding: 0px; margin: 0px;\">对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</li>\n<li style=\"padding: 0px; margin: 0px;\">transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜</li>\n<li style=\"padding: 0px; margin: 0px;\">增加了更多的CSS选择器 &nbsp;多背景 rgba&nbsp;</li>\n<li style=\"padding: 0px; margin: 0px;\">在CSS3中唯一引入的伪元素是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">::selection</code>.</li>\n<li style=\"padding: 0px; margin: 0px;\">媒体查询，多栏布局</li>\n<li style=\"padding: 0px; margin: 0px;\">border-image</li>\n</ul>\n<h2 id=\"详细的总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">详细的总结</h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">1、CSS3圆角表格圆角表格，对应属性：border-radius。</li>\n<li style=\"padding: 0px; margin: 0px;\">2、以往对网页上的文字加特效只能用filter这个属性，这次CSS3中专门制订了一个加文字特效的属性，而且不止加阴影这种效果。对应属性：font-effect。</li>\n<li style=\"padding: 0px; margin: 0px;\">3、丰富了对链接下划线的样式，以往的下划线都是直线，这次可不一样了，有波浪线、点线、虚线等等，更可对下划线的颜色和位置进行任意改变。（还有对应顶线和中横线的样式，效果与下划线类似）对应属性：text-underline-style，text-underline-color，text-underline-mode，text-underline-position。</li>\n<li style=\"padding: 0px; margin: 0px;\">4、在文字下点几个点或打个圈以示重点，CSS3也开始加入了这项功能，这应该在某些特定网页上很有用。对应属性：font-emphasize-style和font-emphasize-position。</li>\n<li style=\"padding: 0px; margin: 0px;\">边框（Borders）\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">border-color:控制边框颜色，并且有了更大的灵活性，可以产生渐变效果</li>\n<li style=\"padding: 0px; margin: 0px;\">border-image:控制边框图象&nbsp;CSS3边框border-corner-image:控制边框边角的图象</li>\n<li style=\"padding: 0px; margin: 0px;\">border-radius:能产生类似圆角矩形的效果</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">背景（Backgrounds）\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">background-origin:决定了背景在盒模型中的初始位置，提供了3个值，border,&nbsp;padding和content</li>\n<li style=\"padding: 0px; margin: 0px;\">border:控制背景起始于左上角的边框</li>\n<li style=\"padding: 0px; margin: 0px;\">padding:控制背景起始于左上角的留白</li>\n<li style=\"padding: 0px; margin: 0px;\">content:控制背景起始于左上角的内容&nbsp;CSS3背景background-clip:决定边框是否覆盖住背景（默认是不覆盖），提供了两个值，border和padding</li>\n<li style=\"padding: 0px; margin: 0px;\">border:会覆盖住背景</li>\n<li style=\"padding: 0px; margin: 0px;\">padding:不会覆盖背景</li>\n<li style=\"padding: 0px; margin: 0px;\">background-size:可以指定背景大小，以象素或百分比显示。当指定为百分比时，大小会由所在区域的宽度、高度，以及background-origin的位置决定</li>\n<li style=\"padding: 0px; margin: 0px;\">multiple&nbsp;backgrounds:多重背景图象，可以把不同背景图象只放到一个块元素里。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">文字效果（Text&nbsp;effects）\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">text-shadow:文字投影，可能是因为MAC&nbsp;OSX的Safari浏览器开始支持投影才特意增加的。</li>\n<li style=\"padding: 0px; margin: 0px;\">text&nbsp;-overflow:当文字溢出时，用&ldquo;&hellip;&rdquo;提示。包&nbsp;CSS3文字效果括ellipsis、clip、ellipsis-word、inherit，前两个CSS2就有了，目前还是部分支持，但有趣的是IE6居然也支持。ellipsis-word可以省略掉最后一个单词，对中文意义不大，inherit可以继承父级元素。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">颜色（Color）\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">HSL&nbsp;colors:除了支持RGB颜色外，还支持HSL（色相、饱和度、亮度）。以前一般都是作图的时候用HSL色谱，但这样一来会包括更多的颜色。H用度表示，S和L用百分比表示，比如hsl（0,100%,&nbsp;50%）</li>\n<li style=\"padding: 0px; margin: 0px;\">HSLA&nbsp;colors:加了个不透明度（Apacity），用0到1之间的数来表示，比如hsla（0,100%,50%,0.2）</li>\n<li style=\"padding: 0px; margin: 0px;\">opacity:直接控制不透明度，用0到1之间的数来表示</li>\n<li style=\"padding: 0px; margin: 0px;\">RGBA&nbsp;colors:和HSLA&nbsp;colors类似，加了个不透明度。一直以来，浏览器的透明一直无法实现单纯的颜色透明，每次使用alpha后就会把透明的属性继承到子节点上。换句话说，很难实现背景颜色透明而文字不透明的效果。直到RGBA颜色的出现这一切将成为现实。</li>\n<li style=\"padding: 0px; margin: 0px;\">实现这样的效果非常简单，设置颜色的时候我们使用标准的rgba（）单位即可，例如rgba（255,0,0,0.4）这样就出现了一个红色同时拥有alpha透明为0.4的颜色。</li>\n<li style=\"padding: 0px; margin: 0px;\">经过测试firefox3.0、safari3.2、opera10都支持了rgba单位。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">用户界面（User-interface）\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">resize:可以由用户自己调整div的大小，有horizontal（水平）vertical（垂直）或者both（同时），或者同时调整。如果再加上max-width或min-width的话还可以防止破坏布局</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">选择器（Selectors）\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">CSS3增加了更多的CSS选择器，可以实现更简单但是更强大的功能，比如:nth-child()等。</li>\n<li style=\"padding: 0px; margin: 0px;\">Attribute&nbsp;selectors:在属性中可以加入通配符，包括^,$,*</li>\n<li style=\"padding: 0px; margin: 0px;\">&nbsp;</li>\n<li style=\"padding: 0px; margin: 0px;\">&nbsp;</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">其它模块（Other&nbsp;modules）\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">media&nbsp;queries:感觉叫媒体选择比较合适，可以为网页中不同的对象设置不同的浏览设备。比如可以为某一块分别设置屏幕浏览样式和手机浏览样式，以前则只能设置整个网页。</li>\n<li style=\"padding: 0px; margin: 0px;\">multi-column&nbsp;layout:多列布局，让文字以多列显示，包括column-width、column-count、column-gap三个值</li>\n<li style=\"padding: 0px; margin: 0px;\">column-width:指定每列宽度</li>\n<li style=\"padding: 0px; margin: 0px;\">column-count:指定列数</li>\n<li style=\"padding: 0px; margin: 0px;\">column-gap:指定每列之间的间距</li>\n<li style=\"padding: 0px; margin: 0px;\">column-rule-color:控制列间的颜色</li>\n<li style=\"padding: 0px; margin: 0px;\">column-rule-style:控制列间的样式</li>\n<li style=\"padding: 0px; margin: 0px;\">column-rule-width:控制列间的宽度</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">column-space-distribution:平均分配列间距</li>\n</ul>\n<h2 id=\"经典的总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">经典的总结</h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">新增各种CSS选择器 （: not(.input)：所有 class 不是&ldquo;input&rdquo;的节点）</li>\n<li style=\"padding: 0px; margin: 0px;\">圆角 （border-radius:8px）</li>\n<li style=\"padding: 0px; margin: 0px;\">多列布局 （multi-column layout）</li>\n<li style=\"padding: 0px; margin: 0px;\">阴影和反射 （Shadow\\Reflect）</li>\n<li style=\"padding: 0px; margin: 0px;\">文字特效 （text-shadow、）</li>\n<li style=\"padding: 0px; margin: 0px;\">文字渲染 （Text-decoration）</li>\n<li style=\"padding: 0px; margin: 0px;\">线性渐变 （gradient）</li>\n<li style=\"padding: 0px; margin: 0px;\">旋转 （transform）</li>\n<li style=\"padding: 0px; margin: 0px;\">增加了旋转,缩放,定位,倾斜,动画，多背景</li>\n<li style=\"padding: 0px; margin: 0px;\">transform:scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg) Animation:</li>\n</ul>","rank_id":145,"createdAt":"2021-06-15T11:58:36.144Z","updatedAt":"2021-06-15T11:58:36.144Z","__v":0},{"_id":"60c89626da9b3346d469d6f3","title":"请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">设为Flex布局以后（&nbsp;display:&nbsp;flex;），子元素的float、clear和vertical-align属性将失效。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">采用Flex布局的元素，称为Flex容器（flex&nbsp;container），简称\"容器\"。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">它的所有子元素自动成为容器成员，称为Flex项目（flex&nbsp;item），简称\"项目\"。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">容器默认存在两根轴：水平的主轴（main&nbsp;axis）和垂直的交叉轴（cross&nbsp;axis）。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">主轴的开始位置（与边框的交叉点）叫做main&nbsp;start，结束位置叫做main&nbsp;end；交叉轴的开始位置叫做cross&nbsp;start，结束位置叫做cross&nbsp;end。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">项目默认沿主轴排列。单个项目占据的主轴空间叫做main&nbsp;size，占据的交叉轴空间叫做cross&nbsp;size。</p>\n<h2 id=\"容器的属性\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">容器的属性</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">以下6个属性设置在容器上（justify-content和align-items、flex-wrap:wrap最常用的）。</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">justify-content：定义了项目在主轴上的对齐方式。它可能取5个值\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">center：&nbsp;居中</li>\n<li style=\"padding: 0px; margin: 0px;\">flex-start（默认值）：左对齐</li>\n<li style=\"padding: 0px; margin: 0px;\">flex-end：右对齐</li>\n<li style=\"padding: 0px; margin: 0px;\">space-between：两端对齐，项目之间的间隔都相等。</li>\n<li style=\"padding: 0px; margin: 0px;\">space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">align-items：属性定义项目在交叉轴上如何对齐。它可能取5个值。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">center：交叉轴的中点对齐。</li>\n<li style=\"padding: 0px; margin: 0px;\">flex-start：交叉轴的起点对齐。</li>\n<li style=\"padding: 0px; margin: 0px;\">flex-end：交叉轴的终点对齐。</li>\n<li style=\"padding: 0px; margin: 0px;\">baseline:&nbsp;项目的第一行文字的基线对齐。</li>\n<li style=\"padding: 0px; margin: 0px;\">stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">flex-flow：flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row&nbsp;nowrap。</li>\n<li style=\"padding: 0px; margin: 0px;\">flex-direction：属性决定主轴的方向（即项目的排列方向）；\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">row（默认值）：主轴为水平方向，起点在左端。</li>\n<li style=\"padding: 0px; margin: 0px;\">row-reverse：主轴为水平方向，起点在右端。</li>\n<li style=\"padding: 0px; margin: 0px;\">column：主轴为垂直方向，起点在上沿。</li>\n<li style=\"padding: 0px; margin: 0px;\">column-reverse：主轴为垂直方向，起点在下沿。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">flex-wrap：默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">它可能取三个值。</li>\n<li style=\"padding: 0px; margin: 0px;\">（1）nowrap（默认）：不换行。</li>\n<li style=\"padding: 0px; margin: 0px;\">（2）wrap：换行，第一行在上方。【这个属性经常用】</li>\n<li style=\"padding: 0px; margin: 0px;\">（3）wrap-reverse：换行，第一行在下方。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">align-content：属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">flex-start：与交叉轴的起点对齐。</li>\n<li style=\"padding: 0px; margin: 0px;\">flex-end：与交叉轴的终点对齐。</li>\n<li style=\"padding: 0px; margin: 0px;\">center：与交叉轴的中点对齐。</li>\n<li style=\"padding: 0px; margin: 0px;\">space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>\n<li style=\"padding: 0px; margin: 0px;\">space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>\n<li style=\"padding: 0px; margin: 0px;\">stretch（默认值）：轴线占满整个交叉轴。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"项目的属性总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">项目的属性总结</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">以下6个属性设置在项目上。（align-self、flex、order）</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><strong>align-self</strong>：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch；该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</li>\n<li style=\"padding: 0px; margin: 0px;\">auto&nbsp;/&nbsp;flex-start&nbsp;/&nbsp;flex-end&nbsp;/&nbsp;center&nbsp;/&nbsp;baseline&nbsp;/&nbsp;stretch;</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><strong>flex</strong>：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">属性是flex-grow,&nbsp;flex-shrink&nbsp;和&nbsp;flex-basis的简写，默认值为0&nbsp;1&nbsp;auto。后两个属性可选。该属性有两个快捷值：auto&nbsp;(1&nbsp;1&nbsp;auto)&nbsp;和&nbsp;none&nbsp;(0&nbsp;0&nbsp;auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><strong>order</strong>：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><strong>flex-grow</strong>：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><strong>flex-shrink</strong>：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><strong>flex-basis</strong>：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</li>\n</ul>\n</li>\n</ul>","rank_id":146,"createdAt":"2021-06-15T11:59:34.050Z","updatedAt":"2021-06-15T11:59:34.050Z","__v":0},{"_id":"60c89645da9b3346d469d6f4","title":"CSS3新增伪类有哪些？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">CSS3新增伪类举例：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">p:first-of-type&nbsp;选择属于其父元素的首个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素的每个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素。</li>\n<li style=\"padding: 0px; margin: 0px;\">p:last-of-type&nbsp;&nbsp;选择属于其父元素的最后&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素的每个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素。</li>\n<li style=\"padding: 0px; margin: 0px;\">p:only-of-type&nbsp;&nbsp;选择属于其父元素唯一的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素的每个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素。</li>\n<li style=\"padding: 0px; margin: 0px;\">p:only-child&nbsp;&nbsp;&nbsp;&nbsp;选择属于其父元素的唯一子元素的每个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素。</li>\n<li style=\"padding: 0px; margin: 0px;\">p:nth-child(2)&nbsp;&nbsp;选择属于其父元素的第二个子元素的每个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素。</li>\n<li style=\"padding: 0px; margin: 0px;\">:enabled、:disabled&nbsp;控制表单控件的禁用状态。</li>\n<li style=\"padding: 0px; margin: 0px;\">:checked，单选框或复选框被选中。</li>\n<li style=\"padding: 0px; margin: 0px;\">:after 在元素之前添加内容,也可以用来做清除浮动。</li>\n<li style=\"padding: 0px; margin: 0px;\">:before 在元素之后添加内容</li>\n<li style=\"padding: 0px; margin: 0px;\">:enabled</li>\n<li style=\"padding: 0px; margin: 0px;\">:disabled 控制表单控件的禁用状态。</li>\n<li style=\"padding: 0px; margin: 0px;\">:checked 单选框或复选框被选中。</li>\n</ul>","rank_id":147,"createdAt":"2021-06-15T12:00:05.161Z","updatedAt":"2021-06-15T12:00:05.161Z","__v":0},{"_id":"60c89663da9b3346d469d6f5","title":"before 和 after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">双冒号是在当前规范中引入的，用于区分伪类和伪元素。但是伪类兼容现存样式，浏览器需要同时支持旧的伪类，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">比如<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">:first-line</code>、<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">:first-letter</code>、<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">:before</code>、<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">:after</code>等。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于CSS2之前已有的伪元素，比如<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">:before</code>和<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">:after</code>，单冒号和双冒号的写法<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">::before</code>和<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">::after</code>作用是一样的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果只需要兼容<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">webkit</code>、<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">firefox</code>、<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">opera</code>等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容IE浏览器，还是用CSS2的单冒号写法比较安全。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这两个伪类下特有的属性&nbsp;content&nbsp;，用于在&nbsp;CSS&nbsp;渲染中向元素逻辑上的头部或尾部添加内容。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">注意这些添加不会改变文档内容，不会出现在 DOM 中，不可复制，仅仅是在 CSS 渲染层加入。</p>","rank_id":148,"createdAt":"2021-06-15T12:00:35.735Z","updatedAt":"2021-06-15T12:00:35.735Z","__v":0},{"_id":"60c896b2da9b3346d469d6f6","title":"box-sizing；border-box是怎么回事?","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">-webkit-box-sizing:&nbsp;border-box;</code>&nbsp;&nbsp;则div&nbsp;设置的宽高将包含&nbsp;边框及&nbsp;padding；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">规定两个并排的带边框的框：</p>\n<pre class=\"language-css\"><code>div{\n    box-sizing:border-box;\n    -moz-box-sizing:border-box; /* Firefox */\n    -webkit-box-sizing:border-box; /* Safari */\n    border:1em solid red;\n    width:50%;\n    float:left;\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">两者都很方便，如果不复杂，我就用box-sizing，复杂了，就用calc()，calc()能实现border-box的所有效果，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">border-box不能实现calc()的所有效果，而且calc()更方便控制；</p>","rank_id":149,"createdAt":"2021-06-15T12:01:54.246Z","updatedAt":"2021-06-15T12:01:54.246Z","__v":0},{"_id":"60c896dfda9b3346d469d6f7","title":"margin的上下左右四个数值？什么原理？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">margin属性的四个值，总是按照上，右，下，左的顺序</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果有三个值，那左右相同（左取的是第二个值）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果有两个值，那上下相同，左右相同（下取上，左取右）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果有一个值，那四面相同（右取上，下取上，右取左）</p>","rank_id":150,"createdAt":"2021-06-15T12:02:39.559Z","updatedAt":"2021-06-15T12:02:39.559Z","__v":0},{"_id":"60c896fdda9b3346d469d6f8","title":"margin和padding分别适合什么场景使用？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">何时应当使用margin</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">需要在border外侧添加空白时。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">空白处不需要背景（色）时。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">何时应当时用padding</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">需要在border内测添加空白时。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">空白处需要背景（色）时。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">浏览器兼容性问题</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在IE5.x、IE6中，为float的盒子指定margin时，左侧margin可能会变成两倍的宽度。通过改用padding或指定盒子为display:inline可以解决。</p>","rank_id":151,"createdAt":"2021-06-15T12:03:09.313Z","updatedAt":"2021-06-15T12:03:09.313Z","__v":0},{"_id":"60c89789da9b3346d469d6f9","title":"CSS旋转属性怎么用？transform 有哪些用法","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">transform&nbsp;属性向元素应用&nbsp;2D&nbsp;或&nbsp;3D&nbsp;转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></p>\n<h2 id=\"一旋转rotate\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">一.旋转&nbsp;rotate</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">用法：transform:&nbsp;rotate(45deg);</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">共一个参数&ldquo;角度&rdquo;，单位deg为度的意思，正数为顺时针旋转，负数为逆时针旋转，上述代码作用是顺时针旋转45度。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">css&nbsp;2.0还是没有翻转的，3.0里面有rotate属性，这个可以把元素进行任意角度旋转，灰常强大。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">除了这个rotate，还有一个scale，这跟css3的rotate差不多，不过只能固定角度的旋转，来个顺时针15度就没折了，css确实很轻松的transform：rotate(15deg);&nbsp;</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这些都是需要加moz或者webkit的</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">1、水平翻转&nbsp;</span></p>\n<pre class=\"language-css\"><code>transform:scale(-1，1); </code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">filter:FlipH;&nbsp;IE的水平翻转：</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">2、垂直翻转&nbsp;</span></p>\n<pre class=\"language-css\"><code>transform:scale(1，-1);</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">filter:FlipV;&nbsp;IE的垂直翻转：</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">3、顺时针旋转90度</span></p>\n<pre class=\"language-css\"><code>-moz-transform:rotate(90deg); \n-webkit-transform:rotate(90deg); \n-o-transform:rotate(90deg); \ntransform:rotate(90deg); </code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 12pt; background-color: #ffffff;\">filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=1);&nbsp;&nbsp;IE的</span></p>\n<h2 id=\"二缩放scale\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">二.缩放&nbsp;scale</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">用法：transform:&nbsp;scale(0.5)&nbsp;&nbsp;或者&nbsp;&nbsp;transform:&nbsp;scale(0.5,&nbsp;2);</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">参数表示缩放倍数；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">一个参数时：表示水平和垂直同时缩放该倍率</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">两个参数时：第一个参数指定水平方向的缩放倍率，第二个参数指定垂直方向的缩放倍率。</span></p>\n<h2 id=\"三移动translate\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">三.移动&nbsp;translate</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">用法：transform:&nbsp;translate(45px)&nbsp;&nbsp;或者&nbsp;transform:&nbsp;skew(45px,&nbsp;150px);</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">参数表示移动距离，单位px，</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">一个参数时：表示水平方向的移动距离；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">两个参数时：第一个参数表示水平方向的移动距离，第二个参数表示垂直方向的移动距离。</span></p>\n<h2 id=\"四倾斜skew\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">四.倾斜&nbsp;skew;</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">&nbsp; 用法：transform:&nbsp;skew(30deg)&nbsp;&nbsp;或者&nbsp;transform:&nbsp;skew(30deg,&nbsp;30deg);</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">参数表示倾斜角度，单位deg</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">一个参数时：表示水平方向的倾斜角度；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">两个参数时：第一个参数表示水平方向的倾斜角度，第二个参数表示垂直方向的倾斜角度。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">skew的默认原点transform-origin是这个物件的中心点</span></p>\n<h2 id=\"五基准点transform-origin\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">五.基准点&nbsp;transform-origin</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在使用transform方法进行文字或图像的变形时，是以元素的中心点为基准点进行的。使用transform-origin属性，可以改变变形的基准点。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">用法：transform-origin:&nbsp;10px&nbsp;10px;</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">共两个参数，表示相对左上角原点的距离，单位px，</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">第一个参数表示相对左上角原点水平方向的距离，</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">第二个参数表示相对左上角原点垂直方向的距离；</span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">两个参数除了可以设置为具体的像素值，其中第一个参数可以指定为left、center、right，第二个参数可以指定为top、center、bottom。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">六.多方法组合变形</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">上面我们介绍了使用transform对元素进行旋转、缩放、移动、倾斜的方法，这里讲介绍综合使用这几个方法来对一个元素进行多重变形。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">用法：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">transform: rotate(45deg) scale(0.5) skew(30deg, 30deg) translate(100px, 100px);</code></span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\"><span style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif;\">这四种变形方法顺序可以随意，但不同的顺序导致变形结果不同，原因是变形的顺序是从左到右依次进行，这个用法中的执行顺序为1.rotate&nbsp;&nbsp;2.scalse&nbsp;&nbsp;3.skew&nbsp;&nbsp;4.translate</span></code></span></p>","rank_id":152,"createdAt":"2021-06-15T12:05:29.169Z","updatedAt":"2021-06-15T12:05:29.169Z","__v":0},{"_id":"60c897acda9b3346d469d6fa","title":"你对line-height是如何理解的？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><span style=\"font-size: 12pt;\">基线位置是由字体确定的，css的line-height指的是一行字的高度，包含了字间距，实际上就是下一行的基线到上一行的基线距离。</span></li>\n<li><span style=\"font-size: 12pt;\">line-height的值跟height的值一样，字体就会垂直居中;</span></li>\n</ul>","rank_id":153,"createdAt":"2021-06-15T12:06:04.207Z","updatedAt":"2021-06-15T12:06:04.207Z","__v":0},{"_id":"60c897d2da9b3346d469d6fb","title":"⾃定义字体的使⽤场景","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">宣传/品牌/ banner 等固定⽂案</li>\n<li style=\"padding: 0px; margin: 0px;\">字体图标</li>\n</ul>","rank_id":154,"createdAt":"2021-06-15T12:06:42.674Z","updatedAt":"2021-06-15T12:06:42.674Z","__v":0},{"_id":"60c89814da9b3346d469d6fc","title":"如何美化CheckBox","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;label&gt;</code>&nbsp;属性 for 和 id</li>\n<li style=\"padding: 0px; margin: 0px;\">隐藏原⽣的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;input&gt;</code></li>\n<li style=\"padding: 0px; margin: 0px;\">:checked +&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;label&gt;</code></li>\n</ul>","rank_id":155,"createdAt":"2021-06-15T12:07:48.518Z","updatedAt":"2021-06-15T12:07:48.518Z","__v":0},{"_id":"60c8983dda9b3346d469d6fd","title":"font-style属性可以让它赋值为“oblique” oblique是什么意思？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">要搞清楚这个问题,首先要明白字体是怎么回事.一种字体有粗体、斜体、下划线、删除线等诸多属性.</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">但是并不是所有字体都做了这些,一些不常用的字体,或许就只有个正常体,如果你用Italic,就没有效果了~这时候你就要用Oblique.</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可以理解成Italic是使用文字的斜体,Oblique是让没有斜体属性的文字倾斜!</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">明白了把?</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">另外附上CSS2.0上边的解释你参考下：</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">italic和oblique都是向右倾斜的文字,但区别在于Italic是指斜体字,而Oblique是倾斜的文字,对于没有斜体的字体应该使用Oblique属性值来实现倾斜的文字效果.</p>","rank_id":156,"createdAt":"2021-06-15T12:08:29.600Z","updatedAt":"2021-06-15T12:08:29.600Z","__v":0},{"_id":"60c89859da9b3346d469d6fe","title":"解释下浮动和它的工作原理？清除浮动的技巧；","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">浮动元素脱离文档流，不占据空间。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">浮动元素碰到包含它的边框或者浮动元素的边框停留</span></p>\n<h2 id=\"使用空标签清除浮动\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">使用空标签清除浮动</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这种方法是在所有浮动标签后面添加一个空标签&nbsp;定义css&nbsp;clear:both.&nbsp;弊端就是增加了无意义标签。</span></p>\n<h2 id=\"使用overflow\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">使用overflow</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">给包含浮动元素的父标签添加css属性&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">overflow:auto;&nbsp;zoom:1;</code> zoom:1用于兼容IE6。</span></p>","rank_id":157,"createdAt":"2021-06-15T12:08:57.592Z","updatedAt":"2021-06-15T12:08:57.592Z","__v":0},{"_id":"60c89883da9b3346d469d6ff","title":"引入样式表CSS的方式有几种？分别是什么？优先级有什么不同","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在HTML中常用以下四种方式定义CSS：</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">inline（内联式，也称行内样式）、</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">embedding（嵌入式）、</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">linking（外部引用式）</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">导入样式表（@import&nbsp;）。</span></li>\n</ul>\n<h2 id=\"详细\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">详细</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">一：内联式/行内样式：使用该属性可以直接指定样式，当然，该样式仅能用于该元素的内容，对于另一个同名的元素则不起作用。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">二：嵌入式（style）：用户可在HTML文档头部定义多个style元素，实现多个样式表。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">三：外部引用式（link）</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">①可以在多个文档间共享样式表，对于较大规模的网站，将CSS样式定义独立成一个一个的文档，可有效地提高效率，并有利于对网站风格的维护。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">②可以改变样式表，而无需更改HTML文档，这也与HTML语言内容与形式分开的原则相一致。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">③可以根据介质有选择的加载样式表。</span></li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">四：导入样式表：@import&nbsp;url(&ldquo;css/base.css&rdquo;);</span></p>\n</li>\n</ul>\n<h2 id=\"优先级就近原则\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">优先级:就近原则</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">内联式&gt;内嵌式&gt;外部引用式&gt;导入样式表</span></p>","rank_id":158,"createdAt":"2021-06-15T12:09:39.009Z","updatedAt":"2021-06-15T12:09:39.009Z","__v":0},{"_id":"60c898b8da9b3346d469d700","title":"CSS权重优先级是如何计算的？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">内联&mdash;-1000</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">id&mdash;-100</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">类&mdash;-10</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">标签/伪类&mdash;-1</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">通配符（*）&mdash;-0</span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">优先级就近原则，同权重情况下样式定义最近者为准;</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">载入样式以最后载入的定位为准;</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">优先级为:</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">!</span><span class=\"pln\" style=\"color: #000000;\">important </span><span class=\"pun\" style=\"color: #666600;\">&gt;</span><span class=\"pln\" style=\"color: #000000;\">  id </span><span class=\"pun\" style=\"color: #666600;\">&gt;</span><span class=\"pln\" style=\"color: #000000;\"> </span><span class=\"kwd\" style=\"color: #000088;\">class</span><span class=\"pln\" style=\"color: #000000;\"> </span><span class=\"pun\" style=\"color: #666600;\">&gt;</span><span class=\"pln\" style=\"color: #000000;\"> tag</span></code></span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">important 比 内联优先级高</span></p>","rank_id":159,"createdAt":"2021-06-15T12:10:32.913Z","updatedAt":"2021-06-15T12:10:32.913Z","__v":0},{"_id":"60c898d4da9b3346d469d701","title":"CSS不同选择器的权重(CSS层叠的规则)","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">!important</code>&nbsp;规则最重要，⼤于其它规则</li>\n<li style=\"padding: 0px; margin: 0px;\">⾏内样式规则，加 1000</li>\n<li style=\"padding: 0px; margin: 0px;\">对于选择器中给定的各个 ID 属性值，加 100</li>\n<li style=\"padding: 0px; margin: 0px;\">对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加 10</li>\n<li style=\"padding: 0px; margin: 0px;\">对于选择其中给定的各个元素标签选择器，加1</li>\n<li style=\"padding: 0px; margin: 0px;\">如果权值⼀样，则按照样式规则的先后顺序来应⽤，顺序靠后的覆盖靠前的规则</li>\n</ul>","rank_id":160,"createdAt":"2021-06-15T12:11:00.103Z","updatedAt":"2021-06-15T12:11:00.103Z","__v":0},{"_id":"60c898f5da9b3346d469d702","title":"浏览器是怎样解析CSS选择器的？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">CSS&nbsp;选择器解析的时候是从右往左解析的；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">简言之就是&nbsp;浏览器css匹配核心算法的规则是以&nbsp;right-to-left&nbsp;方式匹配节点的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这样做是为了使规则能够快、准、狠地与render树上的节点匹配，通俗地将就是&nbsp;就近原则。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">而如果采取&nbsp;right-to-left&nbsp;的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">野路子答案：英文顺序中一向是先小后大，先具体后宽泛。比如姓名是先名后姓、地址是X号X街X城市X州、日期是月/日/年。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">私以为西方比较强调个体价值，中国比较注重家族观念强调继承与服从。</p>","rank_id":161,"createdAt":"2021-06-15T12:11:33.856Z","updatedAt":"2021-06-15T12:11:33.856Z","__v":0},{"_id":"60c8991fda9b3346d469d703","title":"解释下CSS sprites，以及您要如何在页面或网站中使用它","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">CSS&nbsp;Sprites&nbsp;其实就是把网页中一些背景图片整合到一张图片文件中，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">再利用&nbsp;CSS&nbsp;的\"background-image\"，&ldquo;background-repeat&rdquo;，&ldquo;background-position&rdquo;&nbsp;的组合进行背景定位，background-position&nbsp;可以用数字能精确的定位出背景图片的位置。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这样可以减少很多图片请求的开销，因为请求耗时比较长；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">请求虽然可以并发，但是也有限制，一般浏览器都是6个。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于未来而言，就不需要这样做了，因为有了 http2。</p>","rank_id":162,"createdAt":"2021-06-15T12:12:15.270Z","updatedAt":"2021-06-15T12:12:15.270Z","__v":0},{"_id":"60c8993eda9b3346d469d704","title":"css sprite是什么,有什么优缺点","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h3 id=\"概念\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">概念</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">将多个⼩图⽚拼接到⼀个图⽚中。通过 background-position 和元素尺⼨调节需要显示的背景图案。</span></p>\n<h3 id=\"优点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">优点：</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">减少 HTTP 请求数，极⼤地提⾼⻚⾯加载速度</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">增加图⽚信息重复度，提⾼压缩⽐，减少图⽚⼤⼩更换⻛格⽅便，只需在⼀张或⼏张图⽚上修改颜⾊或样式即可实现</span></li>\n</ul>\n<h3 id=\"缺点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">缺点：</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">图⽚合并麻烦</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">维护麻烦，修改⼀个图⽚可能需要从新布局整个图⽚，样式</span></li>\n</ul>","rank_id":163,"createdAt":"2021-06-15T12:12:46.720Z","updatedAt":"2021-06-15T12:12:46.720Z","__v":0},{"_id":"60c89967da9b3346d469d705","title":"为什么要初始化CSS样式？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">*</code>最简单的初始化方法就是（不建议）<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">*{padding:&nbsp;0;&nbsp;margin:&nbsp;0;}</code>：</p>","rank_id":164,"createdAt":"2021-06-15T12:13:27.878Z","updatedAt":"2021-06-15T12:13:27.878Z","__v":0},{"_id":"60c899cdda9b3346d469d706","title":"二级菜单的实现方法","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">CSS用hover来实现；javascript用事件委托来实现（观察者模式）；</span></p>\n<pre class=\"language-css\"><code>.nav li:hover ul{\n    display: block;\n    width: 100px;\n/*如果不写宽度，就会水平排列*/\n    padding: 0;\n}\n.nav li:hover ul li ul{\n    display: none;\n/*隐藏三级菜单的*/\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">JS的写法如下；</span></p>\n<pre class=\"language-javascript\"><code>var tool = new Tool;\nvar oDiv2 = document.getElementById(\"div2\");\ndocument.onmouseover = function (e) {\n    e = e || window.event;//处理事件兼容性；\nvar tar = e.target || e.srcElement;//事件源；\nvar xiaomi = tar.getAttribute(\"xiaomi\");//监听的对象；\nvar ch = tool.getCss(\"height\", oDiv2);\nif (xiaomi === \"true\") {//以属性来判断；\nif (ch &lt;= 200) {\nmove.call(oDiv2, 200)\n        }\n    } else {\nif (ch &gt; 0) {\nmove.call(oDiv2, 0)\n        }\n    }\n};\nfunction move(target) {\nvar that = this;\n_move();\nfunction _move() {\nvar start = tool.getCss(\"height\", that);//要在内部，不能写在外面\nclearTimeout(that.timer);\nthat.timer = setTimeout(_move, 10);\nif (start &gt;= target) {\ntool.setCss(that, \"height\", start - 10);\nif (start - 10 &lt; target) {\ntool.setCss(that, \"height\", target);\nreturn;\n            }\n        } else if (start &lt; target) {\ntool.setCss(that,\"height\", start + 10);\nif (start + 10 &gt;= target) {\ntool.setCss(that, \"height\", target);\nreturn;\n            }\n        } else {\nreturn;\n        }\n    }\n}</code></pre>","rank_id":165,"createdAt":"2021-06-15T12:15:09.079Z","updatedAt":"2021-06-15T12:15:09.079Z","__v":0},{"_id":"60c89a37da9b3346d469d707","title":"请让页面中的一个元素（10px*10px）围绕坐标(200, 300) 做圆周运动","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">页面上画一个圆，画一个圆心。在这个圆的圆周上面画一个点，我们就让这个点绕着圆周跑；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">2.怎么让这个点跑起来呢？</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我们用javascrip的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">setInterval(function(),time);</code>这个方法；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">3.有了这个方法就好办了，我们可以每隔一段时间执行一个function，这个function负责让这个点跑起来；</p>\n<pre class=\"language-markup\"><code>&lt;script type=\"text/javascript\"&gt;\nvar r = 100; //半径\nvar a = 0;   //角度\nvar obj = document.getElementById('point');//js必须写在&lt;body&gt;后面，否则obj=null；\n// 基点坐标为200,300\nsetInterval(function(){\n  obj.style.left = (190 - Math.cos(a) * r) + 'px';/*style 很重要*/\n  obj.style.top = (290 - Math.sin(a) * r) + 'px';\n  a += 0.1; //角度随时增大，产生绕圈的效果\n  }, 50);//every 50/1000s run function() one time;\n&lt;/script&gt;</code></pre>","rank_id":166,"createdAt":"2021-06-15T12:16:55.343Z","updatedAt":"2021-06-15T12:16:55.343Z","__v":0},{"_id":"60c89a42da9b3346d469d708","title":"如果需要手动写动画，你认为最小时间间隔是多久，为什么？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为 1/60＊1000ms ＝ 16.7ms</span></p>","rank_id":167,"createdAt":"2021-06-15T12:17:06.472Z","updatedAt":"2021-06-15T12:17:06.472Z","__v":0},{"_id":"60c89a67da9b3346d469d709","title":"在网页中的应该使用奇数还是偶数的字体？为什么呢？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h2 id=\"一浏览器的原因\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">一、浏览器的原因</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">其一是为了迁就ie6，万恶的ie6会把定义为13px的字渲染成14px，</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">还有一个原因是，偶数宽的汉字，比如12px宽的汉字，去掉1像素的间距，填充了像素的实际宽是11px，这样汉字的中竖线左右是平分的，以&ldquo;中&rdquo;这个字为例，在12像素时，竖线在中间，左右各5像素，显得均衡。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">其二像谷歌一些比较流行的浏览器一般会有个默认的最小字体，而且对奇数字体渲染的不太好看</span></p>\n<h2 id=\"二实际应用\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">二、实际应用</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">偶数字号相对更容易和&nbsp;web&nbsp;设计的其他部分构成比例关系。比如：当我用了&nbsp;14&nbsp;px&nbsp;的正文字号，我可能会在一些地方用&nbsp;14&nbsp;&times;&nbsp;0.5&nbsp;=&nbsp;7&nbsp;px&nbsp;的&nbsp;margin，在另一些地方用&nbsp;14&nbsp;&times;&nbsp;1.5&nbsp;=&nbsp;21&nbsp;px&nbsp;的标题字号。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px 时用的是小一号的点阵（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</span></p>","rank_id":168,"createdAt":"2021-06-15T12:17:43.889Z","updatedAt":"2021-06-15T12:17:43.889Z","__v":0},{"_id":"60c89a88da9b3346d469d70a","title":"在 CSS 样式中常使用 px、em 两种长度单位，各有什么优劣，在表现上有什么区别？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">px 是像素，em 是相对单位，em，在缩放查看网页时，能准确缩放文字。使用 px&nbsp;作为尺寸时，部分浏览器中放大页面时，文字不会变大。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">【px就是像素值，em就是根据基准来缩放字体的大小。em是相对于父元素的属性而计算的，Rem是相对于根元素<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;html&gt;</code>，选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。】</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">任意浏览器的默认字体高都是16px。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">所有未经调整的浏览器都符合:&nbsp;1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这就使em值变为&nbsp;16px*62.5%=10px,&nbsp;这样12px=1.2em,&nbsp;10px=1em,&nbsp;也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。</span></p>\n<h2 id=\"rem特点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">rem特点&nbsp;</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">&nbsp;rem是CSS3新增的一个相对单位（root&nbsp;em，根em），这个单位引起了广泛关注。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">目前，除了IE8及更早版本外，所有浏览器均已支持rem。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">下面就是</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">一个例子：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">p {font-size:14px; font-size:.875rem;}</code></span></p>","rank_id":169,"createdAt":"2021-06-15T12:18:16.334Z","updatedAt":"2021-06-15T12:18:16.334Z","__v":0},{"_id":"60c89ab4da9b3346d469d70b","title":"使用 CSS 预处理器吗？喜欢那个？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">流行是SASS和LESS等</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这些预处理器最终得到的还是css文件。所以他们的目的就是一个&nbsp;提高开发效率。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我感觉CSS还有很多东西要学，所以对sass和less仅限于听说过的层次，主要是学习CSS基础的了，如果项目需要的话，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我相信只要CSS基础扎实，用sass或者less都可以很容易上手；</p>","rank_id":170,"createdAt":"2021-06-15T12:19:00.166Z","updatedAt":"2021-06-15T12:19:00.166Z","__v":0},{"_id":"60c89af3da9b3346d469d70c","title":"抽离样式模块怎么写，说出思路，有无实践经验？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">首一个成熟的网站需要有统一的风格，一致的用户体验，比如：网站的配色，字体的大小，交互行为一致等应该在设计之初就得到确定，而不是由个体开发者来自由的定义。</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">网站同时应存在可以提取出来公用的样式部分。那么我们就可以把网站的字体大小，公共控制，共用模块的样式都抽离出来，作为单独的模块来处理。</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这样，团队中的每个人如果需要这样的样式，都可以用这种公共样式，以此提高代码的重用率。</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我认为一个项目的CSS可以拆分成2部分：公共CSS和业务CSS。</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我们在项目中抽出的这部分可以模块化的CSS就可以归类为公共CSS。</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这部分的代码命名不应涉及到具体的业务，只应对其在模块中负责的具体逻辑负责。</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于业务CSS，我们需要有统一的命名。如一个网站中有如下几个栏目：文件，社区，社交关系等，在项目规划时，就需要把这块模块的名称定好，</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">比如&nbsp;文件-files,社区-cmty(community简写)，这样开发人员在写样式时，就可以使用公用的前缀，.cmty-cmtydetail，而不会根据各自的想法，</li>\n<li style=\"font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">写成.community或是.commu，这一点对于统一风格是尽为重要的，也方便备用人员接手工作。</li>\n</ul>","rank_id":171,"createdAt":"2021-06-15T12:20:03.103Z","updatedAt":"2021-06-15T12:20:03.103Z","__v":0},{"_id":"60c89b25da9b3346d469d70d","title":"base64有什么好处，base64有什么缺点？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">什么时候用，一般移动端的大的背景图会用base64，而且图片体积比较大的时候才会用base64；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果图片比较小，那么base64编码后的字符串会比图片本身还大，只有图片打到几百K的时候，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">用base64编码会大大缩小图片的体积；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>优点</strong>：能够减小大图片的尺寸，同时还能够减少HTTP请求数量；HTTP请求是非常耗费服务器资源的；</p>","rank_id":172,"createdAt":"2021-06-15T12:20:53.568Z","updatedAt":"2021-06-15T12:20:53.568Z","__v":0},{"_id":"60c89b43da9b3346d469d70e","title":"base64的原理及优缺点","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">优点可以加密，减少了 HTTTP 请求</li>\n<li style=\"padding: 0px; margin: 0px;\">缺点是需要消耗 CPU 进⾏编解码</li>\n</ul>","rank_id":173,"createdAt":"2021-06-15T12:21:23.077Z","updatedAt":"2021-06-15T12:21:23.077Z","__v":0},{"_id":"60c89b5dda9b3346d469d70f","title":"base64 的使⽤","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">⽤于减少 HTTP 请求</li>\n<li style=\"padding: 0px; margin: 0px;\">适⽤于⼩图⽚</li>\n<li style=\"padding: 0px; margin: 0px;\">base64 的体积约为原图的 4/3</li>\n</ul>","rank_id":174,"createdAt":"2021-06-15T12:21:49.065Z","updatedAt":"2021-06-15T12:21:49.065Z","__v":0},{"_id":"60c89b71da9b3346d469d710","title":"图片格式的问题，png色彩问题","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">图片常用的有jpg，png，png；</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">jpg一般能够把图片压缩小一点，就是压缩率高；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">png能够实现图片的透明效果；而jpg透明的部分会是白色的，同时8位的png是不能设置透明度的，只有24位可以；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">gif一般用来做冻土，比如等待加载的动画图片等；</p>\n</li>\n</ul>","rank_id":175,"createdAt":"2021-06-15T12:22:09.045Z","updatedAt":"2021-06-15T12:22:09.045Z","__v":0},{"_id":"60c89b89da9b3346d469d711","title":"png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">体积小能支持动画，chrome有针对性优化；Android就不说了，肯定支持，iOS也有支持。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">客户端里的图片显示都可以考虑webp，体积小了、流量少了、加载快了，图片质量也得到保障（同时肉眼几乎无法看出差异）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">前端用webp则还是不太稳妥，一些浏览器不支持。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">WebP&nbsp;的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">同时具备了无损和有损的压缩模式、Alpha&nbsp;透明以及动画的特性，在&nbsp;JPEG&nbsp;和&nbsp;PNG&nbsp;上的转化效果都相当优秀、稳定和统一。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可以得出结论：PNG&nbsp;转&nbsp;WebP&nbsp;的压缩率要高于&nbsp;PNG&nbsp;原图压缩率，同样支持有损与无损压缩</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">转换后的&nbsp;WebP&nbsp;体积大幅减少，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">转换后的&nbsp;WebP&nbsp;支持&nbsp;Alpha&nbsp;透明和&nbsp;24-bit&nbsp;颜色数，不存在&nbsp;PNG8&nbsp;色彩不够丰富和在浏览器中可能会出现毛边的问题</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">经测试，JPEG 转 WebP 的效果更佳</p>","rank_id":176,"createdAt":"2021-06-15T12:22:33.771Z","updatedAt":"2021-06-15T12:22:33.771Z","__v":0},{"_id":"60c89ba3da9b3346d469d712","title":"PNG\\GIF\\JPG的区别及如何选","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">GIF\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">8 位像素， 256 ⾊</li>\n<li style=\"padding: 0px; margin: 0px;\">⽆损压缩</li>\n<li style=\"padding: 0px; margin: 0px;\">⽀持简单动画</li>\n<li style=\"padding: 0px; margin: 0px;\">⽀持 boolean 透明</li>\n<li style=\"padding: 0px; margin: 0px;\">适合简单动画</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">JPEG\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">颜⾊限于 256</li>\n<li style=\"padding: 0px; margin: 0px;\">有损压缩</li>\n<li style=\"padding: 0px; margin: 0px;\">可控制压缩质量</li>\n<li style=\"padding: 0px; margin: 0px;\">不⽀持透明</li>\n<li style=\"padding: 0px; margin: 0px;\">适合照⽚</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">PNG\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">有 PNG8 和 truecolor PNG</li>\n<li style=\"padding: 0px; margin: 0px;\">PNG8 类似 GIF 颜⾊上限为 256 ，⽂件⼩，⽀持 alpha 透明度，⽆动画</li>\n<li style=\"padding: 0px; margin: 0px;\">适合图标、背景、按钮</li>\n</ul>\n</li>\n</ul>","rank_id":177,"createdAt":"2021-06-15T12:22:59.982Z","updatedAt":"2021-06-15T12:22:59.982Z","__v":0},{"_id":"60c89be8da9b3346d469d713","title":"CSS哪些属性脱离文档流","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h2 id=\"什么是文档流\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">什么是文档流？</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">将窗体自上而下分成一行一行，并在每行中按从左至右依次排放元素，称为文档流，也称为普通流。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这个应该不难理解，HTML中全部元素都是盒模型，盒模型占用一定的空间，依次排放在HTML中，形成了文档流。</span></p>\n<h2 id=\"什么是脱离文档流\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">什么是脱离文档流？</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">如果脱离文档流，那么文档原本占据文档流的位置会被它后面的元素填补。</span></p>\n<h2 id=\"css哪些属性脱离文档流\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">CSS哪些属性脱离文档流</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">脱离文档流有两种方式，浮动和定位</span></p>\n<h3 id=\"第一种定位\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">第一种:定位</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">position:absolute</code></span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">position:fixed</code></span></li>\n</ul>\n<h3 id=\"第二种浮动\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">第二种:浮动</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">float也脱离文档流；</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">float:left</code></span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">float:right</code></span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">需要注意<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">position: sticky</code>，就是&nbsp;<strong>粘性定位</strong>&nbsp;并不会脱离文档流；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">上面**什么是脱离文档流？**说了如果脱离文档流，那么文档原本占据文档流的位置会被它后面的元素填补。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">粘性定位是相对定位和固定定位的混合，元素在跨越特定阈值前为相对定位，之后为固定定位。</span></p>\n<h3 id=\"继续延伸sticky的使用注意\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">继续延伸sticky的使用注意</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><strong>1.必须指定阈值</strong></span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">也就是top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效，否则其行为与相对定位相同。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">所以如果你使用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">sticky</code>属性，那么你一定要定阙值，否则不生效；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><strong>2.父级定位不能是 absolute 和 fixed</strong></span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">如果&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">position:sticky</code>&nbsp;元素的任意父节点定位设置为&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">position:absolute | fixed</code>，则元素相对父元素进行定位，而不会相对 viewprot 定位。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">如果父节点定位设置为 relative 是没有问题的，有些人说是也不可以的，实际测试可以的（2020年最新版Chrome测试，版本 80.0.3987.100（正式版本） （64 位））。</span></p>","rank_id":178,"createdAt":"2021-06-15T12:24:08.934Z","updatedAt":"2021-06-15T12:24:08.934Z","__v":0},{"_id":"60c89c44da9b3346d469d714","title":"如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h2 id=\"方法一宽高固定\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">方法一：宽高固定</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果元素的宽高固定,那么,css指定样式为&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">top:50%;left:50%;</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">而&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">margin-top</code>&nbsp;和&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">margin-left</code>&nbsp;指定为负数，绝对值为自身宽高的一半&nbsp;；</p>\n<h2 id=\"方法二有宽度\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">方法二：有宽度</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可以使用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">margin:0&nbsp;auto;</code>可以实现居中（需要有宽度）</p>\n<pre class=\"language-css\"><code>div{\n    width:200px;\n    margin:0 auto;\n}</code></pre>\n<h2 id=\"居中一个浮动元素\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">居中一个浮动元素</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如何居中一个浮动元素？父元素和子元素同时左浮动，然后父元素相对左移动50%，再然后子元素相对右移动50%，或者子元素相对左移动-50%也就可以了。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">具体就是确定容器的宽高 宽500 高 300 的层,设置层的外边距</p>\n<pre class=\"language-css\"><code>.div {\n  width:500px ; height:300px;//高度可以不设\n  margin: -150px 0 0 -250px;\n  position:relative;         //相对定位\n  background-color:pink;     //方便看效果\n  left:50%;\n  top:50%;\n}</code></pre>\n<h2 id=\"让绝对定位的div居中\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">让绝对定位的div居中</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如何让绝对定位的div居中？</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">先把外层的相对定位的大div用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">margin:0px&nbsp;auto;</code>居中，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">然后这个绝对定位的用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">left</code>，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">top</code>来定位。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>top属性值</strong>:（父元素的高度-子元素高度）/2；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>left属性值</strong>:（父元素宽度值-子元素宽度值）/2。</p>\n<pre class=\"language-css\"><code>position: absolute;\nwidth: 1200px;\nbackground: none;\nmargin: 0 auto;\ntop: 0;\nleft: 0;\nbottom: 0;\nright: 0;</code></pre>","rank_id":179,"createdAt":"2021-06-15T12:25:40.178Z","updatedAt":"2021-06-15T12:25:40.178Z","__v":0},{"_id":"60c89c8fda9b3346d469d715","title":"请列举 CSS 中用于隐藏元素的两个属性？两者的差异？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">目前，我所知道的不同有三点（欢迎补充）：<strong>空间占据、回流与渲染、株连性</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">第一点，想必都知道；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">第二点，display:none隐藏产生reflow和repaint(回流与重绘)，而visibility:hidden没有这个影响前端性能的问题；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">第三点估计是不少同行不知道的，就是&ldquo;株连性&rdquo;方面的差异。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">所谓&ldquo;株连性&rdquo;，就是如果祖先元素遭遇某祸害，则其子子孙孙无一例外也要遭殃。display:none就是&ldquo;株连性&rdquo;明显的声明：一旦父节点元素应用了display:none，父节点及其子孙节点元素全部不可见，而且无论其子孙元素如何不屈地挣扎都无济于事。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">何时隐藏&ldquo;失效&rdquo;？很简单，如果子孙元素应用了visibility:visible，那么这个子孙元素可以显现出来。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对比总结：这两个声明都可以让元素隐藏</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>display:none</strong>；隐藏后的元素不占据任何空间，有株连性，父级设置none，子元素就显示不出来了，回引起渲染与回流，影响性能。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>visibility:hidden</strong>；隐藏的元素空间依旧存在；伪株连性，父级设置hidden，子元素默认不显示，但是可以用过visibility:visible显示出子元素，无渲染与回流。</p>","rank_id":180,"createdAt":"2021-06-15T12:26:55.112Z","updatedAt":"2021-06-15T12:26:55.112Z","__v":0},{"_id":"60c89cf1da9b3346d469d716","title":"三栏布局，中间自适应","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">左中右三栏布局，左右两栏宽度固定（要想不固定将宽度值改为百分值即可），中间栏宽度自适应。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>1、绝对定位法</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这或许是三种方法里最直观，最容易理解的：左右两栏采用绝对定位，分别固定于页面的左右两侧，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">中间的主体栏用左右margin值撑开距离。于是实现了三栏自适应布局。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>2、自身浮动法</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">此方法代码最简单。应用了标签浮动跟随的特性。左栏左浮动，右栏右浮动，主体直接放后面，就实现了自适应。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>3、margin负值法</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这种方法是在实际的网站中应用的最多的，我个人感觉多少有些跟风的嫌疑。此方法很难用一句话概括。首先，中间的主体要使用双层标签。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">外层div宽度100%显示，并且浮动（本例左浮动，下面所述依次为基础），内层div为真正的主体内容，含有左右210像素的margin值。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">左栏与右栏都是采用margin负值定位的，左栏左浮动，margin-left为-100%，由于前面的div宽度100%与浏览器，所以这里的-100%margin值正好使左栏div定位到了页面的左侧； 右侧栏也是左浮动，其margin-left也是负值，大小为其本身的宽度即200像素。</p>","rank_id":181,"createdAt":"2021-06-15T12:28:33.119Z","updatedAt":"2021-06-15T12:28:33.119Z","__v":0},{"_id":"60c89d12da9b3346d469d717","title":"元素竖向的百分比设定是相对于容器的高度吗？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">元素竖向的百分比设定是相对于容器的宽度，而不是高度；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于一些表示竖向距离的属性，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">例如&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">padding-top</code>&nbsp;,&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">padding-bottom</code>&nbsp;,&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">margin-top</code>&nbsp;,&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">margin-bottom</code>&nbsp;等，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p>","rank_id":182,"createdAt":"2021-06-15T12:29:06.614Z","updatedAt":"2021-06-15T12:29:06.614Z","__v":0},{"_id":"60c89da0da9b3346d469d718","title":"什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">响应式设计简而言之，就是一个网站能够兼容多个终端&mdash;&mdash;而不是为每个终端做一个特定的版本。</p>\n<h2 id=\"优点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">优点</h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">面对不同分辨率设备灵活性强</li>\n<li style=\"padding: 0px; margin: 0px;\">能够快捷解决多设备显示适应问题</li>\n</ul>\n<h2 id=\"缺点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">缺点</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">兼容各种设备工作量大，效率低下</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">代码累赘，会出现隐藏无用的元素，加载时间加长</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">【通过这三个步骤，你一定可以了解响应式设计的基本原理和media&nbsp;query】</p>\n<h3 id=\"第一步meta标签\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">第一步.&nbsp;Meta&nbsp;标签</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">为了适应屏幕，多数的移动浏览器会把HTML网页缩放到设备屏幕的宽度。你可以使用meta标签的viewport属性来设置。下面的代码告诉浏览器使用设备屏幕宽度作为内容的宽度，并且忽视初始的宽度设置。这段代码写在&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;head&gt;</code>里面</p>\n<pre class=\"language-markup\"><code>&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">IE8及以下的浏览器不支持media query。你可以使用 media-queries.js 或 respond.js 。这样IE就能支持media query了。</span></p>\n<pre class=\"language-markup\"><code>&lt;!--[if lt IE 9]&gt; &lt;script src=\"http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt;\n</code></pre>\n<h3 id=\"第二步html结构\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">第二步.&nbsp;HTML&nbsp;结构</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这个例子里面，有header、content、sidebar和footer等基本的网页布局。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">header&nbsp;有固定的高180px，content&nbsp;容器的宽是600px，sidebar的宽是300px。</p>\n<h3 id=\"第三步mediaqueries\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">第三步.&nbsp;Media&nbsp;Queries</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">CSS3&nbsp;media&nbsp;query&nbsp;响应式网页设计的关键。它像一个if语句，告诉浏览器如何根据特定的屏幕宽口来加载网页。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果屏幕窗口小于980px，规则就生效。设置了容器的宽度为百分比的形式而不是像素单位，这样会更加灵活。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果文档宽度小于 300 像素则修改背景演示(background-color):</p>\n<pre class=\"language-markup\"><code>@media screen and (max-width: 300px) {\n    body {\n        background-color:lightblue;\n    }\n}</code></pre>","rank_id":183,"createdAt":"2021-06-15T12:31:28.506Z","updatedAt":"2021-06-15T12:31:28.506Z","__v":0},{"_id":"60c89defda9b3346d469d719","title":"一个满屏 品 字布局 如何设计?","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">简单的方式：</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">上面的div宽100%，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">下面的两个div分别宽50%，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">然后用float或者inline使其不换行即可</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">代码如下</p>\n<pre class=\"language-markup\"><code>&lt;style&gt;\n  *{margin: 0;padding: 0;}\n  .header{width: 100%;height: 50%;background: lightcoral}\n  .wrap{width: 100%;height: 50%;background: #CCC;}\n  .wrap .left{width: 50%; height:100%;background: fuchsia;float: left;}\n  .wrap .right{width: 50%;height:100%;background: forestgreen;float: left;}\n  .clear{clear: both}\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=\"header\"&gt;&lt;/div&gt;\n&lt;div class=\"wrap\"&gt;\n  &lt;div class=\"left\"&gt;&lt;/div&gt;\n  &lt;div class=\"right\"&gt;&lt;/div&gt;\n  &lt;div class=\"clear\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>","rank_id":184,"createdAt":"2021-06-15T12:32:47.130Z","updatedAt":"2021-06-15T12:32:47.130Z","__v":0},{"_id":"60c89e54da9b3346d469d71a","title":"⼏种常⻅的CSS布局","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">流体布局</span></p>\n<pre class=\"language-css\"><code>.left {\nfloat: left;\nwidth: 100px;\nheight: 200px;\nbackground: red;\n}\n.right {\nfloat: right;\nwidth: 200px;\nheight: 200px;\nbackground: blue;\n}\n.main {\nmargin-left: 120px;\nmargin-right: 220px;\nheight: 200px;\nbackground: green;\n}</code></pre>\n<p>圣杯布局</p>\n<pre class=\"language-markup\"><code>&lt;div class=\"container\"&gt;\n&lt;div class=\"left\"&gt;&lt;/div&gt;\n&lt;div class=\"right\"&gt;&lt;/div&gt;\n&lt;div class=\"main\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n.container {\nmargin-left: 120px;\nmargin-right: 220px;\n}\n.main {\nfloat: left;\nwidth: 100%;\nheight:300px;\nbackground: green;\n}\n.left {\nposition: relative;\nleft: -120px;\nfloat: left;\nheight: 300px;\nwidth: 100px;\nmargin-left: -100%;\nbackground: red;\n}\n.right {\nposition: relative;\nright: -220px;\nfloat: right;\nheight: 300px;\nwidth: 200px;\nmargin-left: -200px;\nbackground: blue;\n}\n&lt;div class=\"container\"&gt;\n&lt;div class=\"main\"&gt;&lt;/div&gt;\n&lt;div class=\"left\"&gt;&lt;/div&gt;\n&lt;div class=\"right\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">双⻜翼布局</span></p>\n<pre class=\"language-css\"><code>.content {\nfloat: left;\nwidth: 100%;\n}\n.main {\nheight: 200px;\nmargin-left: 110px;\nmargin-right: 220px;\nbackground: green;\n}\n.main::after {\ncontent: '';\ndisplay: block;\nfont-size:0;\nheight: 0;\nzoom: 1;\nclear: both;\n}\n.left {\nfloat:left;\nheight: 200px;\nwidth: 100px;\nmargin-left: -100%;\nbackground: red;\n}\n.right {\nfloat: right;\nheight: 200px;\nwidth: 200px;\nmargin-left: -200px;\nbackground: blue;\n}\n&lt;div class=\"content\"&gt;\n&lt;div class=\"main\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"left\"&gt;&lt;/div&gt;\n&lt;div class=\"right\"&gt;&lt;/div&gt;</code></pre>\n<p>&nbsp;</p>","rank_id":185,"createdAt":"2021-06-15T12:34:28.106Z","updatedAt":"2021-06-15T12:34:28.106Z","__v":0},{"_id":"60c89e67da9b3346d469d71b","title":"CSS ⾃适应布局","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">左侧浮动或者绝对定位，然后右侧 margin 撑开</li>\n<li style=\"padding: 0px; margin: 0px;\">使⽤&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;div&gt;</code>&nbsp;包含，然后靠负 margin 形成 bfc</li>\n<li style=\"padding: 0px; margin: 0px;\">使⽤ flex</li>\n</ul>","rank_id":186,"createdAt":"2021-06-15T12:34:47.841Z","updatedAt":"2021-06-15T12:34:47.841Z","__v":0},{"_id":"60c89ea8da9b3346d469d71c","title":"有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">HTML</h2>\n<pre class=\"language-markup\"><code>&lt;div class=\"outer\"&gt;\n&lt;div class=\"A\"&gt;&lt;/div&gt;\n&lt;div class=\"B\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">CSS</h2>\n<pre class=\"language-css\"><code>html,\nbody { height: 100%; padding: 0; margin: 0; }\n.outer { height: 100%; position: relative; }\n.A { height: 100px; background: #BBE8F2; }\n.B { background: #D9C666; width: 100%; position: absolute; top: 100px ; left: 0 ; bottom: 0; }</code></pre>\n<h2 id=\"css\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>\n<h2 id=\"html\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":187,"createdAt":"2021-06-15T12:35:52.119Z","updatedAt":"2021-06-15T12:35:52.119Z","__v":0},{"_id":"60c89f14da9b3346d469d71d","title":"写一段CSS让图片（未知大小)水平垂直居中","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">写一段CSS让图片（未知大小)水平垂直居中；</span></p>\n<pre class=\"language-markup\"><code>&lt;div class=\"img_wrap\"&gt;&lt;img src=\"...\"&gt;&lt;/div&gt;</code></pre>\n<h2 id=\"方法一\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">方法一</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">该方法是将外部容器的显示模式设置成<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">display:table</code>，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">img标签外部再嵌套一个span标签，并设置span的显示模式为<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">display:table-cell</code>，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这样就可以很方便的使用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">vertical-align</code>象表格元素那样对齐了，当然这只是在标准浏览器下，IE6/IE7还得使用定位。</p>\n<pre class=\"language-markup\"><code>&lt;div id=\"box\"&gt;\n&lt;span&gt;&lt;img src=\"images/demo.jpg\" alt=\"\" /&gt;&lt;/span&gt;\n&lt;/div&gt;\n&lt;style type=\"text/css\"&gt;\n#box{\n    width:500px;height:400px;\n    display:table;\n    text-align:center;\n    border:1px solid #d3d3d3;background:#fff;\n}\n#box span{\n    display:table-cell;\n    vertical-align:middle;\n}\n#box img{\n    border:1px solid #ccc;\n}\n&lt;/style&gt;\n&lt;!--[if lte IE 7]&gt;\n&lt;style type=\"text/css\"&gt;\n#box{\n    position:relative;\n    overflow:hidden;\n}\n#box span{\n    position:absolute;\n    left:50%;top:50%;\n}\n#box img{\n    position:relative;\n    left:-50%;top:-50%;\n}\n&lt;/style&gt;\n&lt;![endif]--&gt;</code></pre>\n<h2 id=\"方法二\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">方法二</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在img标签外包裹一个p标签，标准浏览器利用p标签的伪类属性:before来实现，IE6/IE7使用了CSS表达式来实现兼容。</p>\n<pre class=\"language-markup\"><code>&lt;div id=\"box\"&gt;&lt;p&gt;&lt;img src=\"images/demo.jpg\" alt=\"\"/&gt;&lt;/p&gt;&lt;/div&gt;</code></pre>\n<pre class=\"language-css\"><code>#box{\n    width:500px;height:400px;\n    text-align:center;\n    border:1px solid #d3d3d3;background:#fff;\n}\n#box p{\n    width:500px;height:400px;\n    line-height:400px; /* 行高等于高度 */\n}\n  \n/* 兼容标准浏览器 */\n#box p:before{\n    content:\".\"; /* 具体的值与垂直居中无关，尽可能的节省字符 */\n    margin-left:-5px; font-size:10px; /* 修复居中的小BUG */\n    visibility:hidden; /*设置成隐藏元素*/\n}\n#box p img{\n    *margin-top:expression((400 - this.height )/2); /* CSS表达式用来兼容IE6/IE7 */\n    vertical-align:middle;\n    border:1px solid #ccc;\n}</code></pre>","rank_id":188,"createdAt":"2021-06-15T12:37:40.439Z","updatedAt":"2021-06-15T12:37:40.439Z","__v":0},{"_id":"60c89f70da9b3346d469d71e","title":"DIV水平和垂直居中问题，兼容低版本和移动端；","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p>1</p>\n<pre class=\"language-css\"><code>margin:0 auto;</code></pre>\n<p>2</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">left:50%;</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">然后用负margin的值（宽度的一半）；</p>","rank_id":189,"createdAt":"2021-06-15T12:39:12.537Z","updatedAt":"2021-06-15T12:39:12.537Z","__v":0},{"_id":"60c89f97da9b3346d469d71f","title":"如何垂直居中⼀个浮动元素？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-css\"><code>/**⽅法⼀：已知元素的⾼宽**/\n#div1{\n    background-color:#6699FF;\n    width:200px;\n    height:200px;\n    position: absolute; //⽗元素需要相对定位\n    top: 50%;\n    left: 50%;\n    margin-top:-100px ; //⼆分之⼀的height，width\n    margin-left: -100px;\n}\n/**⽅法⼆:**/\n#div1{\n    width: 200px;\n    height: 200px;\n    background-color: #6699FF;\n    margin:auto;\n    position: absolute; //⽗元素需要相对定位\n    left: 0;\n    top: 0;\n    right: 0;\n    bottom: 0;\n}</code></pre>","rank_id":190,"createdAt":"2021-06-15T12:39:51.240Z","updatedAt":"2021-06-15T12:39:51.240Z","__v":0},{"_id":"60c89fb9da9b3346d469d720","title":"CSS 左边定宽，右边⾃适应⽅案","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-css\"><code>/* ⽅案1 */\n.left {\n    width: 120px;\n    float: left;\n}\n.right {\n    margin-left: 120px;\n}\n/* ⽅案2 */\n.left {\n    width: 120px;\n    float: left;\n}\n.right {\n    width: calc(100% - 120px);\n    float: left;\n}</code></pre>","rank_id":191,"createdAt":"2021-06-15T12:40:25.790Z","updatedAt":"2021-06-15T12:40:25.790Z","__v":0},{"_id":"60c89fdfda9b3346d469d721","title":"CSS 左右居中","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">⾏内元素: text-align: center</li>\n<li style=\"padding: 0px; margin: 0px;\">定宽块状元素: 左右 margin 值为 auto</li>\n<li style=\"padding: 0px; margin: 0px;\">不定宽块状元素: table 布局， position + transform\n<pre class=\"language-css\"><code>/* ⽅案1 */\n.wrap {\n    text-align: center\n}\n.center {\n    display: inline;\n    /* or */\n    /* display: inline-block; */\n}\n/* ⽅案2 */\n.center {\n    width: 100px;\n    margin: 0 auto;\n}\n/* ⽅案2 */\n.wrap {\n    position: relative;\n}\n.center {\n    position: absulote;\n    left: 50%;\n    transform: translateX(-50%);\n}\n</code></pre>\n</li>\n</ul>","rank_id":192,"createdAt":"2021-06-15T12:41:03.974Z","updatedAt":"2021-06-15T12:41:03.974Z","__v":0},{"_id":"60c8a014da9b3346d469d722","title":"CSS 上下垂直居中","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">定⾼： margin ， position + margin (负值)</li>\n<li style=\"padding: 0px; margin: 0px;\">不定⾼： position + transform ， flex ， IFC + vertical-align:middle\n<pre class=\"language-css\"><code>/* 定⾼⽅案1 */\n.center {\n    height: 100px;\n    margin: 50px 0;\n}\n/* 定⾼⽅案2 */\n.center {\n    height: 100px;\n    position: absolute;\n    top: 50%;\n    margin-top: -25px;\n}\n/* 不定⾼⽅案1 */\n.center {\n    position: absolute;\n    top: 50%;\n    transform: translateY(-50%);\n}\n/* 不定⾼⽅案2 */\n.wrap {\n    display: flex;\n    align-items: center;\n}\n.center {\n    width: 100%;\n}\n/* 不定⾼⽅案3 */\n/* 设置 inline-block 则会在外层产⽣ IFC，⾼度设为 100% 撑开 wrap 的⾼度 */\n.wrap::before {\n    content: '';\n    height: 100%;\n    display: inline-block;\n    vertical-align: middle;\n}\n.wrap {\n    text-align: center;\n}\n.center {\n    display: inline-block;\n    vertical-align: middle;\n}</code></pre>\n</li>\n</ul>","rank_id":193,"createdAt":"2021-06-15T12:41:56.750Z","updatedAt":"2021-06-15T12:41:56.750Z","__v":0},{"_id":"60c8a038da9b3346d469d723","title":"CSS 盒模型","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">CSS 盒模型</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">content（元素内容） + padding（内边距） + border（边框） + margin（外边距）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">延伸： box-sizing</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">content-box ：默认值，总宽度 = margin + border + padding + width</li>\n<li style=\"padding: 0px; margin: 0px;\">border-box ：盒⼦宽度包含 padding 和 border ， 总宽度 = margin + width</li>\n<li style=\"padding: 0px; margin: 0px;\">inherit ：从⽗元素继承 box-sizing 属性</li>\n</ul>","rank_id":194,"createdAt":"2021-06-15T12:42:32.341Z","updatedAt":"2021-06-15T12:42:32.341Z","__v":0},{"_id":"60c8a075da9b3346d469d724","title":"display inline-block 什么时候会显示间隙？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当对两个或者两个以上的相同元素用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">display:inline-block</code>；他们之间会默认有一个空格（4PX）；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">w移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</p>","rank_id":195,"createdAt":"2021-06-15T12:43:33.496Z","updatedAt":"2021-06-15T12:43:33.496Z","__v":0},{"_id":"60c8a0b3da9b3346d469d725","title":"CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h2 id=\"css选择符有哪些\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">CSS选择符有哪些</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">id选择器（&nbsp;#&nbsp;myid）</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">类选择器（.myclassname）</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">标签选择器（div,&nbsp;h1,&nbsp;p）</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">相邻选择器（h1&nbsp;+&nbsp;p）</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">子选择器（ul&nbsp;&lt;&nbsp;li）</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">后代选择器（li&nbsp;a）</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">通配符选择器（&nbsp;*&nbsp;）</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">属性选择器（a[rel&nbsp;=&nbsp;&ldquo;external&rdquo;]）</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">伪类选择器（a:&nbsp;hover,&nbsp;li:&nbsp;nth&nbsp;-&nbsp;child）</span></li>\n</ul>\n<h2 id=\"可以继承\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">可以继承</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">可继承：&nbsp;font-size、&nbsp;font-family&nbsp;、color、&nbsp;UL&nbsp;、LI&nbsp;DL&nbsp;DD&nbsp;DT;</span></p>\n<h2 id=\"不可继承\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">不可继承</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">不可继承&nbsp;：border&nbsp;padding&nbsp;margin&nbsp;width&nbsp;height&nbsp;;</span></p>\n<h2 id=\"优先级算法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">优先级算法</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">1）、优先级就近原则，样式定义最近者为准;</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">2）、载入样式以最后载入的定位为准;</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">优先级为: 从样式选择器看权重优先级：important&nbsp;&gt;&nbsp;内嵌样式&nbsp;&gt;&nbsp;ID&nbsp;&gt;&nbsp;类&nbsp;&gt;&nbsp;标签&nbsp;|&nbsp;伪类&nbsp;|&nbsp;属性选择&nbsp;&gt;&nbsp;伪对象&nbsp;&gt;&nbsp;继承&nbsp;&gt;&nbsp;通配符；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">important&nbsp;比&nbsp;内联优先级高，但内敛比id要高；</span></p>\n<h2 id=\"css3新增伪类举例\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">CSS3新增伪类举例</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">p:first-of-type 选择属于其父元素的首个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素的每个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">p:last-of-type 选择属于其父元素的最后&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素的每个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">p:only-of-type 选择属于其父元素唯一的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素的每个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">p:only-child 选择属于其父元素的唯一子元素的每个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">p:nth-child(2) 选择属于其父元素的第二个子元素的每个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;p&gt;</code>&nbsp;元素。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">:enabled :disabled 控制表单控件的禁用状态。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">:checked 单选框或复选框被选中。</span></li>\n</ul>","rank_id":196,"createdAt":"2021-06-15T12:44:35.046Z","updatedAt":"2021-06-15T12:44:35.046Z","__v":0},{"_id":"60c8a0ceda9b3346d469d726","title":"三角形怎么画","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-css\"><code>.div1{\n  width: 0;\n  height: 0;\n  border-left: 50px solid transparent;\n  border-right: 50px solid transparent;\n  border-bottom: 100px solid red;\n}</code></pre>","rank_id":197,"createdAt":"2021-06-15T12:45:02.908Z","updatedAt":"2021-06-15T12:45:02.908Z","__v":0},{"_id":"60c8a12dda9b3346d469d727","title":"html5 CSS3画小米logo","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-markup\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n\t&lt;meta charset=\"UTF-8\"&gt;\n\t&lt;title&gt;css3实现小米logo &lt;/title&gt;\n\t&lt;style type=\"text/css\"&gt;\n\tbody{\n\t\tbackground-color: #ccc;\t\n\t}\n\t#main{\n\t\tbackground-color: #f57923;\n\t\twidth: 415px;\n\t\theight: 300px;\n\t\tmargin:150px auto;\n\t\tborder-radius: 25px;\n\t}\n\t#left,#right{\n\t\tbackground-color: #fff;\n\t\tmargin-top:40px;\n\t\theight: 220px;\n\t}\n\t#left{\n\t\tfloat: left;\n\t\twidth: 250px;\n\t\tmargin-left: 35px;\n\t\tborder-top-right-radius: 65px;\n\t\tz-index: -99999;\n \n\t}\n\t#inner{\n\t\tbackground-color: #f57923;\n\t\twidth: 140px;\n\t\theight: 170px;\n\t\tmargin-left: 55px;\n\t\tmargin-top: 50px;\n\t\tborder-top-right-radius: 40px;\n\t\tz-index: 10px;\n \n\t}\n\t#center{\n\t\tbackground-color: #fff;\n\t\tposition: relative;\n\t\twidth: 50px;\n\t\theight: 125px;\n\t\ttop:45px;\n\t\tleft: 45px;\n\t\tz-index:999999; }\n\t#right{\n\tfloat: right;\n\twidth: 50px;\n\tmargin-right:35px;}\n \n\t&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\t&lt;div id=\"main\"&gt;\n\t\t&lt;div id=\"left\"&gt;\n\t\t\t&lt;div id=\"inner\"&gt;\n\t\t\t\t&lt;div id=\"center\"&gt;&lt;/div&gt;\n\t\t\t&lt;/div&gt;\n\t\t&lt;/div&gt;\n\t\t&lt;div id=\"right\"&gt;&lt;/div&gt;\n\t&lt;/div&gt;\n \n\t\n&lt;/body&gt;</code></pre>","rank_id":198,"createdAt":"2021-06-15T12:46:37.229Z","updatedAt":"2021-06-15T12:46:37.229Z","__v":0},{"_id":"60c8a1e2da9b3346d469d728","title":"如何修改chrome记住密码后自动填充表单的黄色背景 ？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">chrome表单自动填充后，input文本框的背景会变成黄色的，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">通过审查元素可以看到这是由于chrome会默认给自动填充的input表单加上<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">input:-webkit-autofill</code>私有属性，然后对其赋予以下样式：</p>\n<pre class=\"language-css\"><code>input:-webkit-autofill {\n    background-color: #FAFFBD;\n    background-image: none;\n    color: #000;\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">在有些情况下，这个黄色的背景会影响到我们界面的效果，尤其是在我们给input文本框使用图片背景的时候，原来的圆角和边框都被覆盖了：</span></p>\n<h2 id=\"情景一input文本框是纯色背景的\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">情景一：input文本框是纯色背景的</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可以对input:-webkit-autofill使用足够大的纯色内阴影来覆盖input输入框的黄色背景；如：</p>\n<pre class=\"language-css\"><code>input:-webkit-autofill {\n    -webkit-box-shadow: 0 0 0px 1000px white inset;\n    border: 1px solid #CCC!important;\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果你有使用圆角等属性，或者发现输入框的长度高度不太对，可以对其进行调整，除了chrome默认定义的background-color，background-image，color不能用!important提升其优先级以外，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">其他的属性均可使用!important提升其优先级，如：</p>\n<pre class=\"language-css\"><code>input:-webkit-autofill {\n    -webkit-box-shadow: 0 0 0px 1000px white inset;\n    border: 1px solid #CCC!important;\n    height: 27px!important;\n    line-height: 27px!important;\n    border-radius: 0 4px 4px 0;\n}</code></pre>\n<h2 id=\"情景二input文本框是使用图片背景的\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">情景二：input文本框是使用图片背景的</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">1、如果你的图片背景不太复杂，只有一些简单的内阴影，那个人觉得完全可以使用上面介绍的方法用足够大的纯色内阴影去覆盖掉黄色背景，此时只不过是没有了原来的内阴影效果罢了。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">2、如果你实在想留住原来的内阴影效果，那就只能牺牲chrome自动填充表单的功能，使用js去实现，例如：</p>\n<pre class=\"language-javascript\"><code>$(function() {\n  if (navigator.userAgent.toLowerCase().indexOf(\"chrome\") &gt;= 0) {\n    $(window).load(function(){\n      $('ul input:not(input[type=submit])').each(function(){\n        var outHtml = this.outerHTML;\n        $(this).append(outHtml);\n      });\n    });\n  }\n});</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">遍历的对象可能要根据你的需求去调整。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果你不想使用js，好吧，在form标签上直接关闭了表单的自动填充功能：autocomplete=&ldquo;off&rdquo;。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">上面是在网上找到的一些方法，我是用的图片背景，经过实验如果用js的方法会导致提交表单的时候重置而无法将value传过去，没办法只能是将自动填充的功能关闭了，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">虽然影响了部分用户的体验，但是解决了黄色背景影响整体UI的问题</p>","rank_id":199,"createdAt":"2021-06-15T12:49:38.212Z","updatedAt":"2021-06-15T12:49:38.212Z","__v":0},{"_id":"60c8a21cda9b3346d469d729","title":"全屏滚动的原理是什么？用到了CSS的那些属性？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">网站有的时候为了简洁就是很多的单页滑屏滚动介绍，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">主要呈现方式有两种，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一种是整体的元素一直排列下去，假设有五个需要展示的全屏页面，那么高度是500%，只是展示100%，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">剩下的可以通过transform进行Y轴定位，也可以通过margin-top实现，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">第二种就是所有的子元素和页面一样，都显示在当前页面。</p>","rank_id":200,"createdAt":"2021-06-15T12:50:36.905Z","updatedAt":"2021-06-15T12:50:36.905Z","__v":0},{"_id":"60c8a27bda9b3346d469d72a","title":"对BFC的规范的理解？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（W3C&nbsp;CSS&nbsp;2.1&nbsp;规范中的一个概念,它决定了元素如何对其内容进行定位,以及与其他元素的关&nbsp;系和相互作用。）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">。在同一个&nbsp;BFC&nbsp;中的两个毗邻的块 级盒在垂直方向（和布局方向有关系）的&nbsp;margin&nbsp;会发生折叠。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。</p>","rank_id":201,"createdAt":"2021-06-15T12:52:11.750Z","updatedAt":"2021-06-15T12:52:11.750Z","__v":0},{"_id":"60c8a2d7da9b3346d469d72b","title":"对BFC规范(块级格式化上下文：block formatting context)的理解？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">定位方案是控制元素的布局，在&nbsp;CSS&nbsp;2.1&nbsp;中，有三种定位方案&mdash;&mdash;普通流&nbsp;(Normal&nbsp;Flow)&nbsp;、浮动&nbsp;(Floats)&nbsp;和绝对定位&nbsp;(Absolute&nbsp;Positioning)&nbsp;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">BFC&nbsp;正是属于普通流的，因此它对兄弟元素也不会造成什么影响。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">从样式上看，具有&nbsp;BFC&nbsp;的元素与普通的容器没有什么区别，但是从功能上，具有&nbsp;BFC&nbsp;的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且&nbsp;BFC&nbsp;具有普通容器没有的一些特性，例如可以</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">包含浮动元素，上文中的第二类清除浮动的方法（如&nbsp;overflow&nbsp;方法）就是触发了浮动元素的父元素的&nbsp;BFC&nbsp;，使到它可以包含浮动元素，从而防止出现高度塌陷的问题。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">简单来说，BFC&nbsp;就是一种属性，这种属性会影响着元素的定位以及与其兄弟元素之间的相互作用。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">触发BFC的条件；满足下面任一条件的元素，会触发为&nbsp;BFC&nbsp;：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">1、浮动元素，float&nbsp;除&nbsp;none&nbsp;以外的值</li>\n<li style=\"padding: 0px; margin: 0px;\">2、绝对定位元素，position（absolute，fixed）</li>\n<li style=\"padding: 0px; margin: 0px;\">3、display&nbsp;为以下其中之一的值&nbsp;inline-blocks，table-cells，table-captions</li>\n<li style=\"padding: 0px; margin: 0px;\">4、overflow&nbsp;除了&nbsp;visible&nbsp;以外的值（hidden，auto，scroll）</li>\n</ul>\n<h2 id=\"bfc的用处\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">BFC的用处</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>1、可以阻止边距折叠（margin&nbsp;collapsing）。</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">两个盒子有margin的时候，边距发生了折叠；对#one和#two添加float：left属性后，此时上下两个盒子的边距未发生折叠。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">float创建&nbsp;BFC&nbsp;的好处：可以将本元素的内外边距的折叠均变为正常。而其他的触发条件均不能控制自身外边距的折叠。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>2、可以包含内部元素的浮动</strong></p>\n<pre class=\"language-markup\"><code>&lt;div id=\"c1\"&gt;\n  &lt;div id=\"red\"&gt;&lt;/div&gt;\n  &lt;div id=\"orange\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=\"c2\"&gt;\n  &lt;div id=\"yellow\"&gt;&lt;/div&gt;\n  &lt;div id=\"green\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">本意是做一个两行两列的布局，但是由于#red,&nbsp;#orange,&nbsp;#yellow,&nbsp;#green这四个div同在一个布局环境中，即便通过#c1,&nbsp;#c2这两个div划分，浮动之后它们还会一个接着一个排列，并不会换行。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">现在对#c1和#c2同时添加float：left属性后，就可以了；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>3、可以阻止元素被浮动覆盖</strong></p>\n<pre class=\"language-markup\"><code>&lt;style type=\"text/css\"&gt;\n* { margin: 0; padding: 0;}\n#left {\nwidth: 100px;\nheight: 100px;\nbackground: red;\nfloat: left;\n        }\n#right {\nheight: 200px;\nwidth: 200px;\nbackground: yellow;\n        }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"left\"&gt;&lt;/div&gt;\n&lt;div id=\"right\"&gt;&lt;/div&gt;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">现在这个时候，就会出现left和right重合的现象；现对#right添加overflow：hidden属性后，运行结果就是浮动的了，紧挨着的效果（给#right添加float：left也可以实现效果）；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">由于IE6-7不支持BFC，而是使用私有属性hasLayout。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">表现上来看hasLayout和BFC相似，触发hasLayout条件与BFC相似，另外需要为元素设置IE特有的CSS属性zoom:1;&nbsp;zoom用于设置或检索元素的缩放比例，值为1即使用元素实际尺寸，使用zoom既可以触发hasLayout又不会对元素产生其他影响，相对来说更加方便。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">为了减少现代浏览器和IE(&lt;8)之间的问题，编程人员可以给框(box)一个布局来创建新的块级格式化上下文。在这种情况下，流式相同的，元素也是通过相同的方式清除浮动，clear也是清除相同的浮动，外边距也像预期的那样叠加。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">同时，编程人员在通过触发hasLayout的方式来给框添加样式时必须留意因为这种添加样式的方法可能使那个元素变成新的块级格式化上下文。</p>","rank_id":202,"createdAt":"2021-06-15T12:53:43.257Z","updatedAt":"2021-06-15T12:53:43.257Z","__v":0},{"_id":"60c8a2eeda9b3346d469d72c","title":"如何创建块级格式化上下⽂(block formatting context),BFC有什么⽤","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">创建规则：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">根元素</li>\n<li style=\"padding: 0px; margin: 0px;\">浮动元素（ float 不取值为 none ）</li>\n<li style=\"padding: 0px; margin: 0px;\">绝对定位元素（ position 取值为 absolute 或 fixed ）</li>\n<li style=\"padding: 0px; margin: 0px;\">display 取值为 inline-block 、 table-cell 、 table-caption 、 flex 、</li>\n<li style=\"padding: 0px; margin: 0px;\">inline-flex 之⼀的元素</li>\n<li style=\"padding: 0px; margin: 0px;\">overflow 不取值为 visible 的元素</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">作⽤：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">可以包含浮动元素</li>\n<li style=\"padding: 0px; margin: 0px;\">不被浮动元素覆盖</li>\n<li style=\"padding: 0px; margin: 0px;\">阻⽌⽗⼦元素的 margin 折叠</li>\n</ul>\n</li>\n</ul>","rank_id":203,"createdAt":"2021-06-15T12:54:06.892Z","updatedAt":"2021-06-15T12:54:06.892Z","__v":0},{"_id":"60c8a310da9b3346d469d72d","title":"为什么说position absolute 跟float 影响性能？","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<h2 id=\"核心\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">核心</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>会引起页面重绘？</strong></p>\n<h2 id=\"详细解释\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">详细解释</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>position: absolute会完全脱离文档流</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不再在z-index:0层保留占位符，其left、top、right、bottom 值是相对于自己最近的一个位置设置了position: relative 或 position: absolute的祖先元素的；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果祖先元素都没有设置position: relative 或 position: absolute，那么就相对于body元素。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>float也能改变文档流</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不同的是，float属性不会让元素&ldquo;上浮&rdquo;到另一个z-index层，它仍然让元素在z-index:0层排列，float不像position: relative 和 position: absolute那样，它不能通过left、top、right、bottom属性精确地控制元素的坐标，它只能通过float:left 和 float:right 来控制元素在同层里&ldquo;左浮&rdquo;和&ldquo;右浮&rdquo;。float会改变正常的文档流排列，影响到周围元素。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">另一个有趣的现象是position: absolute 和 float会隐式地改变display类型，不论之前什么类型的元素（display:none除外），只要设置了position: absolute 或 float中任意一个，都会让元素以display:inline-block的方式显示：可以设置长宽，默认宽度并不占满父元素。</p>\n<div class=\"google-auto-placed ap_container\" style=\"padding: 0px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff; width: 870px; height: auto; clear: both; text-align: center;\"><ins class=\"adsbygoogle adsbygoogle-noablate\" style=\"display: block; margin: auto; background-color: transparent; height: 0px;\" data-ad-format=\"auto\" data-ad-client=\"ca-pub-3504340093271389\" data-adsbygoogle-status=\"done\" data-ad-status=\"unfilled\"><ins id=\"aswift_3_expand\" style=\"display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent;\" tabindex=\"0\" title=\"Advertisement\" aria-label=\"Advertisement\"><ins id=\"aswift_3_anchor\" style=\"display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent; overflow: hidden; opacity: 0;\"><iframe id=\"aswift_3\" style=\"left: 0px; position: absolute; top: 0px; border-width: 0px; border-style: initial; width: 870px; height: 0px;\" src=\"https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3504340093271389&amp;output=html&amp;h=250&amp;adk=2310889761&amp;adf=3163410877&amp;pi=t.aa~a.3884791640~i.17~rp.4&amp;w=870&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1622810640&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9523024247&amp;psa=1&amp;ad_type=text_image&amp;format=870x250&amp;url=https%3A%2F%2Fwww.axihe.com%2Ffocus%2Fcss%2F3.html&amp;flash=0&amp;fwr=0&amp;pra=3&amp;rh=200&amp;rw=870&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;uach=WyJXaW5kb3dzIiwiMTAuMCIsIng4NiIsIiIsIjkxLjAuNDQ3Mi4xMDEiLFtdXQ..&amp;dt=1623761656962&amp;bpp=1&amp;bdt=292&amp;idt=1&amp;shv=r20210607&amp;cbv=%2Fr20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3Dc42b20e6ee6efa3d-221193c456c90083%3AT%3D1623293344%3ART%3D1623293344%3AS%3DALNI_MbzQJ6BWGNxs0oRE7-tp-4q8E74oA&amp;prev_fmts=0x0%2C890x280%2C878x280&amp;nras=2&amp;correlator=5325376242079&amp;frm=20&amp;pv=1&amp;ga_vid=1151264549.1623761657&amp;ga_sid=1623761657&amp;ga_hid=814466188&amp;ga_fc=0&amp;u_tz=480&amp;u_his=4&amp;u_java=0&amp;u_h=864&amp;u_w=1536&amp;u_ah=824&amp;u_aw=1536&amp;u_cd=24&amp;u_nplug=3&amp;u_nmime=4&amp;adx=325&amp;ady=1070&amp;biw=1519&amp;bih=722&amp;scr_x=0&amp;scr_y=0&amp;eid=31061407&amp;oid=3&amp;pvsid=3666953530386311&amp;pem=199&amp;ref=https%3A%2F%2Fwww.axihe.com%2Fmap%2Fcss-focus.html&amp;eae=0&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1536%2C0%2C1536%2C824%2C1536%2C722&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;ifi=4&amp;uci=a!4&amp;btvi=2&amp;fsb=1&amp;xpc=DQH3E4R9Q1&amp;p=https%3A//www.axihe.com&amp;dtd=16\" name=\"aswift_3\" width=\"870\" height=\"0\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" sandbox=\"allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation\" allowfullscreen=\"allowfullscreen\" data-google-container-id=\"a!4\" data-load-complete=\"true\" data-google-query-id=\"CLzZm8bXmfECFcRNYAodHgkPsQ\"></iframe></ins></ins></ins></div>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">就算我们显示地设置display:inline或者display:block，也仍然无效（float在IE6 下的双倍边距bug就是利用添加display:inline来解决的）。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">值得注意的是，position: relative却不改变display的类型。</p>\n<h2 id=\"引申\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">引申</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这一条规则可以解释：为什么在移动开发时尽量使用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Position：absolute</code>；而不是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">float</code>来浮动元素</p>","rank_id":204,"createdAt":"2021-06-15T12:54:40.060Z","updatedAt":"2021-06-15T12:54:40.060Z","__v":0},{"_id":"60c8a335da9b3346d469d72e","title":"让一个元素消失可以用什么方法？除了CSS还有其他方法吗？哪个效率高？","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">**display：none;**隐藏元素&nbsp;不占据空间;有株连性，回引起渲染与回流，影响性能。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">**visible：hidden;**隐藏元素，占据空间;伪株连性，无渲染与回流。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">**height:0;overflow:hidden;**溢出隐藏,就是宽、margin、padding都在;相对于&nbsp;display&nbsp;来说适用范围太窄，但是好处是能使用&nbsp;CSS3&nbsp;动画。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">**opacity:&nbsp;0;**严格来说这个并不是隐藏，透明之后它还占据着页面位置，所以在重排的时候还是会被计算消耗性能。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">**position: absolute; left: -9999px;**通过移出可见区域来达到隐藏，效果还可以，就是看着比较恶心。</p>","rank_id":205,"createdAt":"2021-06-15T12:55:17.541Z","updatedAt":"2021-06-15T12:55:17.541Z","__v":0},{"_id":"60c8a34fda9b3346d469d72f","title":"JS为什么会放在下面，CSS为什么放在上面","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">浏览器从上到下依次解析html文档。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">将&nbsp;css&nbsp;文件放到头部，&nbsp;css&nbsp;文件可以先加载。避免先加载&nbsp;body&nbsp;内容，导致页面一开始样式错乱，然后闪烁。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">将&nbsp;javascript&nbsp;文件放到底部是因为：若</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">将&nbsp;javascript&nbsp;文件放到&nbsp;head&nbsp;里面，就意味着必须等到所有的&nbsp;javascript&nbsp;代码都被&nbsp;下载、解析和执行完成&nbsp;之后才开始呈现页面内容。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这样就会造成呈现页面时出现明显的延迟，窗口一片空白。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">为避免这样的问题一般将全部 javascript 文件放到 body 元素中页面内容的后面。</p>","rank_id":206,"createdAt":"2021-06-15T12:55:43.093Z","updatedAt":"2021-06-15T12:55:43.093Z","__v":0},{"_id":"60c8a387da9b3346d469d730","title":"什么是FOUC（无样式内容闪烁）？如何来避免FOUC？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（一般指IE在加载网页的时候，出现短暂的CSS样式失效。）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果使用import方法对CSS进行导入,会导致某些页面在Windows&nbsp;下的Internet&nbsp;Explorer出现一些奇怪的现象:</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash&nbsp;of&nbsp;Unstyled&nbsp;Content),简称为FOUC.原因大致为：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">使用import方法导入样式表。</li>\n<li style=\"padding: 0px; margin: 0px;\">将样式表放在页面底部</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">有几个样式表，放在html结构的不同位置。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">其实原理很清楚：当样式表晚于&nbsp;结构性html&nbsp;加载，当加载到此样式表时，页面将停止之前的渲染。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">此样式表被下载和解析后，将重新渲染页面，也就出现了短暂&nbsp;的&nbsp;花屏现象。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>解决方法</strong>：避免使用@import方法导入CSS，且将样式表链接都放在head中即可避免此问题。</p>\n<h3 id=\"经典的总结\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">经典的总结</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>FOUC</strong>&nbsp;- Flash Of Unstyled Content 文档样式闪烁</p>\n<pre class=\"language-markup\"><code>&lt;style type=\"text/css\" media=\"all\"&gt;@import \"../fouc.css\";&lt;/style&gt;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">而引用CSS文件的@import就是造成这个问题的罪魁祸首。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">解决方法简单的出奇，只要在<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;head&gt;</code>之间加入一个<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;link&gt;</code>或者<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>元素就可以了。</p>","rank_id":207,"createdAt":"2021-06-15T12:56:39.925Z","updatedAt":"2021-06-15T12:56:39.925Z","__v":0},{"_id":"60c8a3a3da9b3346d469d731","title":"style标签写在body后与body前有什么区别？","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">页面加载自上而下&nbsp;当然是先加载样式；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果放在body后，会出现文档样式暂时失效的现象；</p>","rank_id":208,"createdAt":"2021-06-15T12:57:07.126Z","updatedAt":"2021-06-15T12:57:07.126Z","__v":0},{"_id":"60c8a3c1da9b3346d469d732","title":"CSS优化、提高性能的方法有哪些？","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">CSS&nbsp;优化主要是四个方面</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">1、加载性能</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">这个方面相关的&nbsp;best&nbsp;practice&nbsp;太多了，网上随便找一找就是一堆资料，比如不要用&nbsp;import&nbsp;啊，压缩啊等等，主要是从减少文件体积、减少阻塞加载、提高并发方面入手的，</li>\n<li style=\"padding: 0px; margin: 0px;\">任何&nbsp;hint&nbsp;都逃不出这几个大方向。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">2、选择器性能</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">selector&nbsp;的对整体性能的影响可以忽略不计了，selector&nbsp;的考察更多是规范化和可维护性、健壮性方面，很少有人在实际工作当中会把选择器性能作为重点关注对象的，</li>\n<li style=\"padding: 0px; margin: 0px;\">但也像&nbsp;GitHub&nbsp;这个分享里面说的一样&mdash;&mdash;知道总比不知道好。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">3、渲染性能</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">渲染性能是&nbsp;CSS&nbsp;优化最重要的关注对象。页面渲染&nbsp;junky&nbsp;过多？看看是不是大量使用了&nbsp;text-shadow？是不是开了字体抗锯齿？CSS&nbsp;动画怎么实现的？</li>\n<li style=\"padding: 0px; margin: 0px;\">合理利用&nbsp;GPU&nbsp;加速了吗？什么你用了&nbsp;Flexible&nbsp;Box&nbsp;Model？有没有测试换个&nbsp;layout&nbsp;策略对&nbsp;render&nbsp;performance&nbsp;的影响？</li>\n<li style=\"padding: 0px; margin: 0px;\">这个方面搜索一下&nbsp;CSS&nbsp;render&nbsp;performance&nbsp;或者&nbsp;CSS&nbsp;animation&nbsp;performance&nbsp;也会有一堆一堆的资料可供参考。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">4、可维护性、健壮性</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">命名合理吗？结构层次设计是否足够健壮？对样式进行抽象复用了吗？优雅的&nbsp;CSS&nbsp;不仅仅会影响后期的维护成本，也会对加载性能等方面产生影响。</li>\n<li style=\"padding: 0px; margin: 0px;\">这方面可以多找一些&nbsp;OOCSS（不是说就要用&nbsp;OOCSS，而是说多了解一下）等等不同&nbsp;CSS&nbsp;Strategy&nbsp;的信息，取长补短。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">修复解析错误</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">避免使用多类选择符</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">IE6以及更古老的浏览器对类似.foo.bar的多类选择符解析不正确，参考IE6下的多类选择符一文。&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">移除空的css规则</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">这个规则不包含任何属性，类似：.foo&nbsp;{&nbsp;}空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">正确使用display的属性</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。CSS&nbsp;Lint会检查一下几点：&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">display:inline后不应该再使用width、height、margin、padding以及float。&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">display:inline-block后不应该再使用float。&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">display:block后不应该再使用vertical-align。&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">display:table-*后不应该再使用margin或者float。&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">不滥用浮动</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">虽然浮动不可避免，但不可否认很多css&nbsp;bug是由于浮动而引起。CSS&nbsp;Lint一旦检测出样式文件中有超过10次的浮动便会提示警告。&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">不滥用web字体</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">对于中文网站来说Web&nbsp;Fonts可能很陌生，国外却很流行。web&nbsp;fonts通常体积庞大，而且一些浏览器在下载web&nbsp;fonts时会阻塞页面渲染损伤性能。&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">不声明过多的font-size</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">这是设计层面的问题，设计精良的页面不会有过多的font-size声明。&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">不在选择符中使用ID标识符</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">主要考虑到样式重用性以及与页面的耦合性。&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">不给h1~h6元素定义过多的样式</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">全站统一定义一遍heading元素即可，若需额外定制样式，可使用其他选择符作为代替。&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">不重复定义h1~h6元素</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">值为0时不需要任何单位</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">标准化各种浏览器前缀</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">通常将浏览器前缀置于前面，将标准样式属性置于最后，类似：&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">.foo&nbsp;{-moz-border-radius:&nbsp;5px;border-radius:&nbsp;5px;&nbsp;}&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">使用CSS渐变等高级特性，需指定所有浏览器的前缀</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">避免让选择符看起来像正则表达式</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">CSS3添加了一些类似~=等复杂属性，也不是所有浏览器都支持，需谨慎使用。&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">遵守盒模型规则</p>\n</li>\n</ul>","rank_id":209,"createdAt":"2021-06-15T12:57:37.317Z","updatedAt":"2021-06-15T12:57:37.317Z","__v":0},{"_id":"60c8a403da9b3346d469d733","title":"哪些地方会出现CSS阻塞？哪些地方会出现JS阻塞？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">js的阻塞特性：所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">为了提高用户体验，新一代浏览器都支持并行下载JS，但是JS下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">由于浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以就会阻塞其他的下载和呈现。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">嵌入JS会阻塞所有内容的呈现，而外部JS只会阻塞其后内容的显示，2种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">CSS怎么会阻塞加载了？CSS本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6下CSS都是阻塞加载）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当CSS后面跟着嵌入的JS的时候，该CSS就会出现阻塞后面资源下载的情况。而当把嵌入JS放到CSS前面，就不会出现阻塞的情况了。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">根本原因：因为浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">嵌入JS应该放在什么位置？</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">1、放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。</li>\n<li style=\"padding: 0px; margin: 0px;\">2、如果嵌入JS放在head中，请把嵌入JS放在CSS头部。</li>\n<li style=\"padding: 0px; margin: 0px;\">3、使用defer（只支持IE）</li>\n<li style=\"padding: 0px; margin: 0px;\">4、不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">setTimeout</code>来调用</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Javascript无阻塞加载具体方式</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">将脚本放在底部。<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;link&gt;</code>还是放在head中，用以保证在js加载前，能加载出正常显示的页面。<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>标签放在<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;/body&gt;</code>前。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">成组脚本：由于每个<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>标签下载时阻塞页面解析过程，所以限制页面的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>总数也可以改善性能。适用于内联脚本和外部脚本。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在window.onload事件发出后开始下载代码。</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">（1）defer属性：支持IE4和fierfox3.5更高版本浏览器</li>\n<li style=\"padding: 0px; margin: 0px;\">（2）动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。代码如下：\n<pre class=\"language-markup\"><code>&lt;script&gt;\nvar script=document.createElement(\"script\");\nscript.type=\"text/javascript\";\nscript.src=\"file.js\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(script);\n&lt;/script&gt;</code></pre>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">此技术的重点在于：无论在何处启动下载，文件额下载和运行都不会阻塞其他页面处理过程。即使在head里（除了用于下载文件的http链接）。</li>\n</ul>","rank_id":210,"createdAt":"2021-06-15T12:58:43.376Z","updatedAt":"2021-06-15T12:58:43.376Z","__v":0},{"_id":"60c8a41fda9b3346d469d734","title":"让页面里的字体变清晰，变细用CSS怎么做？","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">CSS3里面加入了一个<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">-webkit-font-smoothing</code>属性。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这个属性可以使页面上的字体抗锯齿,使用后字体看起来会更清晰舒服。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">加上之后就顿时感觉页面小清晰了。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">为了对比明显先将<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">-webkit-font-smoothing</code>设置为none，非常模糊。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">将<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">-webkit-font-smoothing:antialiased</code>，变得非常平滑，效果非常不错。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一共6个熟悉，但是看到效果的就是三个属性：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">none</code>&nbsp;|&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">subpixel-antialiased</code>&nbsp;|&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">antialiased</code></p>","rank_id":211,"createdAt":"2021-06-15T12:59:11.549Z","updatedAt":"2021-06-15T12:59:11.549Z","__v":0},{"_id":"60c8a444da9b3346d469d735","title":"position:fixed;在android下无效怎么处理？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-markup\"><code>&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\"&gt;\n</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">device-width指的是设备的物理宽度</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">initial-scale&nbsp;-&nbsp;初始的缩放比例</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">minimum-scale&nbsp;-&nbsp;允许用户缩放到的最小比例</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">maximum-scale&nbsp;-&nbsp;允许用户缩放到的最大比例</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">user-scalable - 用户是否可以手动缩放</p>","rank_id":212,"createdAt":"2021-06-15T12:59:48.711Z","updatedAt":"2021-06-15T12:59:48.711Z","__v":0},{"_id":"60c8a46bda9b3346d469d736","title":"请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到&nbsp;块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会&nbsp;自动伸高来闭合浮动元素（&ldquo;高度塌陷&rdquo;现象）。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为0（<strong>高度塌陷</strong>）。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在实际布局中，往往这并不是我们所希望的，所以需要清浮动</p>","rank_id":213,"createdAt":"2021-06-15T13:00:27.255Z","updatedAt":"2021-06-15T13:00:27.255Z","__v":0},{"_id":"60c8a48fda9b3346d469d737","title":"inline-block边距问题，有4px的边距；怎么解决？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">去掉标签之间的空格；或者用注释也可以</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">font-size</code>来解决、父级添加<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">font-size:0</code>；然后本身再把<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">font-size</code>恢复下即可；</p>","rank_id":214,"createdAt":"2021-06-15T13:01:03.900Z","updatedAt":"2021-06-15T13:01:03.900Z","__v":0},{"_id":"60c8a4a5da9b3346d469d738","title":"li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">li与li之间有看不见的空白。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">解决办法，可以设置浮动<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">float:left</code>;&nbsp;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不想浮动的话在ul用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">font-size:0</code>去掉空白；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">ul使用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">font-size:0</code>&nbsp;唯一的缺点就是要再次设置LI的font-size</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">总结： 行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</p>","rank_id":215,"createdAt":"2021-06-15T13:01:25.854Z","updatedAt":"2021-06-15T13:01:25.854Z","__v":0},{"_id":"60c8a4d7da9b3346d469d739","title":"CSS的浏览器兼容性（谷歌12px和不同浏览器的margin和padding,img下面有空白），原因，解决方法是什么？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">所谓的浏览器兼容性问题，是指因为不同的浏览器对同一段代码有不同的解析，造成页面显示效果不统一的情况。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在大多数情况下，我们的需求是，无论用户用什么浏览器来查看我们的网站或者登陆我们的系统，都应该是统一的显示效果。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">除了IE6和7的自身bug，其他浏览器BUG很少的。如果你理解了每一句CSS的意思，规范编写代码，一般很少会出bug。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">举个很简单的例子，很多人float:left后，担心IE6的双margin&nbsp;bug，不管三七二十一，加display:inline。其实这是错的。你要搞清楚IE6的双margin&nbsp;bug是如何产生的：</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">浮动方向有同方向的margin值，才会出现这个bug。所以如果只是单纯浮动，是不会产生这个bug的。</p>\n<h2 id=\"浏览器兼容问题一不同浏览器的标签默认的外补丁和内补丁不同\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">问题症状：随便写几个标签，不加样式控制的情况下，各自的margin&nbsp;和padding差异较大。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">解决方案：CSS里 &nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">*{margin:0;padding:0;}</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。</p>\n<h2 id=\"浏览器兼容问题二块属性标签float后又有横行的margin情况下在ie6显示margin比设置的大\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">问题症状:常见症状是IE6中后面的一块被顶到下一行</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">解决方案：在float的标签样式控制中加入&nbsp;display:inline;将其转化为行内属性</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div&nbsp;float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。</p>\n<h2 id=\"浏览器兼容问题三设置较小高度标签一般小于10px在ie6ie7遨游中高度超出自己设置高度\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">碰到频率：60%</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height&nbsp;小于你设置的高度。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">即使你的标签是空的，这个标签的高度还是会达到默认的行高。</p>\n<h2 id=\"浏览器兼容问题四行内属性标签设置displayblock后采用float布局又有横行的margin的情况ie6间距bug\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">问题症状：IE6里的间距比超过设置的间距</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">碰到几率：20%</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">解决方案：在display:block;后面加入display:inline;display:table;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。</p>\n<h2 id=\"浏览器兼容问题五图片默认有间距\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">浏览器兼容问题五：图片默认有间距</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">碰到几率：20%</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">解决方案：使用float属性为img布局</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用）</p>\n<h2 id=\"浏览器兼容问题六标签最低高度设置min-height不兼容\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">浏览器兼容问题六：标签最低高度设置min-height不兼容</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">碰到几率：5%</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px;&nbsp;height:auto&nbsp;!important;&nbsp;height:200px;&nbsp;overflow:visible;}</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。</p>\n<h2 id=\"浏览器兼容问题七透明度的兼容css设置\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">浏览器兼容问题七：透明度的兼容CSS设置</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">做兼容页面的方法是：每写一小段代码（布局中的一行或者一块）我们都要在不同的浏览器中看是否兼容，当然熟练到一定的程度就没这么麻烦了。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">建议经常会碰到兼容性问题的新手使用。很多兼容性问题都是因为浏览器对标签的默认属性解析不同造成的，只要我们稍加设置都能轻松地解决这些兼容问题。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果我们熟悉标签的默认属性的话，就能很好的理解为什么会出现兼容问题以及怎么去解决这些兼容问题。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">/*&nbsp;CSS&nbsp;hack*/</code>&nbsp;我很少使用hacker的，可能是个人习惯吧，我不喜欢写的代码IE不兼容，然后用hack来解决。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不过hacker还是非常好用的。使用hacker我可以把浏览器分为3类：IE6&nbsp;；IE7和遨游；其他（IE8&nbsp;chrome&nbsp;ff&nbsp;safari&nbsp;opera等）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">IE6认识的hacker&nbsp;是下划线<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">_</code>&nbsp;和星号&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">*</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">IE7&nbsp;遨游认识的hacker是星号&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">*</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">比如这样一个CSS设置：</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">height:300px;*height:200px;_height:100px;&nbsp;IE6浏览器在读到height:300px的时候会认为高时300px；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">继续往下读，他也认识<em>heihgt，&nbsp;所以当IE6读到</em>height:200px的时候会覆盖掉前一条的相冲突设置，认为高度是200px。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">继续往下读，IE6还认识_height,所以他又会覆盖掉200px高的设置，把高度设置为100px；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">IE7和遨游也是一样的从高度300px的设置往下读。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当它们读到*height200px的时候就停下了，因为它们不认识_height。所以它们会把高度解析为200px，剩下的浏览器只认识第一个height:300px;所以他们会把高度解析为300px。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为优先级相同且想冲突的属性设置后一个会覆盖掉前一个，所以书写的次序是很重要的。</p>","rank_id":216,"createdAt":"2021-06-15T13:02:15.854Z","updatedAt":"2021-06-15T13:02:15.854Z","__v":0},{"_id":"60c8a4edda9b3346d469d73a","title":"常用的CSS hack有哪些？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">以下几种情况：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">1.大部分特殊字符IE浏览器支持，其他主流浏览器firefox，chrome，opera，safari不支持&nbsp;(opera可识别除外)。</li>\n<li style=\"padding: 0px; margin: 0px;\">2.\\9&nbsp;&nbsp;&nbsp;&nbsp;：所有IE浏览器都支持</li>\n<li style=\"padding: 0px; margin: 0px;\">3._和-&nbsp;&nbsp;：仅IE6支持</li>\n<li style=\"padding: 0px; margin: 0px;\">4.*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;：IE6、E7支持</li>\n<li style=\"padding: 0px; margin: 0px;\">5.\\0&nbsp;&nbsp;&nbsp;&nbsp;：IE8、IE9支持，opera部分支持</li>\n<li style=\"padding: 0px; margin: 0px;\">6.\\9\\0&nbsp;&nbsp;：IE8部分支持、IE9支持</li>\n<li style=\"padding: 0px; margin: 0px;\">7.\\0\\9&nbsp;&nbsp;：IE8、IE9支持</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">IE的if条件</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Hack</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;!&ndash;[if&nbsp;IE]&gt;&nbsp;Only&nbsp;IE&nbsp;&lt;![endif]&ndash;&gt;</code>&nbsp;所有的IE可识别&nbsp;</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;!&ndash;[if&nbsp;IE&nbsp;5.0]&gt;&nbsp;Only&nbsp;IE&nbsp;5.0&nbsp;&lt;![endif]&ndash;&gt;</code>&nbsp;只有IE5.0可以识别&nbsp;</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;!&ndash;[if&nbsp;lt&nbsp;IE&nbsp;6]&gt;&nbsp;Only&nbsp;IE&nbsp;6-&nbsp;&lt;![endif]&ndash;&gt;</code>&nbsp;仅IE6可识别&nbsp;</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;!&ndash;[if&nbsp;lte&nbsp;IE&nbsp;7]&gt;&nbsp;Only&nbsp;IE&nbsp;7/-&nbsp;&lt;![endif]&ndash;&gt;</code>&nbsp;仅IE7可识别&nbsp;</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;!&ndash;[if&nbsp;gte&nbsp;IE&nbsp;6]&gt;&nbsp;Only&nbsp;IE&nbsp;6/+&nbsp;&lt;![endif]&ndash;&gt;</code>&nbsp;IE6以及IE6以下的IE5.x都可识别&nbsp;</li>\n</ul>","rank_id":217,"createdAt":"2021-06-15T13:02:37.852Z","updatedAt":"2021-06-15T13:02:37.852Z","__v":0},{"_id":"60c8a581da9b3346d469d73b","title":"怎么让Chrome支持小于12px 的文字？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-css\"><code>html, body {-webkit-text-size-adjust: none;}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">新版的chrome已经取消了；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">CSS3有个新的属性transform，而我们用到的就是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">transform:scale()</code></p>\n<pre class=\"language-css\"><code>p{font-size:10px;-webkit-transform:scale(0.8);}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\"></code>但是，如果，这个属性会把整个p的属性都缩放。如果我有背景呢？我有边框呢？都会被缩小！</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">所以我们修改结构为</p>\n<pre class=\"language-markup\"><code>&lt;p&gt;&lt;span&gt;我是一个小于12PX的字体&lt;/span&gt;&lt;/p&gt;</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">代码如下</span></p>\n<pre class=\"language-markup\"><code>body,p{ margin:0; padding:0}\np{font-size:10px;}\nspan{-webkit-transform:scale(0.8); display:inline-block}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">定义&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">display:inline-block</code>而不是&nbsp;display:block；会发现。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">会存在一定的边距。貌似margin或者padding的间距。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这就是缩放存在问题。原来的位置还占有12px字体的大小。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">所以，要对应修改margin了。定义为负的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">还有一个网上别人分享的方法；</p>\n<pre class=\"language-css\"><code>html {font-size: 625%;}\nbody {font-size: 0.16rem;}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">&nbsp;</p>","rank_id":218,"createdAt":"2021-06-15T13:05:05.776Z","updatedAt":"2021-06-15T13:05:05.776Z","__v":0},{"_id":"60c8a58bda9b3346d469d73c","title":"overflow scroll时不能平滑滚动的问题怎么处理？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当设置div宽度，里面的内容不设置宽度时候；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">使用overflow: scroll是上下滚动，左右不滚动；设置内部的元素p超过父级的宽度；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">然后设置overflow: scroll是上下和左右都有滚动条；分别设置就可以了</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">overflow-x:scroll;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">overflow-y:hidden;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">或者设置overflow后，在单独设置；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">overflow:auto;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">overflow-y:hidden;</p>","rank_id":219,"createdAt":"2021-06-15T13:05:15.295Z","updatedAt":"2021-06-15T13:05:15.295Z","__v":0},{"_id":"60c8a5b2da9b3346d469d73d","title":"CSS合并⽅法","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">避免使⽤ @import 引⼊多个 css ⽂件，可以使⽤ CSS ⼯具将 CSS 合并为⼀个 CSS ⽂ 件，例如使⽤ Sass\\Compass 等</span></p>","rank_id":220,"createdAt":"2021-06-15T13:05:54.992Z","updatedAt":"2021-06-15T13:05:54.992Z","__v":0},{"_id":"60c8a5c9da9b3346d469d73e","title":"列出你所知道可以改变⻚⾯布局的属性","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">position 、 display 、 float 、 width 、 height 、 margin 、 padding 、 top 、 left 、 right 、</span></p>","rank_id":221,"createdAt":"2021-06-15T13:06:17.349Z","updatedAt":"2021-06-15T13:06:17.349Z","__v":0},{"_id":"60c8a5e1da9b3346d469d73f","title":"CSS在性能优化⽅⾯的实践","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">css 压缩与合并、 Gzip 压缩</li>\n<li style=\"padding: 0px; margin: 0px;\">css ⽂件放在 head ⾥、不要⽤ @import</li>\n<li style=\"padding: 0px; margin: 0px;\">尽量⽤缩写、避免⽤滤镜、合理使⽤选择器</li>\n</ul>","rank_id":222,"createdAt":"2021-06-15T13:06:41.678Z","updatedAt":"2021-06-15T13:06:41.678Z","__v":0},{"_id":"60c8a5fada9b3346d469d740","title":"CSS3动画（简单动画的实现，如旋转等）","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">依靠 CSS3 中提出的三个属性： transition 、 transform 、 animation</li>\n<li style=\"padding: 0px; margin: 0px;\">transition ：定义了元素在变化过程中是怎么样的，包含 transition-property 、 transition-duration 、 transition-timing-function 、 transition-delay 。</li>\n<li style=\"padding: 0px; margin: 0px;\">transform ：定义元素的变化结果，包含 rotate 、 scale 、 skew 、 translate 。</li>\n<li style=\"padding: 0px; margin: 0px;\">animation ：动画定义了动作的每⼀帧（ @keyframes ）有什么效果，包括 animation- name ， animation-duration 、 animation-timing-function 、 animation- delay 、 animation-iteration-count 、 animation-direction</li>\n</ul>","rank_id":223,"createdAt":"2021-06-15T13:07:06.901Z","updatedAt":"2021-06-15T13:07:06.901Z","__v":0},{"_id":"60c8a60ada9b3346d469d741","title":"stylus/sass/less区别","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">均具有&ldquo;变量&rdquo;、&ldquo;混合&rdquo;、&ldquo;嵌套&rdquo;、&ldquo;继承&rdquo;、&ldquo;颜⾊混合&rdquo;五⼤基本特性</li>\n<li style=\"padding: 0px; margin: 0px;\">Scss 和 LESS 语法较为严谨， LESS 要求⼀定要使⽤⼤括号&ldquo;{}&rdquo;， Scss 和 Stylus 可以通过缩进表示层次与嵌套关系</li>\n<li style=\"padding: 0px; margin: 0px;\">Scss ⽆全局变量的概念， LESS 和 Stylus 有类似于其它语⾔的作⽤域概念</li>\n<li style=\"padding: 0px; margin: 0px;\">Sass 是基于 Ruby 语⾔的，⽽ LESS 和 Stylus 可以基于 NodeJS NPM 下载相应库后进⾏编译</li>\n</ul>","rank_id":224,"createdAt":"2021-06-15T13:07:22.963Z","updatedAt":"2021-06-15T13:07:22.963Z","__v":0},{"_id":"60c8a61dda9b3346d469d742","title":"postcss的作⽤","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">可以直观的理解为：它就是⼀个平台。为什么说它是⼀个平台呢？因为我们直接⽤它，感觉不能⼲什么事情，但是如果让⼀些插件在它上⾯跑，那么将会很强⼤</li>\n<li style=\"padding: 0px; margin: 0px;\">PostCSS 提供了⼀个解析器，它能够将 CSS 解析成抽象语法树</li>\n<li style=\"padding: 0px; margin: 0px;\">通过在 PostCSS 这个平台上，我们能够开发⼀些插件，来处理我们的 CSS ，⽐如热⻔的： autoprefixer</li>\n<li style=\"padding: 0px; margin: 0px;\">postcss 可以对sass处理过后的 css 再处理 最常⻅的就是 autoprefixer</li>\n</ul>","rank_id":225,"createdAt":"2021-06-15T13:07:41.798Z","updatedAt":"2021-06-15T13:07:41.798Z","__v":0},{"_id":"60c8a62eda9b3346d469d743","title":"伪类和伪元素的区别","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">伪类表状态</li>\n<li style=\"padding: 0px; margin: 0px;\">伪元素是真的有元素</li>\n<li style=\"padding: 0px; margin: 0px;\">前者单冒号，后者双冒号</li>\n</ul>","rank_id":226,"createdAt":"2021-06-15T13:07:58.868Z","updatedAt":"2021-06-15T13:07:58.868Z","__v":0},{"_id":"60c8a66bda9b3346d469d744","title":"请⽤CSS写⼀个简单的幻灯⽚效果⻚⾯","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">知道是要⽤ CSS3 。使⽤ animation 动画实现⼀个简单的幻灯⽚效果</span></p>\n<pre class=\"language-css\"><code>/**css**/\n.ani{\nwidth:480px;\nheight:320px;\nmargin:50px auto;\noverflow: hidden;\nbox-shadow:0 0 5px rgba(0,0,0,1);\nbackground-size: cover;\nbackground-position: center;\n-webkit-animation-name: \"loops\";\n-webkit-animation-duration: 20s;\n-webkit-animation-iteration-count: infinite;\n}</code></pre>\n<pre class=\"language-css\"><code>@-webkit-keyframes \"loops\" {\n    0% {\n        background:url(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6\n    }\n    25% {\n        background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1\n    }\n    50% {\n        background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937da\n    }\n    75% {\n        background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d375\n    }\n    100% {\n        background:url(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb23\n    }\n}</code></pre>","rank_id":227,"createdAt":"2021-06-15T13:08:59.979Z","updatedAt":"2021-06-15T13:08:59.979Z","__v":0},{"_id":"60c8a682da9b3346d469d745","title":"什么是外边距重叠？重叠的结果是什么？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">外边距重叠就是margin-collapse</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">在CSS当中，相邻的两个盒⼦（可能是兄弟关系也可能是祖先关系）的外边距可以结合成 ⼀个单独的外边距。这种合并外边距的⽅式被称为折叠，并且因⽽所结合成的外边距称为 折叠外边距。</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>折叠结果遵循下列计算规则</strong>：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">两个相邻的外边距都是正数时，折叠结果是它们两者之间较⼤的值。</li>\n<li style=\"padding: 0px; margin: 0px;\">两个相邻的外边距都是负数时，折叠结果是两者绝对值的较⼤值。</li>\n<li style=\"padding: 0px; margin: 0px;\">两个外边距⼀正⼀负时，折叠结果是两者的相加的和。</li>\n</ul>","rank_id":228,"createdAt":"2021-06-15T13:09:22.540Z","updatedAt":"2021-06-15T13:09:22.540Z","__v":0},{"_id":"60c8a697da9b3346d469d746","title":"rgba()和opacity的透明效果有什么不同？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">rgba() 和 opacity 都能实现透明效果，但最⼤的不同是 opacity 作⽤于元素，以及元素内的所有内容的透明度，</li>\n<li style=\"padding: 0px; margin: 0px;\">⽽ rgba() 只作⽤于元素的颜⾊或其背景⾊。（设置 rgba 透明的元素的⼦元素不会继承透明效果！</li>\n</ul>","rank_id":229,"createdAt":"2021-06-15T13:09:43.283Z","updatedAt":"2021-06-15T13:09:43.283Z","__v":0},{"_id":"60c8a6b1da9b3346d469d747","title":"css中可以让⽂字在垂直和⽔平⽅向上重叠的两个属性是什么？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">垂直⽅向： line-height</li>\n<li style=\"padding: 0px; margin: 0px;\">⽔平⽅向： letter-spacing</li>\n</ul>","rank_id":230,"createdAt":"2021-06-15T13:10:09.676Z","updatedAt":"2021-06-15T13:10:09.676Z","__v":0},{"_id":"60c8a6c7da9b3346d469d748","title":"CSS BFC、IFC、GFC、FF","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">BFC ：块级格式化上下⽂，容器⾥⾯的⼦元素不会在布局上影响到外⾯的元素，反之也是如此(按照这个理念来想，只要脱离⽂档流，肯定就能产⽣BFC )。产⽣ BFC ⽅式如下</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">float 的值不为 none 。</li>\n<li style=\"padding: 0px; margin: 0px;\">overflow 的值不为 visible 。</li>\n<li style=\"padding: 0px; margin: 0px;\">position 的值不为 relative 和 static 。</li>\n<li style=\"padding: 0px; margin: 0px;\">display 的值为 table-cell , table-caption , inline-block 中的任何⼀个</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">⽤处？常⻅的多栏布局，结合块级别元素浮动，⾥⾯的元素则是在⼀个相对隔 离的环境⾥运⾏</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">IFC ：内联格式化上下⽂， IFC 的 line box （线框）⾼度由其包含⾏ 内元素中最⾼的实际⾼度计算⽽来（不受到竖直⽅向的 padding/margin 影 响)。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">IFC 中的 line box ⼀般左右都贴紧整个 IFC ，但是会因为 float 元素 ⽽扰乱。 float 元素会位于 IFC 与 line box 之间，使得 line box 宽 度缩短。 同个 ifc 下的多个 line box ⾼度会不同。 IFC 中时不可能有 块级元素的，当插⼊块级元素时（如 p 中插⼊ div ）会产⽣两个匿名块与 div 分隔开，即产⽣两个 IFC ，每个 IFC 对外表现为块级元素，与 div 垂直排列</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">⽤处？</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">⽔平居中：当⼀个块要在环境中⽔平居中时，设置其为 inline-block 则会在外层产⽣ IFC ，通过 text-align 则可以使其⽔平居中。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">垂直居中：创建⼀个 IFC ，⽤其中⼀个元素撑开⽗元素的⾼度，然后设置其 vertical- align : middle ，其他⾏内元素则可以在此⽗元素下垂直居中</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">GFC：⽹格布局格式化上下⽂（ display: grid ）</li>\n<li style=\"padding: 0px; margin: 0px;\">FFC：⾃适应格式化上下⽂（ display: flex ）</li>\n</ul>\n</li>\n</ul>","rank_id":231,"createdAt":"2021-06-15T13:10:31.619Z","updatedAt":"2021-06-15T13:10:31.619Z","__v":0},{"_id":"60c8a789da9b3346d469d749","title":"用JavaScript写一个动态的，格式为..年..月..日..时..分..秒的方法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function clock () {\n  // 实例化当前时间\n  let time = new Date();\n  //年月日周\n  let y = time.getFullYear(),\n    m = time.getMonth() + 1,\n    day = time.getDate(),\n    week = toWeek(time.getDay());\n  //小时，分钟，秒\n  let h = time.getHours(),\n    miu = time.getMinutes(),\n    s = time.getSeconds(),\n    ms = time.getMilliseconds();\n  var resultTimne = `今天是 ${y}年${m}月${day}日 ${week} ${h}时${miu}分${s}秒${ms}毫秒`;\n  return resultTimne;\n}\nfunction toWeek (week) {\n  let resuleWeek = '';\n  switch (week) {\n    case 0:\n      resuleWeek = '日';\n    case 1:\n      resuleWeek = '一';\n    case 2:\n      resuleWeek = '二';\n    case 3:\n      resuleWeek = '三';\n    case 4:\n      resuleWeek = '四';\n    case 5:\n      resuleWeek = '五';\n    case 6:\n      resuleWeek = '六';\n  }\n  return '星期' + resuleWeek;\n}\nconsole.log(clock());</code></pre>","rank_id":232,"createdAt":"2021-06-15T13:13:45.322Z","updatedAt":"2021-06-15T13:13:45.322Z","__v":0},{"_id":"60c8a7a6da9b3346d469d74a","title":"JavaScript 如何让alert弹出框中的信息换行","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">利用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">\\n</code>&nbsp;来实现换行；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">例如：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">alert('朱朱朱\\n安安安\\n邦邦邦')</code></p>","rank_id":233,"createdAt":"2021-06-15T13:14:14.148Z","updatedAt":"2021-06-15T13:14:14.148Z","__v":0},{"_id":"60c8ab7fda9b3346d469d74b","title":"JavaScript 选项卡的标签栏或者一排单选按钮，如何知道选择是第几个？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"核心\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">核心</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这道题是考异步的，以及index的值；</p>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">代码</h2>\n<pre class=\"language-javascript\"><code>var oInputs = document.getElementsByTagName('input');\nfor (let index = 0; index &lt; oInputs.length; index++) {\n  (function (index) {\n    oInputs[index].onclick = function () {\n      alert(index + 1)\n    }\n  })(index)\n}</code></pre>\n<h2 id=\"代码\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":234,"createdAt":"2021-06-15T13:30:39.061Z","updatedAt":"2021-06-15T13:30:39.061Z","__v":0},{"_id":"60c8abdeda9b3346d469d74c","title":"利用JavaScript打印出FIbonacci数（不使用全局变量）","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"知识点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">知识点</h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">Fibonacci数：两相邻数的和等于下一项的值。</li>\n<li style=\"padding: 0px; margin: 0px;\">三元运算符表达式为&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">result = value1 ? Value2 : value3</code>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">当 value1为<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">true</code>时&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">result=Value2</code></li>\n<li style=\"padding: 0px; margin: 0px;\">为<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">false</code>时&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">result=Value3</code></li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">本题主要考对数组索引的控制\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; letter-spacing: 2px;\">代码</h2>\n<pre class=\"language-javascript\"><code>function printFibonacci (n) {\n  var arr = n &gt; 0 ? [1] : [];\n  if (n &gt; 1) {\n    for (let index = 1; index &lt; n; index++) {\n      arr.push(arr[index - 1] + (index &gt;= 2 ? arr[index - 2] : 0))\n    }\n    return arr;\n  }\n}\nconsole.log(printFibonacci(20));</code></pre>\n<h2 id=\"代码\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; letter-spacing: 2px;\"></h2>\n</li>\n</ul>","rank_id":235,"createdAt":"2021-06-15T13:32:14.289Z","updatedAt":"2021-06-15T13:32:14.289Z","__v":0},{"_id":"60c8ac13da9b3346d469d74d","title":"JavaScript 实现如下语法的功能 var a=(5).plus(3).minus(6);","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这一题直接操作数字，而<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">plus</code>这些都不是数字类型有的方法，需要像数值的原型上写方法；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">就是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Number.prototype</code>;</p>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">代码</h2>\n<pre class=\"language-javascript\"><code>Number.prototype.plus = function (n) {\n  return this + n;\n}\nNumber.prototype.minus = function (n) {\n  return this - n;\n}\nvar a = (5).plus(3).minus(6);\nconsole.log(a);</code></pre>\n<h2 id=\"代码\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":236,"createdAt":"2021-06-15T13:33:07.439Z","updatedAt":"2021-06-15T13:33:07.439Z","__v":0},{"_id":"60c8ac8fda9b3346d469d74e","title":"JavaScript 实现输出document对象中所有成员的名称和类型","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"核心\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">核心</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">document</code>是一个对象，需要输出所有可枚举的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">key</code>和<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">vulue</code>;</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">可以使用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">for in</code>;</span></p>\n<h3 id=\"扩展了解\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">扩展了解</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">for in</code>&nbsp;和&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Object.keys</code>在输出这些对象key的区别</span></p>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">for in </span></h2>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">代码</span></h2>\n<pre class=\"language-javascript\"><code>&lt;script language=\"javascript\"&gt;\nfor(key in document){\n    document.write(key +'  :  '+ document[key]+'&lt;br /&gt;');\n}\n&lt;/script&gt;</code></pre>\n<h2 id=\"for-in-代码\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":237,"createdAt":"2021-06-15T13:35:11.883Z","updatedAt":"2021-06-15T13:35:11.883Z","__v":0},{"_id":"60c8acc8da9b3346d469d74f","title":"JavaScript 如果利用JS生成一个table?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"知识点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">知识点</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">通过<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">document.createElement</code>创建元素。</p>\n<h2 id=\"代码\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">代码</h2>\n<pre class=\"language-javascript\"><code>&lt;script&gt;\n  let row;\n  let cell;\n  for (let index = 0; index &lt; 10; index++) {\n    row = document.createElement('tr');\n    document.getElementById('table11').appendChild(row);\n    for (let j = 0; j &lt; 5; j++) {\n      cell = document.createElement('td');\n      cell.innerText = '内容';\n      row.appendChild(cell);\n    }\n  }\n&lt;/script&gt;</code></pre>","rank_id":238,"createdAt":"2021-06-15T13:36:08.193Z","updatedAt":"2021-06-15T13:36:08.193Z","__v":0},{"_id":"60c8acffda9b3346d469d750","title":"JavaScript 实现预加载一张图片，加载完成后显示在网页中并设定其高度为50px;宽度为50px;","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"知识点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">知识点</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">预加载事件为<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">onload</code>,加载成功后为图片设置样式。</span></p>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">代码</span></h2>\n<pre class=\"language-javascript\"><code>&lt;img id ='imgObj' src='https://a.axihe.com/assets/img/anbang-weixin.jpg'/&gt;\n&lt;script&gt;\n  var imgObj = document.getElementById('imgObj');\n  function addImg (tempSrc) {\n    var imgObj1 = new Image();\n    imgObj1.src = tempSrc;\n    imgObj1.onload = function () {\n      imgObj.src = this.src;\n      imgObj.height = 50;\n      imgObj.width = 50;\n    }\n  }\n  addImg('https://a.axihe.com/assets/img/bilibili.jpg');//这里是真正的显示文件\n&lt;/script&gt;</code></pre>\n<h2 id=\"代码\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":239,"createdAt":"2021-06-15T13:37:03.580Z","updatedAt":"2021-06-15T13:37:03.580Z","__v":0},{"_id":"60c8ad4bda9b3346d469d751","title":"JavaScript 假设有一个4行td的table,将table里面的td顺序颠倒","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"知识点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">知识点</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">将非数组集合转换为数组</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">appendChild</code>为父元素添加子元素</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">table含有多个tBody,获取第一个tBody为<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">tBodies[0]</code>.</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">通过call借用数组的slice方法</p>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">方法一：将元素集合迭代到数组中</h2>\n<pre class=\"language-javascript\"><code>let oTab = document.getElementById(\"tab1\");\nlet oBody = oTab.tBodies[0];\nlet oTrs = oBody.rows;\nlet a = [];\nfor (let index = 0; index &lt; oTrs.length; index++) {\n  const element = array[index];\n  a.push(element);\n}\na.reverse();\nfor (let i = 0; i &lt; a.length; i++) {\n  const element = a[i];\n  oBody.appendChild(element);\n}</code></pre>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">方法二：通过call借用数组的slice方法</h2>\n<pre class=\"language-javascript\"><code>let oTab = document.getElementById(\"tab1\");\nlet oBody = oTab.tBodies[0];\nlet oTrs = oBody.rows;\nlet aRows = Array.prototype.slice.call(oRow, 0);\naRows.reverse();\nfor (let i = 0; i &lt; aRows.length; i++) {\n  const element = aRows[i];\n  oBody.appendChild(element);\n}</code></pre>\n<h2 id=\"方法二通过call借用数组的slice方法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>\n<h2 id=\"方法一将元素集合迭代到数组中\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":240,"createdAt":"2021-06-15T13:38:19.662Z","updatedAt":"2021-06-15T13:38:19.662Z","__v":0},{"_id":"60c8ad88da9b3346d469d752","title":"JavaScript 模拟一个HashTable类；包含add，remove，contains，length方法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">JavaScript 模拟一个<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">HashTable</code>类；包含add，remove，contains，length方法</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一个类上注册四个方法</p>\n<h2 id=\"知识点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">知识点</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">定义类需要把函数名第一个字母大写（<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">HashTable</code>）。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;关键字指向调用者。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">为自定义类的原型添加方法。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">push</code>为数组追加项。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">splice</code>&nbsp;是数组的方法,用来增、删、改数据。</p>\n<pre class=\"language-javascript\"><code>代码\nfunction HashTale () {\n  this.value = new Array();\n}\nHashTale.prototype.add = function (value) {\n  this.value.push(value);\n}\nHashTale.prototype.remove = function (index) {\n  this.value.splice(index, 1);\n}\nHashTale.prototype.contains = function (value) {\n  let aValue = this.value;\n  for (let index = 0; index &lt; aValue.length; index++) {\n    const element = aValue[index];\n    if (value === element) {\n      return true;\n    }\n  }\n  return false;\n}\nHashTale.prototype.length = function (index) {\n  return this.value.length;\n}</code></pre>","rank_id":241,"createdAt":"2021-06-15T13:39:20.117Z","updatedAt":"2021-06-15T13:39:20.117Z","__v":0},{"_id":"60c8ade3da9b3346d469d753","title":"对JavaScript中函数绑定的理解；函数绑定可以使用哪两个函数？函数绑定一般使用在什么情况下？这两个函数的区别是什么？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当对象借用方法时可以用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">call</code>或<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">apply</code>,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">apply最多有2个参数,第一个参数是借用对象,第二个参数是数组类型。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">call第一个参数为借用对象,后面的参数个数不限,都作为参数传递给被借用方法。</p>\n<blockquote style=\"padding: 0px 0px 8px; margin: 10px 0px; color: #828201; border-width: 1px 1px 1px 5px; border-style: solid; border-color: #e2e2e2 #e2e2e2 #e2e2e2 #fff000; border-image: initial; background-color: #ffffc0; overflow: hidden; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">注意：内置对象arguments不是数组类型,是类数组,类数组转换为数组常用call和apply。</p>\n</blockquote>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">实例如下问题：获取第0个到第2个参数值：</p>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">call方法</h2>\n<pre class=\"language-javascript\"><code>call方法\nfunction callFn () {\n  let aArg = Array.prototype.slice.call(arguments, 0, 3);\n  return aArg;\n}\nconsole.log(callFn('1', '2', '3', '4', '5', '6'))</code></pre>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">apply方法</h2>\n<pre class=\"language-javascript\"><code>function applyFn () {\n  let aArg = Array.prototype.slice.apply(arguments, [0, 3]);\n  return aArg;\n}\nconsole.log(applyFn('1', '2', '3', '4', '5', '6'))</code></pre>\n<h2 id=\"apply方法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>\n<h2 id=\"call方法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":242,"createdAt":"2021-06-15T13:40:51.000Z","updatedAt":"2021-06-15T13:40:51.000Z","__v":0},{"_id":"60c8ae27da9b3346d469d754","title":"JavaScript var a=b=c=d=5是什么意思?如果接下来再写一句,d=9,a,b,c的值会变化吗?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"知识点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">知识点</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">初始化给a、b、c、d赋值都为5。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">改变d后a、b、c值不会改变,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为a、b、c、d都是值类型的变量,各自的值存在于自己的栈当中,当d变化了其他栈中的值不改变。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>栈</strong>: 存储值类型数据（栈也叫一级缓存）。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>堆</strong>: 存储引用类型数据,在栈中存指向该堆内存地址的句柄（堆也叫二级缓存）。</p>","rank_id":243,"createdAt":"2021-06-15T13:41:59.890Z","updatedAt":"2021-06-15T13:41:59.890Z","__v":0},{"_id":"60c8ae4fda9b3346d469d755","title":"var a=b=c=d=[1,2,3,4,5]是什么意思?如果接下来写一句d[5]=9;a,b,c,的值会发生变化吗","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">发生变化,a、b、c、d值都改为<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">[1,2,3,4,5,9]</code>,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为a、b、c、d是引用类型,引用类型的数据存在于堆当中,栈中存的是指向堆的地址,初始化时 a、b、c、d在各自的栈中指向的堆是同一个,该堆保存着<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">[1,2,3,4,5]</code>,当改变了堆中的值,其他对象跟着改变。</p>","rank_id":244,"createdAt":"2021-06-15T13:42:39.308Z","updatedAt":"2021-06-15T13:42:39.308Z","__v":0},{"_id":"60c8ae6fda9b3346d469d756","title":"JavaScript var n=(1,2,3,4,5),n的值是多少?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">n的值是5,n中保存最后一次赋值。</span></p>","rank_id":245,"createdAt":"2021-06-15T13:43:11.978Z","updatedAt":"2021-06-15T13:43:11.978Z","__v":0},{"_id":"60c8af9dda9b3346d469d758","title":"JavaScript 如何知道一个变量的数据类型?如何判断数据类型?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"基本数据类型用typeof类获取\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">基本数据类型用typeof类获取</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如：</p>\n<pre class=\"language-javascript\"><code>var num=9;\nconsole.log(typeof num);</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">结果为number类型</p>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">复杂数据类型object（是否是Array、Date类的实例）</h2>\n<pre class=\"language-javascript\"><code>var aNum=[1,3];\nconsole.log(aNum instanceof Array);</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">结果为true</p>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">借用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">toString</code>方法;</h2>\n<pre class=\"language-javascript\"><code>Object.prototype.toString.call(ObjectTest) === '[object Function]'</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">封装如下</span></p>\n<pre class=\"language-javascript\"><code>let _typeof = function (data) {\n    let value = /\\[object (\\w+)\\]/.exec(\n        Object.prototype.toString.call(data)\n    );\n    return value ? value[1].toLowerCase() : '';\n}\n</code></pre>\n<h2 id=\"借用tostring方法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>\n<h2 id=\"复杂数据类型object是否是arraydate类的实例\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":246,"createdAt":"2021-06-15T13:48:13.766Z","updatedAt":"2021-06-15T13:48:13.766Z","__v":0},{"_id":"60c8afffda9b3346d469d759","title":"JavaScript var str=true+11+null+9+undefined+\"zhuanbang\"+false+null+9+[],str的值是多少?为什么?","code":"<pre class=\"language-javascript\"><code>var str=true+11+null+9+undefined+\"zhuanbang\"+false+null+9+[];</code></pre>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">结果为&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">NaNzhuanbangfalsenull9</code>,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为undefined类型与任意数类型进行&ldquo;+&rdquo;运算结果都是NaN,NaN在与&rsquo;zhuanbang'+false+null+9+[]运算,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">由于&rsquo;zhuanbang&rsquo;是字符串类型,NaN是number类型,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">NaN会隐式调用toString方法得到&lsquo;NaN&rsquo;,false是布尔类型当与字符串类型相加会隐式调用toString方法,得到&rsquo;false&rsquo;,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">9和空数组同样也是调用toString方法进行加运算。</p>","rank_id":247,"createdAt":"2021-06-15T13:49:51.252Z","updatedAt":"2021-06-15T13:49:51.252Z","__v":0},{"_id":"60c8b1bbda9b3346d469d75a","title":"JavaScript []和{}表示什么?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">[]</code>表示数组,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">{}</code>表示对象,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这2种声明方式都为字面量方式。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">除了字面量方式外还可以用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">new Array</code>及<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">new Object</code>来实例化。</p>","rank_id":248,"createdAt":"2021-06-15T13:57:15.677Z","updatedAt":"2021-06-15T13:57:15.677Z","__v":0},{"_id":"60c8b1d8da9b3346d469d75b","title":"JavaScript 语法i++,++i,和+i是什么意思?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">i++</code>表示先赋值后运算,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">++i</code>表示先运算后赋值,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">+i</code>表示与<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">i</code>进行<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">+</code>运算。</p>","rank_id":249,"createdAt":"2021-06-15T13:57:44.428Z","updatedAt":"2021-06-15T13:57:44.428Z","__v":0},{"_id":"60c8b1edda9b3346d469d75c","title":"JavaScript 什么叫全局变量?什么叫局部变量了?是如何定义出来的?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">全局变量是在函数外部定义的变量,在JS中全局变量属于window对象,其作用域是整个源程序,全局变量全部存放在静态存储区,在程序开始执行时给全局变量分配存储区,程序运行完毕就释放。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">局部变量是相对与全局变量而言的,在特定过程或函数中可以访问的变量,作用域较小,当函数运行结束释放局部变量。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在JavaScript中并没有明确局部变量的概念,是相对于其他编程语言来描述。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">参考《JavaScript高级程序设计》中,变量分全局变量和函数变量。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">什么叫保留字?在定义变量时我们应该注意哪些?</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">保留字是JavaScript中已经定义过的字,由于考虑扩展性,一些保留字可能并没有应用于当前的语法中,这是保留字与关键字的区别。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如class、abstract是保留字。在定义变量时应避免与保留字取名相同;</p>","rank_id":250,"createdAt":"2021-06-15T13:58:05.804Z","updatedAt":"2021-06-15T13:58:05.804Z","__v":0},{"_id":"60c8b239da9b3346d469d75d","title":"JavaScript 书写规范/原则","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"参考\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">参考</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">变量的首字母不能是数字，其它字母可以是字母、数字、下划线</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">不能用关键字和保留字作为变量的名字；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">使用驼峰命名法来书写变量</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">使用匈牙利命名法来书写明确知道变量名字；让别人一眼看出什么变量类型；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">后续需要用到的变量，可以先赋值为null；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">借用变量的时候；变量最后不用时候置为null；</span></p>\n<h2 id=\"其它的细节\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">其它的细节</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">&nbsp;</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">1.不要在同一行声明多个变量。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">2.请使用 ===/!==来比较true/false或者数值</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">3.使用对象字面量替代new Array这种形式</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">4.尽量不使用全局函数。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">5.switch语句必须带有default分支</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">6.函数不应该有时候有返回值，有时候没有返回值。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">7.for循环必须使用大括号</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">8.if语句必须使用大括号</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">9.for-in循环中的变量 应该使用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">let</code>或<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">const</code>关键字明确限定作用域，从而避免作用域污染。</p>\n</li>\n</ul>","rank_id":251,"createdAt":"2021-06-15T13:59:21.450Z","updatedAt":"2021-06-15T13:59:21.450Z","__v":0},{"_id":"60c8b265da9b3346d469d75e","title":"在IE,fireFox,chrome这三个浏览器中,如何查看JS代码的报错?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这个问题，一般是作为引子使用，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果没有改过键，一般按&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">F12</code>启动调试工具。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">面试官正常会追问些，怎么调试BUG，等问题</p>","rank_id":252,"createdAt":"2021-06-15T14:00:05.276Z","updatedAt":"2021-06-15T14:00:05.276Z","__v":0},{"_id":"60c8b2e9da9b3346d469d75f","title":"JavaScript 说一说html代码,css代码和js代码的注释写法?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"font-size: 12pt;\">HTML注释语法</span></p>\n<pre class=\"language-markup\"><code>&lt;!--注释的内容--&gt;</code></pre>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">css注释语法</span></h2>\n<pre class=\"language-css\"><code>/* 注释内容 */</code></pre>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">javaScript注释</span></h2>\n<pre class=\"language-javascript\"><code>//注释内容\n/*注释内容*/</code></pre>\n<h2 id=\"javascript注释\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>\n<h2 id=\"css注释语法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":253,"createdAt":"2021-06-15T14:02:17.464Z","updatedAt":"2021-06-15T14:02:17.464Z","__v":0},{"_id":"60c8b349da9b3346d469d760","title":"JavaScript 循环语句有几种写法?用不同的写法写出判断当天是星期几的方法;","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"循环语句有几种写法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">循环语句有几种写法</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果您希望一遍又一遍地运行相同的代码，并且每次的值都不同，那么使用循环是很方便的。迭代语句又叫循环语句。 JavaScript 支持不同类型的循环：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">for</code>&nbsp;- 循环代码块一定的次数</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">for/in</code>&nbsp;- 循环遍历对象的属性</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">while</code>&nbsp;- 当指定的条件为 true 时循环指定的代码块</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">while do</code>&nbsp;当指定的条件为 true 时循环指定的代码块</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">forEach()</code>&nbsp;方法用于调用数组的每个元素，并将元素传递给回调函数。</li>\n</ul>\n<h2 id=\"写出判断当天是星期几的方法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">写出判断当天是星期几的方法;</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">核心是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">if</code>&nbsp;和&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">switch</code></p>\n<h3 id=\"if\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">if</code></h3>\n<pre class=\"language-javascript\"><code>let timeToday = new Date();\nlet day = timeToday.getDay();\nlet str = '';\nif (day === 0) {\n  str = '星期日';\n} else if (day === 1) {\n  str = '星期一';\n} else if (day === 2) {\n  str = '星期二';\n} else if (day === 3) {\n  str = '星期三';\n} else if (day === 4) {\n  str = '星期四';\n} else if (day === 5) {\n  str = '星期五';\n} else if (day === 6) {\n  str = '星期六';\n}\nconsole.log(\"今天是\", str)</code></pre>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">switch</code></h3>\n<pre class=\"language-javascript\"><code>let timeToday = new Date();\nlet day = timeToday.getDay();\nlet str = '';\nswitch (day) {\n  case 0:\n    str = '星期日'\n    break;\n  case 1:\n    str = '星期一'\n    break;\n  case 2:\n    str = '星期二'\n    break;\n  case 3:\n    str = '星期三'\n    break;\n  case 4:\n    str = '星期四'\n    break;\n  case 5:\n    str = '星期五'\n    break;\n  case 6:\n    str = '星期六'\n    break;\n  default:\n    break;\n}\nconsole.log(\"今天是\", str)</code></pre>\n<h3 id=\"switch\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\"></code></h3>\n<p><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\"></code></p>","rank_id":254,"createdAt":"2021-06-15T14:03:53.791Z","updatedAt":"2021-06-15T14:03:53.791Z","__v":0},{"_id":"60c8b38cda9b3346d469d761","title":"JavaScript NaN是什么意思?这个值有什么特点?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"核心\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><strong>核心</strong></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">NaN</code>&nbsp;表示不是一个数,但是它本身是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">number</code>&nbsp;类型。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">NaN</code>&nbsp;和&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">NaN</code>&nbsp;不相等</p>\n<h2 id=\"扩展\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">扩展</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可以使用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">isNaN</code>&nbsp;来判断</p>\n<pre class=\"language-javascript\"><code>var num=3;\nwindow.isNaN(num);</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">结果为<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">false</code>。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">isNaN()</code>此方法可以判断一个数是不是一个数。</p>","rank_id":255,"createdAt":"2021-06-15T14:05:00.255Z","updatedAt":"2021-06-15T14:05:00.255Z","__v":0},{"_id":"60c8b3bdda9b3346d469d762","title":"JavaScript 在switch case判断条件中,用到了break;还有的地方用到了return;请问这两者有何区别?如果既不用break也不用return行不行?会有什么样的后果?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">执行break会跳出switch ,然后执行switch下面的语句;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">执行return跳出方法。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不用break会发生击穿现象,执行到下一个case,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不用return 被调用的函数没有返回值(<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">undefined</code>)。</p>","rank_id":256,"createdAt":"2021-06-15T14:05:49.681Z","updatedAt":"2021-06-15T14:05:49.681Z","__v":0},{"_id":"60c8b424da9b3346d469d763","title":"JavaScript 写一个通用的整数随时学方法,要求有两个参数,用来限定随机数的上限和下限,方法最终能返回这个符合条件的随机数;","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.random()</code>&nbsp;获取0~1之间的随机数;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.floor(x)</code>&nbsp;返回小于等于数字参数x的最大整数,对数字进行下舍入,如Math.floor(-1.01)结果为-2。</p>\n<pre class=\"language-javascript\"><code>function fn (max, min) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nconsole.log(fn(48, 30))</code></pre>","rank_id":257,"createdAt":"2021-06-15T14:07:32.097Z","updatedAt":"2021-06-15T14:07:32.097Z","__v":0},{"_id":"60c8b485da9b3346d469d764","title":"2022年的春节是2022年02月01日;请写一段代码;算出现在距离春节还有多少天,多少小时,多少分,多少秒;","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">getTime()</code>方法可返回距1970年1月1日之间的毫秒数。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.floor(x)</code>返回小于等于数字参数x的最大整数,对数字进行下舍入。</p>\n<pre class=\"language-javascript\"><code>function zero (val) {\n  return Number(val) &lt; 10 ? ('0' + val) : val\n};\n  \nfunction fn () {\n  var date1 = new Date();\n  // var date2 = new Date(2022, 1, 1, 0, 0, 0);//传参的时候，传入的是(2022,1)而不是(2022,2...)\n  var date2 = new Date(\"2022/02/01 0:0:0\");//这样传入是没有问题的，不需要改\n  var minutesVal = 60 * 1000;\n  var dateValue = date2.getTime() - date1.getTime();\n  var days = Math.floor(dateValue / (24 * 60 * minutesVal));\n  var hoursValue = dateValue % (24 * 60 * minutesVal);\n  var hours = Math.floor(hoursValue / (60 * minutesVal));\n  var minutesValue = hoursValue % (60 * minutesVal);\n  var minutes = Math.floor(minutesValue / minutesVal);\n  var secondValue = minutesValue % (minutesVal);\n  var second = Math.floor(secondValue / 1000);\n  return {\n    days: days,\n    hours: zero(hours),\n    minutes: zero(minutes),\n    second: zero(second)\n  }\n}\nvar diffTime = fn();\nvar str = `相差 ${diffTime.days}天 ${diffTime.hours}小时 ${diffTime.minutes}分 ${diffTime.second}秒`;\nconsole.log(str);\n// document.write(str);</code></pre>\n<h2 id=\"注意\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">注意：</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果使用 2016-01-25 请使用 2016/01/25 ；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为IE678下不兼容的；需要把<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">-</code>改成<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">/</code>才好；&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">new Date(\"2016/01/25 16:59:59\")</code></p>","rank_id":258,"createdAt":"2021-06-15T14:09:09.922Z","updatedAt":"2021-06-15T14:09:09.922Z","__v":0},{"_id":"60c8b4acda9b3346d469d765","title":"请问alert(Number(\"08\"));输出的结果是什么?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">输出结果为8。</span></p>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">八进制字面值的第一位必须是0,然后是八进制数字0 到7,如果字面值中的数值超出了范围,那么前导的0将被忽略。</span></p>","rank_id":259,"createdAt":"2021-06-15T14:09:48.508Z","updatedAt":"2021-06-15T14:09:48.508Z","__v":0},{"_id":"60c8b509da9b3346d469d766","title":"请使用JavaScript找出name=\"A\"的内容","code":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">请使用JavaScript找出<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">name=\"A\"</code>的内容;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">并用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">console.log</code>方法显示出来;下面的代码最终打印\"1111,3333\"</p>\n<pre class=\"language-markup\"><code>&lt;div name=\"A\"&gt;1111&lt;/div&gt;\n&lt;div name=\"B\"&gt;2222&lt;/div&gt;\n&lt;div name=\"A\"&gt;3333&lt;/div&gt;</code></pre>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">getAttribute()</code>&nbsp;方法不能通过&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">document</code>&nbsp;对象调用,只能通过一个元素节点对象调用它。</p>\n<pre class=\"language-javascript\"><code>var oDivs = document.getElementsByTagName('div');\nvar sValue = '';\nfor (let index = 0; index &lt; oDivs.length; index++) {\n  const item = oDivs[index];\n  const attr = item.getAttribute('name');\n  if (attr &amp;&amp; (attr === 'A')) {\n    sValue += (!sValue ? \"\" : \",\") + item.innerText();\n  }\n}\nconsole.log(sValue);</code></pre>","rank_id":260,"createdAt":"2021-06-15T14:11:21.921Z","updatedAt":"2021-06-15T14:11:21.921Z","__v":0},{"_id":"60c8b5a7da9b3346d469d767","title":"JavaScript 下面的目的是把所有的li都删除掉;下面的方法有没有问题?为什么?怎么解决?","code":"<pre class=\"language-markup\"><code>&lt;ul id=\"ul1\"&gt; \n    &lt;li&gt;node&lt;/li&gt; \n    &lt;li&gt;node&lt;/li&gt; \n    &lt;li&gt;node&lt;/li&gt; \n    &lt;li&gt;node&lt;/li&gt; \n    &lt;li&gt;node&lt;/li&gt; \n&lt;/ul&gt;</code></pre>\n<p><span style=\"font-size: 12pt;\">JS代码</span></p>\n<pre class=\"language-javascript\"><code>var eles=document.getElementById(\"ul1\").getElementsByTagName(\"li\");\nvar liLength=eles.length;\nfor(var i=0;i&lt;liLength;i++){\n  eles.item(i).parentNode.removeChild(eles.item(i))\n}</code></pre>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">因为</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">liLength</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">的值是一直变化的,所以会有未删除项,</span></p>\n<pre class=\"language-javascript\"><code>var oLis = document.getElementById('url1').childNodes;\nwhile (oLis[0]) {\n  oLis[0].parentNode.removeChild(oLis[0]);\n}</code></pre>","rank_id":261,"createdAt":"2021-06-15T14:13:59.773Z","updatedAt":"2021-06-15T14:13:59.773Z","__v":0},{"_id":"60c8b611da9b3346d469d768","title":"JavaScript 作用域闭包的概念,闭包用在哪里有哪些变化?性能如何?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">闭包的概念,在写一个<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">function fn(){}</code>&nbsp;然后<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">fn()</code>;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">fn这个函数执行的时候就会产生一个封闭的作用域,这个封闭的作用域就是闭包；(函数的执行就是闭包)</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">而大家普遍认为的闭包是;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">(function(){})()</code>;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">说这个闭包的一种形式,也就是闭包的一种应用,这样用闭包的好处是避免变量冲突;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">但是闭包还有一个缺点,就是如果闭包中有引用类型的数据被使用,那么整个闭包都无法释放,占用内存。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">闭包一般用在选项卡那类的异步操作,还有定时器的时候用;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为这时候闭包所产生的作用域不销毁,如果用this.index来代替闭包,性能会好很多;</p>\n<blockquote style=\"padding: 0px 0px 8px; margin: 10px 0px; color: #828201; border-width: 1px 1px 1px 5px; border-style: solid; border-color: #e2e2e2 #e2e2e2 #e2e2e2 #fff000; border-image: initial; background-color: #ffffc0; overflow: hidden; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">闭包是指有权访问另一个函数作用域中的变量的函数，并且在闭包内部形成一个外部无法访问的局部作用域。</p>\n</blockquote>\n<blockquote style=\"padding: 0px 0px 8px; margin: 10px 0px; color: #828201; border-width: 1px 1px 1px 5px; border-style: solid; border-color: #e2e2e2 #e2e2e2 #e2e2e2 #fff000; border-image: initial; background-color: #ffffc0; overflow: hidden; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">创建闭包的常见方式是在一个函数内部创建另一个函数。通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。</p>\n</blockquote>\n<h2 id=\"闭包是一种机制\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">闭包是一种机制</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">函数要访问一个变量的时候，就会先从自己的作用域开始，逐步向外层函数的作用域寻找那个变量的值。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">简而言之就是外层函数不能访问内层，内层能访问外层。</p>\n<h3 id=\"优点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">优点</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">加强封装性,可以达到对变量的保护作用。</p>\n<h3 id=\"缺点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">缺点</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">1)&nbsp;&nbsp;由于闭包内部变量优先级高于外部变量,所以多查找作用域链中的一个层次,就会在一定程度上影响查找速度。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">2)&nbsp;&nbsp;内存浪费,如下：</p>\n<pre class=\"language-javascript\"><code>function teachersInfo (propertyName) {\n  return function (obj1, obj2) {\n    return obj1[propertyName] + ' - ' + obj2[propertyName]\n  }\n}\n//创建函数\nvar getTeachers = teachersInfo('name');\n//调用函数\nvar resule = getTeachers({ name: \"朱一\" }, { name: \"朱二\" }, { name: \"朱三\" })\nconsole.log(resule);//朱一 - 朱二\ngetTeachers = null;//释放这个句柄</code></pre>\n<h4 id=\"知识点\" style=\"padding: 0px; margin: 18px 0px 6px 18px; font-size: 16px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #999999; letter-spacing: 1px; background-color: #ffffff;\">知识点</h4>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当执行函数<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">teachersInfo</code>时,函数的作用域链包括活动对象（参数propertyName）和全局变量对象,当函数<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">teachersInfo</code>执行完毕后,其活动对象也不会被销毁,因为匿名函数的作用域链仍然在引用这个活动对象。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">getTeachers</code>&nbsp;指向的是匿名函数的地址,所以最后需要释放这个句柄。</p>\n<h2 id=\"闭包的特性\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">闭包的特性</h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">函数内再嵌套函数</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">内部函数可以引用外层的参数和变量</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">参数和变量不会被垃圾回收机制回收\n<pre class=\"language-javascript\"><code>function say667() {\n    var num = 666;\n    var sayAlert = function() { alert(num); }\n    num++;\n    return sayAlert;\n}\nvar sayAlert = say667();\nsayAlert()//执行结果应该弹出的667  </code></pre>\n</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">执行<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">say667()</code>后,<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">say667()</code>闭包内部变量会存在,而闭包内部函数的内部变量不会存在.</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源，因为say667()的内部函数的执行需要依赖say667()中的变量。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">这是对闭包作用的非常直白的描述.</p>","rank_id":262,"createdAt":"2021-06-15T14:15:45.799Z","updatedAt":"2021-06-15T14:15:45.799Z","__v":0},{"_id":"60c8b63dda9b3346d469d769","title":"JavaScript 写一个从0到59依次循环的计时器","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">主要是考&nbsp;</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">setInterval</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">&nbsp;以及临界判断;</span></p>\n<pre class=\"language-javascript\"><code>var flag = 0;\nfunction timer () {\n  flag++;\n  if (flag &gt; 59) {\n    flag = 0;\n    return;\n  }\n  console.log(flag);\n}\nsetInterval(timer, 1000);</code></pre>\n<p>&nbsp;</p>","rank_id":263,"createdAt":"2021-06-15T14:16:29.947Z","updatedAt":"2021-06-15T14:16:29.947Z","__v":0},{"_id":"60c8b689da9b3346d469d76a","title":"JavaScript 双十一倒计时更准确","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"思路\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">思路</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">核心：要用 结束时间 - 系统当前时间 来计算</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当然 系统当前时间可能不准确 可以和服务器做个同步</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">定时器本身就不准，timeout是在限定时间内，interval是在限定时间后。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">chrome为了优化网页性能，使得用户在离开网页后，暂停网页的计时器、运动等耗性能的部分，故此问题只能使用异步解决，使得计时线程在后台一直运行</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">前端的计时逻辑永远不会准，即便你初始化时间采用服务器时间。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为网络传输误差你不知道，同时<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">setTimeout</code>和<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">setInterval</code>并不会非常精确，所以不要依赖前端计时器来处理重要逻辑，需要结合后台来保障。</p>\n<h2 id=\"逻辑代码\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">逻辑代码</h2>\n<pre class=\"language-javascript\"><code>function fn () {\n  var date1 = new Date();//可以借助服务器辅助时间\n  var date2 = new Date(2022, 11, 11, 0, 0, 0);\n  var minutesVal = 60 * 1000;\n  var dateValue = date2.getTime() - date1.getTime();\n  var days = Math.floor(dateValue / (24 * 60 * minutesVal));\n  var hoursValue = dateValue % (24 * 60 * minutesVal);\n  var hours = Math.floor(hoursValue / (60 * minutesVal));\n  var minutesValue = hoursValue % (60 * minutesVal);\n  var minutes = Math.floor(minutesValue / minutesVal);\n  var secondValue = minutesValue % (minutesVal);\n  var second = Math.floor(secondValue / 1000);\n  return {\n    days: days,\n    hours: hours,\n    minutes: minutes,\n    second: second\n  }\n}\nvar diffTime = fn();\nvar str = `相差 ${diffTime.days}天 ${diffTime.hours}小时 ${diffTime.minutes}分 ${diffTime.second}秒`;\nconsole.log(str);\n// document.write(str);</code></pre>\n<p>&nbsp;</p>","rank_id":264,"createdAt":"2021-06-15T14:17:45.115Z","updatedAt":"2021-06-15T14:17:45.115Z","__v":0},{"_id":"60c8b733da9b3346d469d76b","title":"JavaScript null和undefined的区别?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"知识点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">知识点</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">null是一个表示\"无\"的对象,转为数值时为0</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">undefined是一个表示\"无\"的原始值,转为数值时为NaN</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当声明的变量还未被初始化时,变量的默认值为undefined</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">null用来表示尚未存在的对象,常用来表示函数企图返回一个不存在的对象</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">null\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">表示一个对象被定义了，值为&ldquo;空值&rdquo;；</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">undefined\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">表示不存在这个值。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"undefined\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">undefined</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">undefined表示 &ldquo;缺少值&rdquo;,就是此处应该有一个值,但是还没有定义。典型用法是：</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">变量被声明了,但没有赋值时,就等于 undefined</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">调用函数时,应该提供的参数没有提供,该参数等于 undefined</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">对象没有赋值的属性,该属性的值为 undefined</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">函数没有返回值时,默认返回 undefined\n<pre class=\"language-javascript\"><code>typeof undefined\n    //\"undefined\"\n    // undefined :是一个表示\"无\"的原始值或者说表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； \n    // 例如变量被声明了，但没有赋值时，就等于undefined</code></pre>\n</li>\n</ol>\n<h2 id=\"null\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; letter-spacing: 2px;\">null</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">null表示&ldquo;没有对象&rdquo;,即该处不应该有值。典型用法是：</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">作为函数的参数,表示该函数的参数不是对象</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">作为对象原型链的终点</li>\n</ol>\n<blockquote style=\"padding: 0px 0px 8px; margin: 10px 0px; color: #828201; border-width: 1px 1px 1px 5px; border-style: solid; border-color: #e2e2e2 #e2e2e2 #e2e2e2 #fff000; border-image: initial; background-color: #ffffc0; overflow: hidden;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">注意：在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</p>\n</blockquote>\n<pre class=\"language-javascript\"><code>typeof null\n    //\"object\"\n    // null : 是一个对象(空对象, 没有任何属性和方法)；\n    // 例如作为函数的参数，表示该函数的参数不是对象；</code></pre>","rank_id":265,"createdAt":"2021-06-15T14:20:35.044Z","updatedAt":"2021-06-15T14:20:35.044Z","__v":0},{"_id":"60c8b78eda9b3346d469d76c","title":"JavaScript add(2, 3, 4)，add(2)(3)(4)和add(2, 3)(4)","code":"<pre class=\"language-javascript\"><code>console.log(add(2, 3, 4));\nconsole.log(add(2)(3)(4));\nconsole.log(add(2, 3)(4));</code></pre>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>let _typeof = function (data) {\n  let value = /\\[object (\\w+)\\]/.exec(\n    Object.prototype.toString.call(data)\n  );\n  return value ? value[1].toLowerCase() : '';\n}\n// 参数3个的时候，返回值\n// 参数小于3的时候，返回函数，比如，1，2\nfunction add (...arg) {\n  // TODO转出数组\n  let ary = [...arg];\n  let sum = 0;\n  // 相加\n  ary.forEach(ele =&gt; {\n    // 判断参数类型\n    if (_typeof(ele) !== 'number') {\n      throw Error(`不支持非数字类型；参数${ele} (${_typeof(ele)} 类型)`)\n    }\n    sum += ele;\n  })\n  // console.log(sum);\n  // 返回\n  if (ary.length &gt;= 3) {\n    return sum;\n  }\n  const _add = function () {\n    if (arguments.length &gt; 1) {\n      throw Error(`暂时不支持链式调用多个参数`)\n    }\n    if (ary.length === 1) {\n      return add(sum, ...arguments)\n    }\n    return add(sum, ...arguments, 0)\n  }\n  return _add;\n}\nconsole.log(add(2, 3, 4));\nconsole.log(add(2)(3)(4));\nconsole.log(add(2, 3)(4));</code></pre>","rank_id":266,"createdAt":"2021-06-15T14:22:06.792Z","updatedAt":"2021-06-15T14:22:06.792Z","__v":0},{"_id":"60c94c737d119d797cb7b75c","title":"JavaScript 事件冒泡机制","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">事件传播机制（不管是DOM0还是DOM2，这个机制是天生就带的）；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当触发底层元素的某一个事件行为，那么它的上级元素的对应事件行为也会一级级的触发，一直出发到我们的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">document</code>；（只有相同的事件类型才会触发）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>从底层一级级往上传播的机制叫做冒泡；</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>DOM2级绑定事件，第三个参数写false代表的是冒泡阶段执行，如果写的是true，代表的是在捕获阶段执行；</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">同一个元素既可以在捕获阶段处理也可以在冒泡阶段处理；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">DOM0级基本上只能控制冒泡阶段，而DOM2级是可以控制捕获阶段的；</p>\n<h3 id=\"事件委托\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">事件委托</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">利用DOM的传播机制（点击任意元素，document的click都要出发），我们给document绑定一个点击事件，在事件中我们只需要获取事件源；根据不同的事件源做不同的事件就可以的了（这样就可以不用给元素一个个的绑定事件的了）；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当事件发生在子元素中的时候，旺旺会引起连锁反应，就是在它的祖先元素上也会发生这个事件，比如说你点击了div一个，也相当于点击了一个body，同样相当于点击了html，同样相当于点击了document；</p>\n<h3 id=\"理解事件传播的时候要注意两点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">理解事件传播的时候要注意两点；</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一是事件本身在传播，而不是绑定在事件上的方法会传播；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">二是并非所有的事件都会传播，像<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">onfocus</code>，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">onblur</code>事件就不传播，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">onmouseenter</code>和<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">onmouseleave</code>事件也不会传播；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我们要知道常见的事件默认行为有哪些，并且要知道组织默认行为，只要绑定到这个行为事件的方法最后加一句，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">return false</code>就可以了；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">但是需要强调的是，如果你的事件绑定是用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">addEventListener</code>来实现的，那么组织默认行为必须用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">e.preventDefault=true;</code></p>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">阻止事件冒泡</h3>\n<pre class=\"language-javascript\"><code>function (e) { \n  e.preventDefault(); \n}</code></pre>\n<p><strong style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">事件委托</strong><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">：事件委托就是用事件的传播机制，无论哪一个网页元素，它的click事件都会最终传到document上，这样，则只需在document上处理click事件即可；</span></p>\n<pre class=\"language-javascript\"><code>document.onclick=function(e){\n    e=e||window.event;\n    var  target=e.targrt||e.srcElement;//获取事件源是关键；\n    alert(target.nodeName);\n    return false;\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">事件委托的关键是理解好事件源的概念；</span></p>\n<h3 id=\"阻止事件冒泡\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>","rank_id":267,"createdAt":"2021-06-16T00:57:23.445Z","updatedAt":"2021-06-16T00:57:23.445Z","__v":0},{"_id":"60c94cde7d119d797cb7b75d","title":"JavaScript 事件兼容性问题有哪些？怎么解决？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">1、事件对象本身，标准浏览器是时间发生时自动给方法传一个实参，这个实参就是时间对象，IE是全局的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">window.event</code>；（解决方法是：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">e=e||window.event</code>）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">2、事件源:<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">e.target</code>，IE下是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">e.srcElement</code>;（解决办法是是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">var target=e.target||e.srcElement;</code>）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">3、DOM二级事件绑定：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">ele.addEventListener</code>,IE是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">ele.attachEvent</code>；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">解决办法是通过</p>\n<pre class=\"language-javascript\"><code>if(ele.addEventListener){\n}else if(ele.attachEvent){\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这样的方法来解决绑定对应的移除方法是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">removeEventListener</code>和IE的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">detachEvent</code>;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">4、第三点中的IE的attachEvent绑定的方法上，</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">第一点、this不是当前元素了，而是变成了window；</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">第二点，事件的执行顺序是混乱的；\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">在IE678中，如果绑定的方法少于9个，执行的顺序是相反的，如果多于9个，执行的是混乱的；</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">第三点，同一函数可以重复绑定在同一事件上；\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">需要解决一个函数不能重复绑定在同一个事件上，低版本IE没有遵循这个原则；要保证一个方法只能被绑定到某事件上一次；</li>\n</ul>\n</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">5、阻止事件传播；<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">e.stopPropagation</code>,IE是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">e.cancelBubble=true</code>这个属性；这个一般不做处理，用这个属性，还可以做观察者模式的；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">6、阻止默认行为：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">e.preventDefault()</code>方法，IE是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">e.returnValue=false</code>；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">7、<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">e.pageX</code>,<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">e.pageY</code>;相对于文档的鼠标坐标IE不支持这两个属性；但都支持<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">clentX</code>，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">clentY</code>，这个是相对于浏览器的鼠标坐标。可以通过scrollTop+clientY来实现；</p>\n<pre class=\"language-javascript\"><code>e.pageX=(document.documentElement.scrollLeft||document.body.scrollLeft)+ e.clientX;\ne.pageY=(document.documentElement.scrollTop||document.body.scrollTop)+ e.clientY;</code></pre>","rank_id":268,"createdAt":"2021-06-16T00:59:10.245Z","updatedAt":"2021-06-16T00:59:10.245Z","__v":0},{"_id":"60c94d157d119d797cb7b75e","title":"JavaScript 写一个通用的事件侦听器函数","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>/*on:是负责往数组里安排一个队列的，程序池*/\nfunction on (ele, type, fn) {\n  if (ele.addEventListener) {\n    ele.addEventListener(type, fn);\n  } else {\n    if (!ele[\"aEvent\" + type]) {\n      ele[\"aEvent\" + type] = [];//用了自定义属性，这里不能用全局（污染），不能用局部（off失效）\n      //bind3(ele,type,run);//只会执行一次,防止重复绑定；上一次封装的事件库是用bind解决的\n      ele.attachEvent(\"on\" + type, function () { run.call(ele) })//放在这里，因为是在if里，所以是有条件执行的，而且这里是只执行一次；防止重复绑定；\n    }\n    var aryEvent = ele[\"aEvent\" + type];\n    for (var i = 0; i &lt; aryEvent.length; i++) {//防止同一个方法被同事件绑定；\n      if (aryEvent[i] == fn) return;\n    }\n    aryEvent.push(fn);\n  }\n}\n/*run:负责具体的执行,在这里把IE兼容性全部解决掉;run方法是由系统的事件来触发的,真正绑定的是run方法；run在on里执行的*/\nfunction run () {//run方法只用在IE678；\n  var e = window.event;\n  e.target = e.srcElement;\n  e.pageX = (document.documentElement.scrollLeft || document.body.scrollLeft) + e.clientX;\n  e.pageY = (document.documentElement.scrollTop || document.body.scrollTop) + e.clientY;\n  e.stopPropagation = function () { e.cancelBubble = true; }//阻止事件传播;\n  e.preventDefault = function () { e.returnValue = false; }//阻止事件默认行为;\n  var a = this[\"aEvent\" + e.type];\n  for (var i = 0; i &lt; a.length;) {\n    /*下面是防止数组塌陷的*/\n    if (typeof a[i] == \"function\") {//这个是和off呼应的，off里有为null的值；\n      a[i].call(this, e);//以后给元素写的方法，约定好都要写一个e的参数，这样就不需要再解决IE兼容性了；\n      i++;\n    } else {\n      a.splice(i, 1);\n    }\n  }\n}\nfunction off (ele, type, fn) {\n  if (ele.removeEventListener) {\n    ele.removeEventListener(type, fn);\n  } else {\n    var aryEvent = ele[\"aEvent\" + type];\n    if (aryEvent &amp;&amp; aryEvent.length) {\n      for (var i = 0; i &lt; aryEvent.length; i++) {\n        if (aryEvent[i] == fn) {\n          aryEvent[i] = null;\n          return;\n        }\n      }\n    }\n  }\n}\nfunction bindThis (obj, fn) {\n  return function (e) { fn.call(obj, e) }\n}</code></pre>","rank_id":269,"createdAt":"2021-06-16T01:00:05.571Z","updatedAt":"2021-06-16T01:00:05.571Z","__v":0},{"_id":"60c94dca7d119d797cb7b75f","title":"JavaScript DOM2级绑定的优点以及兼容性问题","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">文档元素属于nodeList集合，该集合属于动态的，每当文档结构发生变化时，它们都会得到更新。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因此，它们始终都保存最新、最准确的信息。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">兼容性(待大家补充)：</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">所有IE（6、7、8、9）中getElementsByName不能获取到非表单元素（例如<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;li&gt;&lt;/li&gt;</code>&nbsp;）以下是解决方法：\n<pre class=\"language-javascript\"><code>var lis = document.getElementsByTagName('*');\nvar aLi = [];\nfor (let index = 0; index &lt; aLi.length; index++) {\n  if (lis[i].getAttribute('name') == 'liOption') {\n    aLi.push(lis[i]);\n  }\n}</code></pre>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">getElementById(&lsquo;id&rsquo;);有兼容性问题 IE6、7版本对ID不区分大小写 而其他浏览器严格区分大小写。</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">var oText=document.createTextNode(&lsquo;我用DOM方法创建的第一个节点&rsquo;);//IE中可以不写参数 火狐中必须写。</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">previousElementSibling;//只表示oLi6的元素哥哥（就是它的上一个元素节点）老版浏览器都不支持如IE6、7、8。</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">firstElementChild//指它的第一个元素子节点，老版浏览器都不支持如IE6、7、8。</li>\n</ol>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">注意：DOM1级的目标主要是映射文档的结构，如html结构。DOM2级在DOM1基础上又扩充了鼠标和用户界面事件、范围、遍历（迭代DOM文档的方法）等细分模块，而且通过对象接口增加了对CSS的支持。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">//DOM二级时间是定义在EventTarget上的；也就是【<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">oUl.__proto__.__proto__.__proto__.__proto__.__proto__</code>】Oul找五层；基类是Object；所以DOM2性能没有DOM0级好；</p>\n<div class=\"google-auto-placed ap_container\" style=\"padding: 0px; margin: 0px; width: 870px; height: auto; clear: both; text-align: center;\"><ins class=\"adsbygoogle adsbygoogle-noablate\" style=\"display: block; margin: auto; background-color: transparent; height: 0px;\" data-ad-format=\"auto\" data-ad-client=\"ca-pub-3504340093271389\" data-adsbygoogle-status=\"done\" data-ad-status=\"unfilled\"><ins id=\"aswift_3_expand\" style=\"border: none; height: 0px; width: 870px; margin: 0px; padding: 0px; position: relative; visibility: visible; background-color: transparent; display: inline-table;\" tabindex=\"0\" title=\"Advertisement\" aria-label=\"Advertisement\"><ins id=\"aswift_3_anchor\" style=\"border: none; height: 0px; width: 870px; margin: 0px; padding: 0px; position: relative; visibility: visible; background-color: transparent; display: block; overflow: hidden; opacity: 0;\"><iframe id=\"aswift_3\" style=\"left: 0px; position: absolute; top: 0px; border-width: 0px; border-style: initial; width: 870px; height: 0px;\" src=\"https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3504340093271389&amp;output=html&amp;h=280&amp;adk=109321987&amp;adf=970835177&amp;pi=t.aa~a.2817947589~i.20~rp.4&amp;w=870&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1622810652&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9523024247&amp;psa=1&amp;ad_type=text_image&amp;format=870x280&amp;url=https%3A%2F%2Fwww.axihe.com%2Ffocus%2Fjs%2Fevent%2F04.html&amp;flash=0&amp;fwr=0&amp;pra=3&amp;rh=200&amp;rw=870&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;uach=WyJXaW5kb3dzIiwiMTAuMCIsIng4NiIsIiIsIjkxLjAuNDQ3Mi4xMDEiLFtdXQ..&amp;dt=1623805245550&amp;bpp=1&amp;bdt=259&amp;idt=1&amp;shv=r20210610&amp;cbv=%2Fr20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3Dc42b20e6ee6efa3d-221193c456c90083%3AT%3D1623293344%3ART%3D1623293344%3AS%3DALNI_MbzQJ6BWGNxs0oRE7-tp-4q8E74oA&amp;prev_fmts=0x0%2C878x280%2C890x280&amp;nras=2&amp;correlator=6012015061152&amp;frm=20&amp;pv=1&amp;ga_vid=555460619.1623805245&amp;ga_sid=1623805245&amp;ga_hid=125271907&amp;ga_fc=0&amp;u_tz=480&amp;u_his=4&amp;u_java=0&amp;u_h=864&amp;u_w=1536&amp;u_ah=824&amp;u_aw=1536&amp;u_cd=24&amp;u_nplug=3&amp;u_nmime=4&amp;adx=325&amp;ady=1312&amp;biw=1519&amp;bih=722&amp;scr_x=0&amp;scr_y=0&amp;eid=42530671%2C31060615%2C31060957&amp;oid=3&amp;pvsid=3164146425025166&amp;pem=199&amp;ref=https%3A%2F%2Fwww.axihe.com%2Fmap%2Fjs-focus.html&amp;eae=0&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1536%2C0%2C1536%2C824%2C1536%2C722&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;ifi=4&amp;uci=a!4&amp;btvi=2&amp;fsb=1&amp;xpc=OnFUjbXLuU&amp;p=https%3A//www.axihe.com&amp;dtd=14\" name=\"aswift_3\" width=\"870\" height=\"0\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" sandbox=\"allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation\" allowfullscreen=\"allowfullscreen\" data-google-container-id=\"a!4\" data-load-complete=\"true\" data-google-query-id=\"CNqCq_f5mvECFQR2vAodHooBNQ\"></iframe></ins></ins></ins></div>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">DOM一级事件，同一个事件绑定多个处理方法时候，后面的绑定会覆盖前面的绑定；DOM2可以给click绑定多个事件，解决了这个问题；</p>\n<pre class=\"language-javascript\"><code>ele.onclick=fn1;\nele.onclick=fn2;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这样处理的结果就是，ele的onclick事件上，fn2方法吧fn1方法给覆盖了，这样不容易实现同一个事件上绑定多个方法；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">DOM2绑定方法是；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">W3C给出的方法是这样的；</p>\n<pre class=\"language-javascript\"><code>ele.addEventListener(&ldquo;click&rdquo;,fn,false);</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">IE678给出的方法是</span></p>\n<pre class=\"language-javascript\"><code>ele.attachEvent(&ldquo;onclokck&rdquo;,fn)</code></pre>","rank_id":270,"createdAt":"2021-06-16T01:03:06.180Z","updatedAt":"2021-06-16T01:03:06.180Z","__v":0},{"_id":"60c94dfb7d119d797cb7b760","title":"JavaScript 事件IE与火狐的时间机制有什么区别？如何阻止冒泡？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">我们在网页中的某个操作（有的操作对应多个事件）。</li>\n</ol>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。</li>\n</ul>\n</li>\n</ul>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"2\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">ev.stopPropagation();</code>&nbsp;注意旧ie的方法&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">ev.cancelBubble = true;</code></p>\n</li>\n</ol>","rank_id":271,"createdAt":"2021-06-16T01:03:55.031Z","updatedAt":"2021-06-16T01:03:55.031Z","__v":0},{"_id":"60c94ea07d119d797cb7b761","title":"JavaScript 如何使用事件，以及IE和标准DOM事件模型之间存在的差别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol class=\"linenums\" style=\"padding: 0px 0px 0px 10px; margin: 0px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace; font-size: 14px; color: #495666; white-space: pre;\">\n<li class=\"L0\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\">\n<h3 id=\"关于事件流\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; white-space: normal; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">关于事件流</span></h3>\n<pre class=\"language-markup\"><code>1.1 IE的事件流：事件冒泡\n  由事件的目标(event.srcElement)接受事件，然后逐级向上（例：下一个为包含event.srcElement的节点传递事件,直到文档节点document;\n1.2 其他浏览器支持的另一种事件流：事件捕获\n  与事件冒泡正好相反，文档节点document先监听到事件，然后把事件逐级向下传递事件，直到目标节点event.target；\n1.3 DOM事件流\n  DOM2级事件规范的事件流综合了以上两种，把事件流分为了以下三个阶段：\n  1.3.1 事件捕获阶段\n    不涉及事件目标，或者说这个阶段在目标之前就结束了；\n  1.3.2 处于目标阶段\n    被看作冒泡阶段的一部分，所以可以在冒泡阶段在目标事件上操作事件；\n  1.3.3 事件冒泡阶段\n1.4 规范和浏览器实现的差别\n  DOM2级事件规范的捕获阶段，事件从文档节点document开始传播，现代浏览器大多数都是从window对象开始传播事件的；\n  DOM2级事件规范捕获阶段不涉及事件目标，现代浏览器大多数都在这个阶段包含事件目标。</code></pre>\n</li>\n<li class=\"L0\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\">\n<h3 id=\"如何使用事件以下是几种用来响应事件的事件处理程序\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; white-space: normal; background-color: #ffffff;\">如何使用事件？以下是几种用来响应事件的事件处理程序</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; white-space: normal; background-color: #ffffff;\">HTML事件处理程序|DOM0级事件处理程序|DOM2级事件处理程序|IE的事件处理程序(IE11以下)</p>\n<pre class=\"language-markup\"><code>2.1HTML事件处理程序\n  2.1.1 指定事件:&lt;button type=\"button\" onclick=\"alert('响应事件的处javascript代码，可以用全局的函数')\"&gt;Click Me!&lt;/button&gt;\n  2.1.2 优缺点:简单，但是与HTML代码紧密耦合，更改不方便;\n  2.1.3 删除事件:同DOM0的删除事件处理方式;\n2.2 DOM0级事件处理程序\n  2.2.1 指定事件:document.onclick = function(){alert(\"document has been clicked\")};\n  2.2.2 删除事件:document.onclick = null;\n  2.2.3 优缺点:简单且跨浏览器\n  2.2.4 实质: 为元素指定方法(栗子中为document指定onclick方法)，移除方法，所以其处理程序是在元素的作用域运行的；\n2.3 DOM2级事件处理程序\n  2.3.1 指定事件:addEventListener(\"引号括起来的事件名\"， 触发事件后调用的事件处理程序, 是否在捕获节点调用时间处理程序的布尔值)\n    栗子:var funA = function(){alert(\" DOM2级事件处理程序\")};\n          document.addEventListener(\"click\", funA, false);\n  2.3.2 删除事件: document.removeEventListener(\"click\", funA, false);\n    如果指定的处理程序是匿名函数则不能删除，因为没有函数名;\n  2.3.3 优缺点: 可以添加多个监听事件，缺点见2.3.2;\n2.4 IE的事件处理程序(IE11以下，IE11及Edge用的DOM2级事件处理程序)\n  2.4.1 指定事件: attachEvent(\"onclick\", function(){alert(\"is no longer supported in ie11\")});\n  2.4.2 删除事件: detachEvent(\"onclick\", funA);\n    如果指定的处理程序是匿名函数则不能删除，因为没有函数名;\n  2.4.3 优缺点:可以添加多个监听事件，缺点见2.4.2;</code></pre>\n</li>\n<li class=\"L0\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\">\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; white-space: normal; background-color: #ffffff;\">IE和标准DOM事件模型之间存在的差别</h3>\n<pre class=\"language-markup\"><code>3.1 这里的IE是IE11以下;\n3.2 参数的差别: attachEvent()的第一个参数比addEventListener()的事件名多一个\"on\"，\n    且没有第三个参数，因为IE事件模型只支持冒泡事件流;\n3.3 事件处理函数作用域的区别: IE中事件处理程序处于全局作用域，其内的this会指向window;\n    而用DOM（0或2）级事件的事件处理程序的作用域是元素作用域，其内的this指向其所属的元素\n    例: document.addEventListener(\"click\", function(){ \n            if(this == document){\n              alert(\"此时this指向document\");\n            }\n          }, false);\n3.4 事件对象event的属性方法的差别\n        IE                    DOM\ncancelBubble = true    stopPropagation() //停止冒泡\nreturnValue = false    preventDefault() //阻止元素默认事件\nsrcEelement            target //事件目标</code></pre>\n<h3 id=\"ie和标准dom事件模型之间存在的差别\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; white-space: normal; background-color: #ffffff;\"></h3>\n</li>\n</ol>","rank_id":272,"createdAt":"2021-06-16T01:06:40.057Z","updatedAt":"2021-06-16T01:06:40.057Z","__v":0},{"_id":"60c94ed07d119d797cb7b762","title":"我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">先捕获，后冒泡；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">addEventListener</code>绑定几次就执行几次，即便绑定的函数一样也会多次执行，结果应该是先显示捕捉再显示冒泡</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">冒泡，需要先冒泡到根节点（document，部分浏览器是html节点），再向下，碰到有绑定的DOM就执行；而捕捉是直接从根节点开始</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">任何发生在 w3c事件模型 中的事件，首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">首先，无论是冒泡事件还是捕获事件，元素都会先执行捕获阶段</p>","rank_id":273,"createdAt":"2021-06-16T01:07:28.192Z","updatedAt":"2021-06-16T01:07:28.192Z","__v":0},{"_id":"60c94f1c7d119d797cb7b763","title":"JavaScript 如何实现事件委托，举例说明","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-markup\"><code>&lt;div id=\"div1\"&gt;\n    &lt;ul&gt;\n        &lt;li &gt;首页&lt;/li&gt;\n        &lt;li xiaomi=\"true\"&gt;小米手机&lt;/li&gt;\n    &lt;/ul&gt;\n    &lt;div id=\"div2\" xiaomi=\"true\"&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre>\n<pre class=\"language-javascript\"><code>var tool = new Tool;//Tool是自己封装的方法\nvar oDiv2 = document.getElementById(\"div2\");\ndocument.onmouseover = function (e) {\n    e = e || window.event;//处理事件兼容性；\n    var tar = e.target || e.srcElement;//事件源；\n    var xiaomi = tar.getAttribute(\"xiaomi\");//监听的对象；\n    var ch = tool.getCss(\"height\", oDiv2);\n    if (xiaomi === \"true\") {//以属性来判断；\n        if (ch &lt;= 200) {\n            move.call(oDiv2, 200)\n        }\n    } else {\n        if (ch &gt; 0) {\n            move.call(oDiv2, 0)\n        }\n    }\n};</code></pre>","rank_id":274,"createdAt":"2021-06-16T01:08:44.834Z","updatedAt":"2021-06-16T01:08:44.834Z","__v":0},{"_id":"60c94ffe7d119d797cb7b764","title":"页面上有一个按钮，点击后，在按钮后面插入一个label，内容显示\"OK\"，已有元素结构","code":"<pre class=\"language-markup\"><code>&lt;input id=\"btnOK\" type=\"button\"/&gt;</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">要求事件卸载页面元素加载完成之后，函数动态绑定到</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">btnOK</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">元素；</span></p>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>$(function(){\n    $(\"#btnOK\").click(function(e){ $(this).after(\"&lt;label&gt;OK&lt;/label&gt;\") ; }) ;\n});</code></pre>\n<p>或者</p>\n<pre class=\"language-javascript\"><code>$(document).ready(function(){\n    $(\"#btnOK\").click(function(e){\n        var lab = document.createElement_x(\"label\") ;\n        $(lab).html(\"OK\") ;\n        this.parentNode.insertBefore(lab,this.nextSibling);\n    });\n});</code></pre>","rank_id":275,"createdAt":"2021-06-16T01:12:30.759Z","updatedAt":"2021-06-16T01:12:30.759Z","__v":0},{"_id":"60c9506e7d119d797cb7b765","title":"JavaScript 求数组中的最大值","code":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">求数组中的最大值&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">var ary=[1,2,3,5,7,90,3,6]</code>;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">有3种方法；可以使用Math.max函数</p>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">alert(Math.max.apply(null,a))</code>。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">知识点：将a作为参数传递，返回值为排序后的新数组，第一个参数为null因为不需要借用对象，此值可以忽略。</p>\n<pre class=\"language-javascript\"><code>var a = [3, 4, 6, 2, 9, 11, 4];\nvar maxNum = Math.max.apply(null, a);\nconsole.log(maxNum);//11</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">注意：a被当做参数传递进去，因为调用对象可以忽略，所以第一个参数为null,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Math.max.apply返回的是一个新值。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">还有一种方法是，先排序，然后头尾就是我们想要的；</p>\n<pre class=\"language-javascript\"><code>ary.sort(function(a,b){return a-b})\nconsole.log(ary[0]);\nconsole.log(ary[ary.length-1]);</code></pre>","rank_id":276,"createdAt":"2021-06-16T01:14:22.237Z","updatedAt":"2021-06-16T01:14:22.237Z","__v":0},{"_id":"60c950f47d119d797cb7b766","title":"JavaScript 数组去重","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">数组去重，注意3和\"3\"的两种类型，还可以引申到有对象类型时的去重；（如果不新建新的数组，该怎么写？）</span></p>\n<h2 id=\"第1种\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">第1种</h2>\n<pre class=\"language-javascript\"><code>Array.prototype.distinct = function () {\n  var a = this;\n  for (let index = 0; index &lt; a.length - 1; index++) {\n    for (let i = index + 1; i &lt; a.length;) {\n      if (a[index] == a[i]) {\n        a.slice(i, 1);\n      } else {\n        i++\n      }\n    }\n  }\n  return a;\n}</code></pre>\n<h2 id=\"第二种写法这种的最好\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">第二种写法,这种的最好</h2>\n<pre class=\"language-javascript\"><code>var arr = [3, 2, 3, 1, 4, true, false, \"3\", \"22\", \"2\", 2]\nfunction norepeat (arr) {\n  var resArr = [];\n  var obj = {};\n  for (var i = 0, len = arr.length; i &lt; len; i++) {\n    if (!(obj[arr[i] + typeof arr[i]])) {\n      resArr.push(arr[i]);\n      obj[arr[i] + typeof arr[i]] = 1;\n    }\n  }\n  return resArr;\n}\nvar res = norepeat(arr);\nconsole.log(res);</code></pre>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">第三种写法</h2>\n<pre class=\"language-javascript\"><code>function noRepeat (arr) {\n  var obj = {}\n  for (var i = 0, len = arr.length; i &lt; len; i++) {\n    var cur = arr[i];\n    if (obj[cur] == cur) {\n      arr.splice(i, 1);\n      i--;\n      continue;\n    }\n    obj[cur] = cur;\n  }\n  return = null;\n}</code></pre>\n<h2 id=\"第三种写法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":277,"createdAt":"2021-06-16T01:16:36.037Z","updatedAt":"2021-06-16T01:16:36.037Z","__v":0},{"_id":"60c9512b7d119d797cb7b767","title":"JavaScript 计算出班级的平均分","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>funtion average(){\n  var a = arguments;\n  [].sort.call(a, function (a, b) {\n    return a - b\n  });\n  [].pop.call(a);\n  [].shift.call(a);\n  var count = null;\n  var count = eval([].join.call(a, \"+\"));\n  return count / a.length;\n}\nvar sore = average(45, 56, 23, 18, 90, 100)</code></pre>","rank_id":278,"createdAt":"2021-06-16T01:17:31.292Z","updatedAt":"2021-06-16T01:17:31.292Z","__v":0},{"_id":"60c951ae7d119d797cb7b768","title":"JavaScript 写出你知道的数组的方法和属性","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul>\n<li style=\"padding: 0px; margin: 0px;\">var a=new Array;</li>\n<li style=\"padding: 0px; margin: 0px;\">a.concat(arr1,&hellip;,arryN);\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">//将arr1&hellip;arryN数组与a合并成一个新数组返回，原数组不变。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">a.join(',');\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">//将数组a中各项以逗号（,）拼接成一个字符串返回</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">a.push(value)\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">//将value追加到a最后一项，a.length自动加1</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">a.pop();\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">//删除a数组最后一项，a.length自动减1</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">a.unshift(val);\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">//在a第0项插入val值，原数据项向后移位,a.length自动加1</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">a.shift();\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">//删除a第0项，a.length自动减1</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">a.reverse()\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">//将a中数据反转</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">a.slice(indexA,indexB);\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">//复制索引从indexA到indexB-1为一个新数组，原数组不变,不包括indexB项，通常这种传入2个索引的方法，第二个参数都不参与运算，indexB-1参与运算。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">a.sort()\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">//对a进行排序，但排序是按照ASCII表排序，会将13排在2前面。如果想按照正常排序，如下：\n<pre class=\"language-javascript\"><code> var a = [5, 67, 1, 2, 4];\na.sort(function (x, y) {\n  return x - y;\n})\nconsole.log(a);</code></pre>\n</li>\n</ul>\n</li>\n<li>splice(index,count,ele1,&hellip;,ele2);\n<ul>\n<li>//index是起始索引，count表示从index开始要删除的个数，后面的参数表示从index开始插入的值，例如：\n<pre class=\"language-javascript\"><code>var a = [5, 67, 1, 2, 4];\na.splice(1, 2, 88, 99);\nconsole.log(a);</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">改变原数组的方法：pop()、push()、reverse()、shift()、sort()、splice()、unshift()</li>\n<li style=\"padding: 0px; margin: 0px;\">不改变原数组的方法：concat()、join()、slice()、toString()</li>\n</ul>","rank_id":279,"createdAt":"2021-06-16T01:19:42.801Z","updatedAt":"2021-06-16T01:19:42.801Z","__v":0},{"_id":"60c951e87d119d797cb7b769","title":"JavaScript 数组按照从大到小的顺序排序","code":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">数组按照从大到小的顺序排序；</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">var arr=['90px','100px','10px','45px','30px']</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">;</span></p>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var arr = ['90px', '100px', '10px', '45px', '30px'];\narr.sort(function (a, b) {\n  a = parseInt(a);\n  b = parseInt(b);\n  return a - b;\n})</code></pre>","rank_id":280,"createdAt":"2021-06-16T01:20:40.231Z","updatedAt":"2021-06-16T01:20:40.231Z","__v":0},{"_id":"60c956f67d119d797cb7b76a","title":"JavaScript 请把这个数组里面的数字替换成中文","code":"<pre class=\"language-javascript\"><code>var arr=['壹','贰',3,4,'伍']</code></pre>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var a = ['零','壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖', '拾', '佰', '仟', '万', '亿'];\nvar arr = ['壹', '贰', 3, 4, '伍'];\nvar ss = arr.toString().replace(/\\d/g, function (n) {\n  return a[n];\n})\nconsole.log(ss);</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">同类题：将112299转换成中文：</span></p>\n<pre class=\"language-javascript\"><code>var a = ['零','壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖', '拾', '佰', '仟', '万', '亿'];\nvar n = 112299;\nvar str = n.toString().replace(/\\d/g, function (n) {\n  return a[n];\n})\nconsole.log(str);</code></pre>","rank_id":281,"createdAt":"2021-06-16T01:42:14.363Z","updatedAt":"2021-06-16T01:42:14.363Z","__v":0},{"_id":"60c9577d7d119d797cb7b76b","title":"JavaScript 删除数组中的第m项到第n项，用什么方法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var a = [1, 2, 5, 6, 7, 8, 9];\nconsole.log(dele(a, 1, 3));\nfunction dele (a, m, n) {\n  a.splice(m, n - m + 1);\n  return a;\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">知识点</span></p>\n<pre class=\"language-javascript\"><code>splice(index,count,ele1,...,ele2);//index是起始索引，count表示从index开始要删除的个数，后面的参数表示从index开始插入的值</code></pre>","rank_id":282,"createdAt":"2021-06-16T01:44:29.102Z","updatedAt":"2021-06-16T01:44:29.102Z","__v":0},{"_id":"60c957a37d119d797cb7b76c","title":"JavaScript 转化一个数字数据为function数组","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">知识点：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">为数组原型增加方法。</li>\n</ol>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\" start=\"2\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">迭代数组，每项值改为一个function本身，外界通过索引和（）就可以调用该function\n<pre class=\"language-javascript\"><code>var arr = [3, 5, 12, 55, 12, 321, 41, 0, 999];\nArray.prototype.toFunction = function () {\n  for (let index = 0; index &lt; this.length; index++) {\n    this[i] = (function (a) {\n      return function () {\n        return a;\n      }\n    })(this[i])\n  }\n  return this;\n}\narr.toFunction();\nconsole.log((arr[0])())</code></pre>\n</li>\n</ol>\n</li>\n</ul>","rank_id":283,"createdAt":"2021-06-16T01:45:07.902Z","updatedAt":"2021-06-16T01:45:07.902Z","__v":0},{"_id":"60c9583f7d119d797cb7b76d","title":"JavaScript 给Object数组进行排序","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var obj1 = { att1: 0, attr2: 0, att3: 0, att4: 0 };\nvar obj1 = { att1: 0, attr2: 0, att3: 0, att4: 0, att5: 0 };\nvar obj1 = { att1: 0, attr2: 0, att3: 0, att4: 0, att5: 0, att6: 0 };\nvar aObjs = [obj1, obj2, obj3];\naObjs.sort(function () {\n  for (let index = 0; index &lt; 2; index++) {\n    arguments[i].length = 0;\n    for (const key in arguments[i]) {\n      if (arguments[i].hasOwnProperty(key)) {\n        arguments[i].length++;\n      }\n    }\n  }\n  return arguments[0].length - arguments[1].length;\n})\nconsole.log(aObjs);</code></pre>","rank_id":284,"createdAt":"2021-06-16T01:47:43.481Z","updatedAt":"2021-06-16T01:47:43.481Z","__v":0},{"_id":"60c958c47d119d797cb7b76e","title":"JavaScript 在10000下不重复的数字中随机抽取5000不重复样本，多次操作获得的不同结果","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">1、第一种是最耗费性能的方法是每次去除的数字都要通过循环或者indexOf判断是否在新的数组中；</li>\n<li style=\"padding: 0px; margin: 0px;\">2、第二个是从10000个数字中随机取一个，放到一个新的数组中，然后删除这个数字；这样5000次都能保证都不重复；</li>\n<li style=\"padding: 0px; margin: 0px;\">3、数组去重的思想，将10000个数字都当成对象的下标，但是占用内存太多；</li>\n<li style=\"padding: 0px; margin: 0px;\">4、最佳方案是从10000个数字中随机取出一个，然后把数组最后一个元素填充到取出的空缺处；这样数组长度编程9999，进行5000次即可完成题目的要求；看似用aplice删除数组中的一项挺容易的；为什么要数组最后一个元素填补到随机取出的空缺呢？这个涉及到内存的知识，假设你随机去到的是第10个数字，用splice删除第10个数字，那么实际上计算机会把后面9990个数字都向前移动一个单位；导致时间复杂度特别高；\n<pre class=\"language-javascript\"><code>var ary = [];//储存很多项目的数组\nvar newAry = [];//把需要获取的项储存到这个空数组里面；\nfor (var i = o; i &lt; 5000; i++) {\n  var ran = Math.round(Math.random() * (ary.length - 1));\n  newAry.push(ary[ran]);\n  ary[ran] = ary[ary.length - 1];//最后一项放到当前要删除的项目；\n  ary.length = ary.length - 1;//删除最后一项；\n}\nconsole.log(newAry);</code></pre>\n</li>\n</ul>","rank_id":285,"createdAt":"2021-06-16T01:49:56.323Z","updatedAt":"2021-06-16T01:49:56.323Z","__v":0},{"_id":"60c959087d119d797cb7b76f","title":"JavaScript 1--100000个数字，丢了两个数后打乱顺序怎么找到丢的两个数字？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">1、第一个想到的是先排序，然后遍历一遍，但是排序是复杂度最高的方法；</li>\n<li style=\"padding: 0px; margin: 0px;\">2、用遍历，用二分的思想去找；</li>\n<li style=\"padding: 0px; margin: 0px;\">3、数组去重的思路去做；把9999个数字作为一个对象的键值；然后做一个1&mdash;100000的遍历就能找到了；数组去重的思想一定要深刻理解；</li>\n</ul>","rank_id":286,"createdAt":"2021-06-16T01:51:04.773Z","updatedAt":"2021-06-16T01:51:04.773Z","__v":0},{"_id":"60c959627d119d797cb7b770","title":"JavaScript 为数组添加方法indexOf（value），使得下列调用可成功运行","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var arr=[1,2,3,4,5]\nvar index=arr.indexOf(3)</code></pre>","rank_id":287,"createdAt":"2021-06-16T01:52:34.578Z","updatedAt":"2021-06-16T01:52:34.578Z","__v":0},{"_id":"60c9598f7d119d797cb7b771","title":"JavaScript 有一个数组，其中保存的都是小写英文字符串，现在要把它按照除了第一个字母外的字符的字典顺序排序","code":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">有一个数组，其中保存的都是小写英文字符串，现在要把它按照除了第一个字母外的字符的字典顺序(字典顺序就是按首字母从 a-z 顺序排列，如果首字母相同则按第二个字母&hellip;&hellip;)排序，请编写代码</span></p>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var selector = function (x, y) {\n  if (typeof x == 'string' &amp; typeof y == 'string') {\n    var a = x.slice(1);\n    var b = y.slice(1);\n    if (a &gt; b) {\n      return 1\n    } else if (a &lt; b) { return -1; }\n    else { return 0; }\n  }\n}\nvar arr = [];\narr.sort(selector)</code></pre>","rank_id":288,"createdAt":"2021-06-16T01:53:19.601Z","updatedAt":"2021-06-16T01:53:19.601Z","__v":0},{"_id":"60c959e27d119d797cb7b772","title":"JavaScript 返回一个合并过的数组","code":"<pre class=\"language-javascript\"><code>var a = [-3,-1,0,1,3,5,7,9],\n    b = [-4,-2,0,2,3,4,5,6,7,8];\n//返回一个合并过的数组\n[-4,-3,-2,-1,0,0,1,2,3,3,4,5,5,6,7,7,8,9]</code></pre>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">数组相加后，数组去重，然后数组排序</span></p>","rank_id":289,"createdAt":"2021-06-16T01:54:42.816Z","updatedAt":"2021-06-16T01:54:42.816Z","__v":0},{"_id":"60c95a0b7d119d797cb7b773","title":"JavaScript js对象的深度克隆","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function clone (Obj) {\n  var buf;\n  if (Obj instanceof Array) {\n    buf = [];  //创建一个空的数组 \n    var i = Obj.length;\n    while (i--) {\n      buf[i] = clone(Obj[i]);\n    }\n    return buf;\n  } else if (Obj instanceof Object) {\n    buf = {};  //创建一个空对象 \n    for (var k in Obj) {  //为这个对象添加新的属性 \n      buf[k] = clone(Obj[k]);\n    }\n    return buf;\n  } else {\n    return Obj;\n  }\n}</code></pre>","rank_id":290,"createdAt":"2021-06-16T01:55:23.165Z","updatedAt":"2021-06-16T01:55:23.165Z","__v":0},{"_id":"60c95a3b7d119d797cb7b774","title":"JavaScript 字符串的常用方法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul>\n<li>charAt 获取指定索引位置的字符</li>\n<li>charCodeAt 获取指定索引位置的字符对应的ASCII码值</li>\n<li>indeof/lasrIndexof 获取某个字符串在第一次（最后一次）出现位置的索引，没有的话返回-1，我们通常用这个来检测字符串中是否包含某一个字符；</li>\n<li>toUpperCase/tolowerCase将字符串中的字母转大写|小写；</li>\n<li>split按照指定的分隔符，讲一个字符串拆分成数组，和数组的join对应；</li>\n<li>substr：substr(n,m)从索引n开始截取m个字符，把截取字符返回一个新的字符串；</li>\n<li>substring：substring(n,m)从索引n开始截取到索引m处（不包含m），将找到的字符返回成一个新的字符串；</li>\n<li>slice：slice(n，m)和substring的用法和意思一样，只是slice可以支持负数作为索引，出现负数索引的时候，用字符串的长度+负数索引，例如：ary.slice(-6,-2)，其实是ary.slice(ary.length-6,ary.length-2)</li>\n<li>上面三个方法，如果只写一个n，都是默认截取到字符串末尾的位置；</li>\n<li>Replace：replace(&ldquo;要替换的老字符&rdquo;,&ldquo;替换成的新字符&rdquo;)字符串中字符替换的方法，可以应用正则来统一的进行替换，在正则中我们会详细的讲解replace的强大应用；</li>\n<li>Match：把所有和正则匹配到的内容都进行捕获（不能捕获小分组中的内容）</li>\n<li>trim： 去掉字符串中末尾位置的空白字符（不兼容）</li>\n</ul>","rank_id":291,"createdAt":"2021-06-16T01:56:11.721Z","updatedAt":"2021-06-16T01:56:11.721Z","__v":0},{"_id":"60c95a507d119d797cb7b775","title":"JavaScript 字符串方法indexOf和lastIndexOf的功能是什么？有什么区别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">indexOf()</code>&nbsp;从前向后检索，返回某个指定的字符串值在字符串中首次出现的位置。</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">lastIndexOf()</code>&nbsp;从后向面检索，返回某个指定的字符串值在字符串中首次出现的位置，输出正向索引。</li>\n</ul>","rank_id":292,"createdAt":"2021-06-16T01:56:32.894Z","updatedAt":"2021-06-16T01:56:32.894Z","__v":0},{"_id":"60c95a7c7d119d797cb7b776","title":"JavaScript 字符串方法substr和substring的功能是什么？有什么区别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">都表示截取字符串。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">s.substring(starIndex,endIndex);</code></li>\n<li style=\"padding: 0px; margin: 0px;\">starIndex为起始索引，结束索引为endIndex-1，返回一个信变量，注意：不包括endIndex。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">s.substr(starIndex,length);\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">starIndex为起始索引，截取长度为length,返回一个新变量。\n<pre class=\"language-javascript\"><code>starIndex为起始索引，截取长度为length,返回一个信变量。\nvar str = 'abcdefg';\nvar b = str.substring(1, 3);\nconsole.log(b);//bc\nb = str.substr(1, 3);\nconsole.log(b);//bcd</code></pre>\n</li>\n</ul>\n</li>\n</ul>","rank_id":293,"createdAt":"2021-06-16T01:57:16.192Z","updatedAt":"2021-06-16T01:57:16.192Z","__v":0},{"_id":"60c95b547d119d797cb7b777","title":"请编写一个JavaScript函数，parseQueryStr，它的用途是把URL参数解析为一个对象","code":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">用法如：</span></p>\n<pre class=\"language-javascript\"><code>var obj=parseQueryStr(url);</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">例如</span></p>\n<pre class=\"language-javascript\"><code>url=www.taobao.fm?name=zhu&amp;age=26;</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">则obj的值为</span></p>\n<pre class=\"language-javascript\"><code>{name：zhu,age：26}</code></pre>\n<p>&nbsp;</p>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">split()</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\"> 方法用于把一个字符串按照指定字符（？）分割成字符串数组。</span></p>\n<pre class=\"language-javascript\"><code>var str = 'url=www.taobao.fm?name=zhu&amp;age=26'\nfunction parseQueryStr (str) {\n  var obj = {};\n  var aCourse = str.split(\"?\")[1].split(\"&amp;\");\n  for (let index = 0; index &lt; aCourse.length; index++) {\n    const currCou = aCourse[index].split(\"=\");\n    obj[currCou[0]] = currCou[1];\n  }\n  return obj\n}\nconsole.log(parseQueryStr(str))</code></pre>","rank_id":294,"createdAt":"2021-06-16T02:00:52.421Z","updatedAt":"2021-06-16T02:00:52.421Z","__v":0},{"_id":"60c95b7b7d119d797cb7b778","title":"JavaScript String中写一个方法trim，要求能够去除一个字符串开始和结尾的空格","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>String.prototype.trim = function () {\n  var reg = /^\\s+|\\s+&amp;/g;\n  return this.replace(reg, '');\n}</code></pre>","rank_id":295,"createdAt":"2021-06-16T02:01:31.392Z","updatedAt":"2021-06-16T02:01:31.392Z","__v":0},{"_id":"60c95cc97d119d797cb7b779","title":"JavaScript 字符串反转","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var str=\"1234567890\"\nvar resStr=str.split(\"\").reverse().join(\"\");\nconsole.log(revStr);</code></pre>","rank_id":296,"createdAt":"2021-06-16T02:07:05.432Z","updatedAt":"2021-06-16T02:07:05.432Z","__v":0},{"_id":"60c95cf97d119d797cb7b77a","title":"JavaScript 判断一个字符串中出现次数最多的字符；并统计此字符的个数","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var str = &ldquo;abcdefgaaaaaaddda&rdquo;;\nvar obj = {};\nvar arr = [];\nvar letter;\nfor(var i = 0,len = str.length;i&lt;len;i++){\n   letter = str[i];\n   if(!obj[letter]){\n     obj[letter] = 1;\n   }else{\n     obj[letter]++;\n   }\n}\nvar max_key,max_num=0;\nfor(key in obj){\n   if(max_num &lt;obj[key]){\n     max_num = obj[key];\n     max_key = key;\n   }\n};    \ndocument.write(&ldquo;字母：&rdquo;+max_key+&rdquo;　次数：&rdquo;+max_num);</code></pre>","rank_id":297,"createdAt":"2021-06-16T02:07:53.403Z","updatedAt":"2021-06-16T02:07:53.403Z","__v":0},{"_id":"60c95ded7d119d797cb7b77b","title":"JavaScript 实现千位分隔符方法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function commafy (num) {\n  num = num + '';\n  var reg = /(-?d+)(d{3})/;\n  if (reg.test(num)) {\n    num = num.replace(reg, '$1,$2');\n  }\n  return num;\n}</code></pre>","rank_id":298,"createdAt":"2021-06-16T02:11:57.559Z","updatedAt":"2021-06-16T02:11:57.559Z","__v":0},{"_id":"60c95e6e7d119d797cb7b77c","title":"JavaScript 写一个字符串转成驼峰的方法，o_div_style_position转成oDivStylePosotion","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">方法一：</span></p>\n<pre class=\"language-javascript\"><code>var str = 'border-bottom-color';\nvar strRg = str.replace(/\\-[a-z]/g, function (params) {\n  return params.charAt(1).toUpperCase();\n})\nconsole.log(strRg);</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">注意：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">1)<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">charAt(1)</code>也可以用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">substr(1)</code>、<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">substring(1)</code>来替代。</li>\n<li style=\"padding: 0px; margin: 0px;\">2)<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">toUpperCase()</code>转换成大写字母。</li>\n<li style=\"padding: 0px; margin: 0px;\">3)<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">/\\-[a-z]/g</code>中g表示全文检索，part表示匹配到的字符</li>\n<li style=\"padding: 0px; margin: 0px;\">4)replace是字符串的方法，返回经过修改的新字符串。</li>\n</ul>\n<p>方法二：</p>\n<pre class=\"language-javascript\"><code>var str = 'border-bottom-color';\nvar aNew = [];\naNew = str.split('-');\nfor (let index = 0; index &lt; aNew.length; index++) {\n  if (index != 0) {\n    aNew[index] = aNew[index].substr(0, 1).toUpperCase() + aNew[index].substr(1);\n  }\n}\nstr = aNew.join('');\nconsole.log(str);</code></pre>","rank_id":299,"createdAt":"2021-06-16T02:14:06.985Z","updatedAt":"2021-06-16T02:14:06.985Z","__v":0},{"_id":"60c95eb97d119d797cb7b77d","title":"JavaScript 查找字符串中出现最多字符的个数","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">例如：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">sdjksfssscfssdd</code>&nbsp;-&gt;字符最多的是s，出现了7次</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">方法一：</p>\n<pre class=\"language-javascript\"><code>var str = 'sdjksfssscfssdd';\nvar maxObj = { key: null, count: null };\nvar maxCou = 0;\nwhile (str) {\n  var i = 0;\n  var reg = new RegExp(str[0], 'g');\n  var currStr = str[0];\n  str = str.replace(reg, function (part) {\n    i++;\n    return '';\n  })\n  if (i &gt; maxCou) {\n    maxObj.key = currStr;\n    maxCou = maxObj.count = i;\n  }\n}\nconsole.log(maxObj.key + ':' + maxObj.count)</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">方法二：</span></p>\n<pre class=\"language-javascript\"><code>var str2 = 'sdjksfssscfssdd';\nvar obj = {};\nvar aNew = str2.split('');\nfor (let index = 0; index &lt; aNew.length; index++) {\n  const val = aNew[index];\n  if (typeof obj[val] !== 'undefined') {\n    obj[val]++;\n  } else {\n    obj[val] = 1;\n  }\n}\nvar maxObj = { key: null, count: null };\nfor (const key in obj) {\n  var curr = obj[key];\n  if (curr &gt; maxObj.count) {\n    maxObj.count = curr;\n    maxObj.key = key;\n  }\n}\nconsole.log(maxObj.key + ':' + maxObj.count);</code></pre>","rank_id":300,"createdAt":"2021-06-16T02:15:21.230Z","updatedAt":"2021-06-16T02:15:21.230Z","__v":0},{"_id":"60c95ee37d119d797cb7b77e","title":"JavaScript 去除字符串中连续重复的地方","code":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">JavaScript 把12233435566690中连续重复的数字去掉</span></p>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">判断是否为空字符串，是就直接返回；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不是的话</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">初始字符串为str第一个，从第二个开始，如果不等于他们前一个的字符，代表不重复，加入初始字符，迭代进行，直到最后一个，返回</p>\n<pre class=\"language-javascript\"><code>function removeRepetition (str) {\n  if (str != '') {\n    var result = str[0];\n    for (var i = 1; i &lt; str.length; i++) {\n      if (str[i] != str[i - 1]) {\n        result += str[i];\n      }\n    }\n  }\n  else result = '';\n  return result;\n}</code></pre>","rank_id":301,"createdAt":"2021-06-16T02:16:03.307Z","updatedAt":"2021-06-16T02:16:03.307Z","__v":0},{"_id":"60c95f577d119d797cb7b77f","title":"JavaScript 用js实现千位分隔符?例如123456789-->123,456,789","code":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">JavaScript 用js实现千位分隔符?</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">例如<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">123456789</code>&ndash;&gt;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">123,456,789</code></p>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">方法一</h2>\n<pre class=\"language-javascript\"><code>var str = '123456789';\nvar reg = /^([1-9]\\d{0,2})((?:\\d{3})+)$/;\nvar s = str.replace(reg, function () {\n  return RegExp.$1 + ',' + RegExp.$2.match(/\\d{3}/g);\n})\nconsole.log(s);//123,456,789</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">知识点</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">将第一个逗号前面的数字作为第一组，后面所有数字为第二组，第二组是由多个三位的数字组合而成的，整体需要匹配捕获，但是每个三位数不需要匹配捕获所以加？：。</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">RegExp.$1</code>获取第一个分组，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">RegExp.$2</code>获取第二个分组。</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">match</code>返回匹配到的数据，是数组类型。</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">注意：IE10中直接调用分组不识别，需要在此前调用test方法：</p>\n<pre class=\"language-javascript\"><code>var str = '123456789';\nvar reg = /^([1-9]\\d{0,2})((?:\\d{3})+)$/;\nif (reg.test(str)) {\n  var s = str.replace(reg, function () {\n    return RegExp.$1 + ',' + RegExp.$2.match(/\\d{3}/g);\n  })\n}\nconsole.log(s);//123,456,789</code></pre>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">方法二</h2>\n<pre class=\"language-javascript\"><code>var count = 0;\nvar strNew = '';\nvar str1 = '60123761';\nfor (let i = str1.length; i &gt;= 0; i--) {\n  if (count % 3 === 0 &amp;&amp; count != 0) {\n    strNew += ',';\n  }\n  strNew += str1.substr(i, 1);\n  count++;\n}\nstrNew = strNew.split('').reverse().join('');\nconsole.log(strNew);</code></pre>\n<h2 id=\"方法二\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>\n<h2 id=\"方法一\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":302,"createdAt":"2021-06-16T02:17:59.668Z","updatedAt":"2021-06-16T02:17:59.668Z","__v":0},{"_id":"60c95fb47d119d797cb7b780","title":"JavaScript 写一个正则表达式判断字符串是否是对称数","code":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">JavaScript 写一个正则表达式判断字符串是否是对称数</span></p>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var str = 'Woow';\nvar reg = /^([a-z])([a-z])\\2\\1$/i;\nif (reg.test(str)) {\n  console.log('ok')\n}</code></pre>","rank_id":303,"createdAt":"2021-06-16T02:19:32.215Z","updatedAt":"2021-06-16T02:19:32.215Z","__v":0},{"_id":"60c9604a7d119d797cb7b781","title":"JavaScript 正则验证，当下面的这个表单提交的时候，输入框中不能为空，如果有空格必须把空格去掉，必须是合法的手机号","code":"<pre class=\"language-markup\"><code>&lt;form action=\"\" id=\"form1\" method=\"get\"&gt;\n  电话号码：&lt;input type=\"text\" value=\"输入电话号码\" id=\"mobi\" name=\"\"/&gt;\n  &lt;input type=\"submit\" name=\"\"/&gt;\n&lt;/form&gt;</code></pre>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var form1 = document.getElementById('form1');\nform1.onsubmit = function () {\n  var mobi = document.getElementById('mobi');\n  var reg = /^1\\d{10}$/;\n  if (reg.test(mobi.value.replace(/ /g, ''))) {\n    console.log('ok');\n  } else {\n    console.log('error');\n    return false;\n  }\n</code></pre>","rank_id":304,"createdAt":"2021-06-16T02:22:02.691Z","updatedAt":"2021-06-16T02:22:02.691Z","__v":0},{"_id":"60c9608b7d119d797cb7b782","title":"JavaScript 判断字符串由数字和字母组成","code":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">JavaScript 写出一个正则表达式用于匹配由数字和大写字母组成的字符串</span></p>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function checkPassWord (nubmer) {\n  var re = /^[0-9a-zA-Z]*$/;  //判断字符串是否为数字和字母组合\n  if (!re.test(nubmer)) {\n    return false;\n  } else {\n    return true;\n  }\n}</code></pre>","rank_id":305,"createdAt":"2021-06-16T02:23:07.492Z","updatedAt":"2021-06-16T02:23:07.492Z","__v":0},{"_id":"60c960ac7d119d797cb7b783","title":"解释一下JavaScript的同源策略","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">它最早出自Netscape Navigator2.0，其目的是<strong>防止某个文档或脚本从多个不同源装载</strong>。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这里的同源策略指的是：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">协议</code>，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">域名</code>，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">端口</code>相同，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">同源策略是一种安全协议:指一段脚本只能读取来自同一来源的窗口和文档的属性。</p>","rank_id":306,"createdAt":"2021-06-16T02:23:40.932Z","updatedAt":"2021-06-16T02:23:40.932Z","__v":0},{"_id":"60c960e07d119d797cb7b784","title":"JavaScript 为什么要有同源限制","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">比如一个黑客程序，他利用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">iframe</code>&nbsp;把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">他的页面就可以通过<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Javascript</code>读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">是为了WEB端的安全考虑</p>","rank_id":307,"createdAt":"2021-06-16T02:24:32.512Z","updatedAt":"2021-06-16T02:24:32.512Z","__v":0},{"_id":"60c961847d119d797cb7b785","title":"JavaScript Ajax读取一个xml文档并进行解析的实例","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var xhr = new XMLHttpRequest;//-&gt;在IE7以下浏览器中是不兼容的\nxhr=new ActiveXObject(\"Microsoft.XMLHTTP\");\nxhr=new ActiveXObject(\"Msxml2.XMLHTTP\");\nxhr=new ActiveXObject(\"Msxml3.XMLHTTP\");</code></pre>\n<pre class=\"language-javascript\"><code>//-&gt;惰性思想\nvar getXHR = (function () {\n  //-&gt;存放我们需要的几个获取Ajax对象的方法\n  var ajaxAry = [\n    function () {\n      return new XMLHttpRequest;\n    },\n    function () {\n      return new ActiveXObject(\"Microsoft.XMLHTTP\");\n    },\n    function () {\n      return new ActiveXObject(\"Msxml2.XMLHTTP\");\n    },\n    function () {\n      return new ActiveXObject(\"Msxml3.XMLHTTP\");\n    }\n  ];\n  //-&gt;循环数组,把四个方法依次的执行\n  var xhr = null;\n  for (var i = 0; i &lt; ajaxAry.length; i++) {\n    //-&gt;标准浏览器:i=0,获取的是第一个函数function(){return new XMLHttpRequest;}(A1),执行的时候没有报错,\n    //xhr是它的返回值也是我们的Ajax对象,没有报错不会走catch,执行getXHR = A1,这样把外面的getXHR重写了,遇到break循环结束\n    //-&gt;IE6浏览器:i=0,获取第一个函数执行,IE6不支持XMLHttpRequest,所以会报错,执行catch中的continue继续下一次的循环,i=1,\n    //获取第二个函数 function(){return new ActiveXObject(\"Microsoft.XMLHTTP\");}(A2),执行没有报错,那么开始执行getXHR = A2,\n    //遇到break结束整个循环,此时外面的getXHR = A2\n    var tempFn = ajaxAry[i];\n    try {\n      xhr = tempFn();\n    } catch (e) {\n      continue;\n    }\n    getXHR = tempFn;\n    break;\n  }\n  if (!xhr) {\n    throw new Error(\"你的浏览器版本也太LOW了吧,还能不能愉快的玩耍~~\");\n  }\n  return getXHR;\n})();\nvar xhr = getXHR();\nxhr.open(\"get\", \"test.txt?_=\" + Math.random(), true);\nxhr.onreadystatechange = function () {\n  if (xhr.readyState === 4 &amp;&amp; /^2\\d{2}$/.test(xhr.status)) {\n    var val = xhr.responseText;\n    console.log(val);\n  }\n};\nxhr.send(null);</code></pre>\n<h2 id=\"避免返回的数据是乱码的\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">避免返回的数据是乱码的</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">-&gt;前端页面是UTF-8编码,如果我们从服务器请求回来的数据不是UTF-8编码格式,那么获取到的内容中,中文汉字会出现乱码</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">-&gt;需要我们使用\"UTF-8到底的原则\":前端页面、JS、CSS、后台代码、数据库、请求传递的数据统一都采用一个编码UTF-8</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">-&gt;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">[RESPONSE]</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Content-Type:text/plain</code>(纯文本)、<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">application/json</code>(JSON格式的)&hellip;设定响应主体中内容的格式</p>\n<h2 id=\"前端设置请求头获取响应头\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">前端：设置请求头,获取响应头</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">-&gt;在前端的JS中我们可以使用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">xhr.setRequestHeader([name],[value])</code>&nbsp;设置请求头的信息；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可以使用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">xhr.getResponseHeader([name])/xhr.getAllResponseHeaders()</code>&nbsp;获取响应头信息；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">服务器端：获取请求头,设置响应头</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">-&gt;在NODE中我们可以使用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">response.writeHead(200, {'content-type': 'application/json'})</code>; 设置响应头信息</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">-&gt;在NODE中我们可以使用 request 这个对象获取到请求信息(起始行、首部、主体) 中的都可以获取到</p>","rank_id":308,"createdAt":"2021-06-16T02:27:16.615Z","updatedAt":"2021-06-16T02:27:16.615Z","__v":0},{"_id":"60c961a87d119d797cb7b786","title":"JavaScript Ajax是什么？ajax的交互模型？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">ajax是什么？</li>\n</ol>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">通过异步模式，提升了用户体验</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">2.） Ajax的最大的特点是什么。</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">Ajax可以实现动态不刷新（局部刷新）</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">readyState属性 状态 有5个可取值： 0=未初始化 ，1=启动 2=发送，3=接收，4=完成</li>\n</ol>\n<h2 id=\"经典总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">经典总结</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">ajax的全称：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Asynchronous Javascript And XML</code>。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">异步传输 + js + xml</code>。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象</li>\n<li style=\"padding: 0px; margin: 0px;\">(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li>\n<li style=\"padding: 0px; margin: 0px;\">(3)设置响应HTTP请求状态变化的函数</li>\n<li style=\"padding: 0px; margin: 0px;\">(4)发送HTTP请求</li>\n<li style=\"padding: 0px; margin: 0px;\">(5)获取异步调用返回的数据</li>\n<li style=\"padding: 0px; margin: 0px;\">(6)使用JavaScript和DOM实现局部刷新</li>\n</ul>","rank_id":309,"createdAt":"2021-06-16T02:27:52.786Z","updatedAt":"2021-06-16T02:27:52.786Z","__v":0},{"_id":"60c962477d119d797cb7b787","title":"jQuery 如何创建一个Ajax","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>//-&gt;Ajax\n$.ajax({\n    url: \"test.txt?_=\" + Math.random(),\n    type: \"get\",\n    dataType: \"json\",//-&gt;text获取的是一个字符串 json获取的是一个对象\n    success: function (data) {\n        console.log(data);\n        //-&gt;解析数据和实现数据绑定都可以继续在这个方法中去操作了\n    }\n});\n//-&gt;JSONP\n$.ajax({\n    url: \"http://matchweb.sports.qq.com/kbs/list?columnId=100000&amp;startTime=2016-02-28&amp;endTime=2016-03-05&amp;_=\" + Math.random(),\n    type: \"get\",\n    dataType: \"jsonp\",\n    success: function (data) {\n        console.log(data);\n    }\n});</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">使用jQuery的JSONP请求,我们不需要自己在URL后面加callback,也不需要自己事先写一个方法传给后台,因为jQuery把这些事情都帮我们做了,它默认在URL的末尾增加一个callback=,会自己随机创建一个函数</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">jQuery1113026970771374180913_1456989781792,把这个函数传递给后台,后台也会把这个函数给执行了</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">success对应的那个匿名函数其实可以理解为就是随机创建的这个函数,data其实就是我们想要获取的数据</p>\n<pre class=\"language-javascript\"><code>//http://matchweb.sports.qq.com/kbs/list?columnId=100000&amp;startTime=2016-02-28\n//&amp;endTime=2016-03-05&amp;_=1456989781793&amp;callback=jQuery1113026970771374180913_1456989781792\n$.ajax({\n  url: \"http://matchweb.sports.qq.com/kbs/list?columnId=100000&amp;startTime=2016-02-28&amp;endTime=2016-03-05&amp;_=\" + Math.random(),\n  type: \"get\",\n  dataType: \"jsonp\",\n  jsonp: \"cb\",//-&gt;我们把callback这个名字也可以修改为自己想要的\n  jsonpCallback: \"wangHaoYu\",\n//-&gt;自己把callback后面传递的函数的名字修改为自己想要的名字,不使用自己随机生成的那个长名字\n  success: function (data) {\n    console.log(data);\n  }\n});\n//-&gt;....&amp;cb=wangHaoYu\n$.ajax({\n  url: \"test.txt?_=\" + Math.random(),\n  type: \"get\",\n  dataType: \"text\",\n  async: true,//默认就是true\n  success: function (data) {//-&gt;请求成功执行的方法,data就是服务器返回给前端的数据\n    console.log(data);\n  },\n  error: function (message) {//-&gt;请求失败执行的方法,message就是错误信息\n  }\n});</code></pre>","rank_id":310,"createdAt":"2021-06-16T02:30:31.416Z","updatedAt":"2021-06-16T02:30:31.416Z","__v":0},{"_id":"60c962b47d119d797cb7b788","title":"简述 JavaScript AJAX 的原理","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">简述 JavaScript AJAX 的原理</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">通过自己用js创建一个request对象发起请求，从而实现局部刷新，然后把ajax的那四步写上，大体描述一下就可以了</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">ajax是很多种技术的集合体。其中包括</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">浏览器的xmlHTTPRequest对象，他是负责为你开通另一条连接通道，可以传递信息。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">javascript：他是负责调用XMLHTTPRequest对象进行与后台交互的媒介。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">xml是一种数据格式，用于服务器应答传递信息的格式。除了xml外，还可以使用任何的文本格式，包括text，html，json等。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">使用CSS和XHTML来表示。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">使用DOM模型来交互和动态显示。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">使用XMLHttpRequest来和服务器进行异步通信。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">使用javascript来绑定和调用。</span></p>\n</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在上面几中技术中，除了<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">XmlHttpRequest</code>对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">所以我们先从XMLHttpRequest讲起，来看看它的工作原理。</span></p>\n<h2 id=\"xmlhttprequest-的属性\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">XMLHttpRequest 的属性</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">它的属性有：</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">onreadystatechange 每次状态改变所触发事件的事件处理程序。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">responseText 从服务器进程返回数据的字符串形式。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">responseXML 从服务器进程返回的DOM兼容的文档数据对象。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">status Text 伴随状态码的字符串信息</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">readyState 对象状态值</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">0</code>&nbsp;(未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">1</code>&nbsp;(初始化) 对象已建立，尚未调用send方法</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">2</code>&nbsp;(发送数据) send方法已调用，但是当前的状态及http头未知</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">3</code>&nbsp;(数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">4</code>&nbsp;(完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</span></li>\n</ul>\n</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">但是，由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这个差异主要体现在IE和其它浏览器之间。下面是一个比较标准的创建XMLHttpRequest对象的方法。</span></p>\n<pre class=\"language-javascript\"><code>function CreateXmlHttp () {\n  //非IE浏览器创建XmlHttpRequest对象\n  if (window.XmlHttpRequest) {\n    xmlhttp = new XmlHttpRequest();\n  }\n  //IE浏览器创建XmlHttpRequest对象\n  if (window.ActiveXObject) {\n    try {\n      xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    catch (e) {\n      try {\n        xmlhttp = new ActiveXObject(\"msxml2.XMLHTTP\");\n      }\n      catch (ex) { }\n    }\n  }\n}\nfunction Ustbwuyi () {\n  var data = document.getElementById(\"username\").value;\n  CreateXmlHttp();\n  if (!xmlhttp) {\n    alert(\"创建xmlhttp对象异常！\");\n    return false;\n  }\n  xmlhttp.open(\"POST\", url, false);\n  xmlhttp.onreadystatechange = function () {\n    if (xmlhttp.readyState == 4) {\n      document.getElementById(\"user1\").innerHTML = \"数据正在加载...\";\n      if (xmlhttp.status == 200) {\n        document.write(xmlhttp.responseText);\n      }\n    }\n  }\n  xmlhttp.send();\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">如上所示，函数首先检查XMLHttpRequest的整体状态并且保证它已经完成（readyStatus=4），即数据已经发送完毕。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">然后根据服务器的设定询问请求状态，如果一切已经就绪（status=200），那么就执行下面需要的操作。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">对于XmlHttpRequest的两个方法，open和send，其中open方法指定了：</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">a、向服务器提交数据的类型，即post还是get。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">b、请求的url地址和传递的参数。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">c、传输方式，false为同步，true为异步。默认为true。如果是异步通信方式(true)，客户机就不等待服务器的响应；如果是同步方式(false)，客户机就要等到服务器返回消息后才去执行其他操作。我们需要根据实际需要来指定同步方式，在某些页面中，可能会发出多个请求，甚至是有组织有计划有队形大规模的高强度的request，而后一个是会覆盖前一个的，这个时候当然要指定同步方式。</span></p>\n</li>\n</ul>\n<h2 id=\"send方法用来发送请求\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">Send方法用来发送请求</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">知道了XMLHttpRequest的工作流程，我们可以看出，XMLHttpRequest是完全用来向服务器发出一个请求的，它的作用也局限于此，但它的作用是整个ajax实现的关键，因为ajax无非是两个过程，发出请求和响应请求。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">并且它完全是一种客户端的技术。而XMLHttpRequest正是处理了服务器端和客户端通信的问题所以才会如此的重要。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">现在，我们对ajax的原理大概可以有一个了解了。我们可以把服务器端看成一个数据接口，它返回的是一个纯文本流，当然，这个文本流可以是XML格式，可以是Html，可以是Javascript代码，也可以只是一个字符串。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这时候，XMLHttpRequest向服务器端请求这个页面，服务器端将文本的结果写入页面，这和普通的web开发流程是一样的，不同的是，客户端在异步获取这个结果后，不是直接显示在页面，而是先由javascript来处理，然后再显示在页面。至于现在流行的很多ajax控件，比如magicajax等，可以返回DataSet等其它数据类型，只是将这个过程封装了的结果，本质上他们并没有什么太大的区别。</span></p>","rank_id":311,"createdAt":"2021-06-16T02:32:20.804Z","updatedAt":"2021-06-16T02:32:20.804Z","__v":0},{"_id":"60c962cf7d119d797cb7b789","title":"JavaScript AJAX 的优点","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Ajax的给我们带来的好处大家基本上都深有体会，在这里我只简单的讲几点：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">1、最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。</li>\n<li style=\"padding: 0px; margin: 0px;\">2、使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。</li>\n<li style=\"padding: 0px; margin: 0px;\">3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是&ldquo;按需取数据&rdquo;，可以最大程度的减少冗余请求，和响应对服务器造成的负担。</li>\n<li style=\"padding: 0px; margin: 0px;\">4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。</li>\n</ul>","rank_id":312,"createdAt":"2021-06-16T02:32:47.363Z","updatedAt":"2021-06-16T02:32:47.363Z","__v":0},{"_id":"60c963937d119d797cb7b78a","title":"JavaScript AJAX 的缺点","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">下面我着重讲一讲ajax的缺陷，因为平时我们大多注意的都是ajax给我们所带来的好处诸如用户体验的提升。而对ajax所带来的缺陷有所忽视。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">下面所阐述的ajax的缺陷都是它先天所产生的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>1、ajax干掉了back按钮，即对浏览器后退机制的破坏。</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>2、安全问题</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>3、对搜索引擎的支持比较弱。</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>4、破坏了程序的异常机制。</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。关于这个问题，我曾经在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来我自己做了一次试验，分别采用ajax和传统的form提交的模式来删除一条数据&hellip;&hellip;给我们的调试带来了很大的困难。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">**5、另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。**例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">6、一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的，当然，这个问题和我们没太多关系。</p>","rank_id":313,"createdAt":"2021-06-16T02:36:03.213Z","updatedAt":"2021-06-16T02:36:03.213Z","__v":0},{"_id":"60c963b77d119d797cb7b78b","title":"JavaScript AJAX 的几种框架","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<h2 id=\"jquery\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jQuery</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jQuery 是一个快速、简洁的JavaScript框架</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jQuery 是对原生XHR的封装，另外还增加了jsonp的支持，让ajax请求可以支持跨域请求，</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">但是要注意的是：jsonp请求本质不是XHR异步请求，就是请求了一个js文件，因此在浏览器的network面板中的xhr标签下看不到jsonp的跨域请求，但是在js标签下能看见，因为它利用src特性请求任何一个网站的资源。</span></p>\n<h2 id=\"axios\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">Axios</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">特性</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">从浏览器中创建 XMLHttpRequest</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">从 node.js 发出 http 请求</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">支持 Promise API</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">拦截请求和响应</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">转换请求和响应数据</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">取消请求</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">自动转换JSON数据</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">客户端支持防止 CSRF/XSRF</span></li>\n</ul>\n<h2 id=\"fetch\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">fetch</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">Fetch API 是近年来被提及将要取代XHR的技术新标准，是一个 HTML5 的 API。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">Fetch 并不是XHR的升级版本，而是从一个全新的角度来思考的一种设计。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">Fetch 是基于 Promise 语法结构，而且它的设计足够低阶，这表示它可以在实际需求中进行更多的弹性设计。对于XHR所提供的能力来说，Fetch 已经足够取代XHR，并且提供了更多拓展的可能性。</span></p>","rank_id":314,"createdAt":"2021-06-16T02:36:39.555Z","updatedAt":"2021-06-16T02:36:39.555Z","__v":0},{"_id":"60c963d87d119d797cb7b78c","title":"JavaScript AJAX 的过程是怎么样的","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象.</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">(2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">(3)设置响应HTTP请求状态变化的函数.</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">(4)发送HTTP请求.</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">(5)获取异步调用返回的数据.</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">(6)使用JavaScript和DOM实现局部刷新.</p>\n</li>\n</ul>","rank_id":315,"createdAt":"2021-06-16T02:37:12.930Z","updatedAt":"2021-06-16T02:37:12.930Z","__v":0},{"_id":"60c964487d119d797cb7b78d","title":"JavaScript XMLHttpRequest是什么、怎样完整地执行一次GET请求、怎样检测错误","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">　所以我们先从XMLHttpRequest讲起，来看看它的工作原理。</span></p>\n<h2 id=\"xmlhttprequest-属性\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">XMLHttpRequest 属性</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">它的属性有：</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">onreadystatechange 每次状态改变所触发事件的事件处理程序。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">responseText 从服务器进程返回数据的字符串形式。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">responseXML 从服务器进程返回的DOM兼容的文档数据对象。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">status Text 伴随状态码的字符串信息</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">readyState 对象状态值</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">1 (初始化) 对象已建立，尚未调用send方法</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">2 (发送数据) send方法已调用，但是当前的状态及http头未知</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据 但是，由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。下面是一个比较标准的创建XMLHttpRequest</span></p>\n<pre class=\"language-javascript\"><code>var xmlhttp;\nfunction loadXMLDoc (url) {\n  xmlhttp = null;\n  if (windows.XMLHttpRequest) {\n    xmlhttp = new XMLHttpRequest();\n  } else if (window.ActiveXObject) {\n    //For IE5 IE6\n    xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');\n  }\n  if (xmlhttp != null) {\n    xmlhttp.onreadystatechange = stateChange;\n    xmlhttp.open(\"GET\", url, true)\n    xmlhttp.send(null);\n  } else {\n    alert(\"不支持XMLHTTP\")\n  }\n}\nfunction stateChange () {\n  // 4 'load'\n  if (xmlhttp.readState == 4) {\n    // 200 'load'\n    if (xmlhttp.status == 200) {\n      //...\n    } else {\n      alert(\"problem retrieving XML data\")\n    }\n  }\n}</code></pre>\n</li>\n</ul>\n</li>\n</ul>","rank_id":316,"createdAt":"2021-06-16T02:39:04.783Z","updatedAt":"2021-06-16T02:39:04.783Z","__v":0},{"_id":"60c964b27d119d797cb7b78e","title":"JavaScript 如何得到HTTP的请求头信息和返回的头信息","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Javascript中跟response header有关的就两个方法：</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">getResponseHeader 从响应信息中获取指定的http头 语法</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">strValue = oXMLHttpRequest.getResponseHeader(bstrHeader);</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">getAllResponseHeaders 获取响应的所有http头 语法</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">strValue = oXMLHttpRequest.getAllResponseHeaders();</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">需要注意的是，通常，在IE下不能完整的获取header报头数据，只能取到如下header数据：</p>\n<pre class=\"language-javascript\"><code>X-Powered-By:\nX-UA-Compatible:\nKeep-Alive:\nTransfer-Encoding:\nContent-Type:</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">比如你要获取时间戳，在IE下必须做些特殊处理，需要在后端设置一下，关闭缓存：</p>\n<pre class=\"language-javascript\"><code>header( 'Cache-Control: no-store');</code></pre>\n<pre class=\"language-javascript\"><code>var req = new XMLHttpRequest();\nreq.open('GET', document.location, false);\nreq.send(null);\nvar header = req.getAllResponseHeaders().toLowerCase();\nconsole.log(Headers);</code></pre>","rank_id":317,"createdAt":"2021-06-16T02:40:50.110Z","updatedAt":"2021-06-16T02:40:50.110Z","__v":0},{"_id":"60c965007d119d797cb7b78f","title":"JavaScript 页面编码和被请求的资源编码如果不一致如何处理","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">比如：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">http://www.yyy.com/a.html</code>&nbsp;中嵌入了一个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">http://www.xxx.com/test.js</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">a.html 的编码是gbk或gb2312的。 而引入的js编码为utf-8的 ，那就需要在引入的时候</p>\n<pre class=\"language-markup\"><code>&lt;script src=\"http://www.xxx.com/test.js\" charset=\"utf-8\"&gt;&lt;/script&gt;</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">同理，如果你的页面是utf-8的，引入的js是gbk的，那么就需要加上</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">charset=\"gbk\"</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">.</span></p>","rank_id":318,"createdAt":"2021-06-16T02:42:08.283Z","updatedAt":"2021-06-16T02:42:08.283Z","__v":0},{"_id":"60c965217d119d797cb7b790","title":"JavaScript AJAX同步和异步的区别","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>同步</strong>：提交请求-&gt;等待服务器处理-&gt;处理完毕返回，这个期间客户端浏览器不能干任何事情；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>异步</strong>：请求通过事件触发-&gt;服务器处理（这时浏览器仍然可以作其他事情）-&gt;处理完毕</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Ajax.open方法中，第三个参数是设置同步或者异步的；</p>\n<h3 id=\"同步和异步的区别\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">同步和异步的区别；</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>同步</strong>：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>异步</strong>：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。</p>","rank_id":319,"createdAt":"2021-06-16T02:42:41.197Z","updatedAt":"2021-06-16T02:42:41.197Z","__v":0},{"_id":"60c965607d119d797cb7b791","title":"JavaScript GET和POST有何区别？何时使用post？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>GET</strong>：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>POST</strong>：一般用于修改服务器上的资源，对所发送的信息没有限制。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">GET方式需要使用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Request.QueryString</code>来取得变量的值，而POST方式通过<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Request.Form</code>来获取变量的值，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">然而，在以下情况中，请使用 POST 请求：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">无法使用缓存文件（更新服务器上的文件或数据库）</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">向服务器发送大量数据（POST 没有数据量限制）</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>\n</li>\n</ul>","rank_id":320,"createdAt":"2021-06-16T02:43:44.435Z","updatedAt":"2021-06-16T02:43:44.435Z","__v":0},{"_id":"60c965a27d119d797cb7b792","title":"JavaScript get为什么比post性能好，php/node都用一个东西接收post和get请求，怎么解释get比post性能好","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">如果你希望</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">请求中的URL可以被手动输入</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">请求中的URL可以被存在书签里，或者历史里，或者快速拨号里面，或者分享给别人。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">请求中的URL是可以被搜索引擎收录的。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">带云压缩的浏览器，比如Opera mini/Turbo 2, 只有GET才能在服务器端被预取的。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">请求中的URL可以被缓存。</span></p>\n</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">请使用GET.</span></p>\n<h3 id=\"http请求方式\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP请求方式</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">get 从服务器获取</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">post 向服务器发送</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">注册页面:用户填完信息,有很多的信息,我们把这些信息都获取到,然后通过Ajax中的POST请求,在请求主体中把这些信息都传递给后台服务器,服务器把这些信息存储到数据库中(&ldquo;表单提交&rdquo;)</span></li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">put 增加</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">delete 删除</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">head、options、trace、connection、track&hellip;</span></li>\n</ul>\n<h3 id=\"get系的特征getdeletehead\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">get系的特征(get、delete、head)</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">1、会把给服务器发送的数据放到url后面 -&gt;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">http://matchweb.sports.qq.com/kbs/hotMatchList?callback=getHotMatchList&amp;_=1456903174906</code>&nbsp;&ldquo;?后面写的内容都是同过get请求传递给服务器的&rdquo;</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">2、有大小限制</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">因为get系把数据都放到url里面，而浏览器会对url的长度有大小限制， 所以造成了get系对传输的数据大小有限制</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">ie-&gt;2K</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">firefox-&gt;7k</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">chrome-&gt;8k</span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">3、会被缓存(服务器和浏览器自带的缓存)</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">我们一般不用缓存,因为自带的缓存很多情况导致,第二次请求的内容一直和第一次一样,最新的内容请求不回来</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">如果想要快,我们做的所有的缓存都是自己单独用程序设计出来的而不是浏览器自带的缓存机制</span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">4、不安全,因为明文发送</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">在浏览器的控制台中我们可以查看到URL后面的参数值,所以不安全</span></li>\n</ul>\n<h3 id=\"post系postput\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">post系(post、put)</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">1、会把给服务器发送的数据放到请求主体里</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">2、不会有大小限制</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">因为post系把数据放到请求主体里，而请求主体是没有大小限制的</span></li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">3、永远不会被缓存</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">4、相对于get系安全许多,因为不是明文发送</span></li>\n</ul>\n<h3 id=\"为什么get系会被缓存而post系不会被缓存\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">为什么get系会被缓存而post系不会被缓存?</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">1、因为get系设计的初衷是用来从服务器拉取数据的。含有两个特点：</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">数据可能很大，数据可能会重复。正因为有这两个特点，所以造成了get系会被缓存</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">post系设计的初衷是往服务器发送数据的,所以不需要缓存</span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HEAD、DELETE这两个方法比较特殊：他们成功只返回202，不会返回200</span></p>","rank_id":321,"createdAt":"2021-06-16T02:44:50.786Z","updatedAt":"2021-06-16T02:44:50.786Z","__v":0},{"_id":"60c965c67d119d797cb7b793","title":"WEB应用从服务器主动推送Data到客户端有哪些方式","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">html5 websoket</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">WebSocket通过Flash</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">XHR长时间连接</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">XHR Multipart Streaming</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不可见的Iframe</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>标签的长时间连接(可跨域)</p>","rank_id":322,"createdAt":"2021-06-16T02:45:26.137Z","updatedAt":"2021-06-16T02:45:26.138Z","__v":0},{"_id":"60c967ac7d119d797cb7b795","title":"JavaScript jsonP有哪几种方式？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">JSONP原理及实现跨域方式?</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">后台给了个接口：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">https://a.a.com/a/a.json</code>,我页面的上线地址是：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">http://b.b.com</code>。显而易见，因为浏览器同源策略的限制，通过ajax无法无法取得json的数据。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支JavaScript的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">同源策略限制了我们无法通过原生的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">XMLHttpRequest()</code>对象获取到json数据。为了突破这个限制，我们的前辈们想出了一个解决方案：jsonp。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">jsonp并非新的数据格式，而是解决JSON跨域获取的解决方案。通过JSONP获取到得数据已经不是JSON了，而是JS类型的数据（大部分是对象）。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">上网找过很多讲jsonp的文章，大部分都是讲的模模糊糊的。jsonp的原理其实不复杂：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">1、浏览器的同源策略把跨域请求都禁止了；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">2、HTML的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>标签是例外，可以突破同源策略从其他来源获取数据；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">3、由上可得，我们可以通过<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>标签引入jsonp文件，然后通过一系列JS操作获取数据。</p>\n</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不仅如此，我们还发现凡是拥有&rdquo;src&rdquo;这个属性的标签都拥有跨域的能力，比如<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>、<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;img&gt;</code>、<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;iframe&gt;</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">上面三点便是JSONP实现跨域的原理。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">原理我们知道了，该怎么实现这些操作呢？</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">接下来轮到jQuery登场！JQ已经帮我们封装好了</p>\n<pre class=\"language-javascript\"><code>$.ajax({\n  dataType:'jsonp',\n  jsonp:'jsonp_callback',\n  url:'http://www.baidu.com/xxx.jsonp',\n  success:function(){\n      //dosomthing\n  }\n});</code></pre>\n<p>严格的jQuery代码：</p>\n<pre class=\"language-javascript\"><code>jQuery(document).ready(function(){\n  $.ajax({\n       type: \"get\",\n       async: false,\n       url: \"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998\",\n       dataType: \"jsonp\",\n       jsonp: \"callback\",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)\n       jsonpCallback:\"flightHandler\",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写\"?\"，jQuery会自动为你处理数据\n       success: function(json){\n           alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');\n       },\n       error: function(){\n           alert('fail');\n       }\n   });\n});</code></pre>\n<p>原生的JS Demo:</p>\n<pre class=\"language-javascript\"><code>function jsonHandle (url) {\n  var script = document.createElement(\"script\");\n  script.setAttribute(\"src\", url);\n  document.getElementsByTagName(\"body\")[0].appendChild(script);\n}\n//JS插入之后就可以处理数据了</code></pre>\n<h2 id=\"ajax和jsonp的区别\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">Ajax和jsonp的区别</h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">1、ajax和jsonp这两种技术在调用方式上&ldquo;看起来&rdquo;很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>标签来调用服务器提供的js脚本。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。</p>\n</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">http://www.XXXX.com:80/</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">1、协议、域名/IP、端口号 2、同源策略：上面的三个完全一致是同源</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我们当前页面的地址(<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">http://www.aaa.com/</code>)和我们要向服务器请求数据的地址(<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">http://www.XXX.com/data/userInfo?name=aaa&amp;age=13</code>)在同源下,这就是同源策略,项目中我们在同源下请求数据使用JS中的Ajax技术</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">非同源(跨域)策略：上面的三个有一个不一样就是非同源</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我们当前页面的地址和请求数据的服务器地址不是同一个源,</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">例如:当前地址是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">http://www.XXX.com/</code>,请求数据的地址<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">http://www.baidu.com/data/videoInfo</code>,此时我们是跨域请求(非同源策略),在项目中目前最常用的解决跨域的方式是JS中的JSONP技术</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">具体的目录文件和URL后面的参数值</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">后面的都是传递给当前页面的参数值(问号传参),如果需要传递多个参数,中间中&amp;隔开,#是当前页面的锚点定位</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">https://www.baidu.com:80/user/index.html?name=aaa&amp;age=17&amp;sex=1#userName</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">(#userName锚点定位,定位到当前页面中ID为userName这个标签的位置)</p>","rank_id":323,"createdAt":"2021-06-16T02:53:32.104Z","updatedAt":"2021-06-16T02:53:32.104Z","__v":0},{"_id":"60c967f07d119d797cb7b796","title":"AJAX 的状态码有哪些","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">readyState属性 状态 有5个可取值</span></p>\n<ul>\n<li><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"lit\" style=\"color: #006666;\">0</span><span class=\"pun\" style=\"color: #666600;\">=未初始化</span></code></li>\n<li><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"lit\" style=\"color: #006666;\">1</span><span class=\"pun\" style=\"color: #666600;\">=启动</span></code></li>\n<li><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"lit\" style=\"color: #006666;\">2</span><span class=\"pun\" style=\"color: #666600;\">=发送</span></code></li>\n<li><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"lit\" style=\"color: #006666;\">3</span><span class=\"pun\" style=\"color: #666600;\">=接收</span></code></li>\n<li><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"lit\" style=\"color: #006666;\">4</span><span class=\"pun\" style=\"color: #666600;\">=完成</span></code></li>\n</ul>","rank_id":324,"createdAt":"2021-06-16T02:54:40.881Z","updatedAt":"2021-06-16T02:54:40.881Z","__v":0},{"_id":"60c968177d119d797cb7b797","title":"HTTP状态码有哪些？分别代表什么意思？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">100-199 用于指定客户端应相应的某些动作。</li>\n<li style=\"padding: 0px; margin: 0px;\">200-299 用于表示请求成功。</li>\n<li style=\"padding: 0px; margin: 0px;\">300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。</li>\n<li style=\"padding: 0px; margin: 0px;\">400-499 用于指出客户端的错误。400 1、语义有误，当前请求无法被服务器理解。401 当前请求需要用户验证 403 服务器已经理解请求，但是拒绝执行它。</li>\n<li style=\"padding: 0px; margin: 0px;\">500-599 用于支持服务器错误。 503 &ndash; 服务不可用;</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">常用的</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n<li style=\"padding: 0px; margin: 0px;\">200 OK 正常返回信息</li>\n<li style=\"padding: 0px; margin: 0px;\">201 Created 请求成功并且服务器创建了新的资源</li>\n<li style=\"padding: 0px; margin: 0px;\">202 Accepted 服务器已接受请求，但尚未处理</li>\n<li style=\"padding: 0px; margin: 0px;\">301 Moved Permanently 请求的网页已永久移动到新位置。</li>\n<li style=\"padding: 0px; margin: 0px;\">302 Found 临时性重定向。</li>\n<li style=\"padding: 0px; margin: 0px;\">303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。</li>\n<li style=\"padding: 0px; margin: 0px;\">304 Not Modified 自从上次请求后，请求的网页未修改过。</li>\n<li style=\"padding: 0px; margin: 0px;\">400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>\n<li style=\"padding: 0px; margin: 0px;\">401 Unauthorized 请求未授权。</li>\n<li style=\"padding: 0px; margin: 0px;\">403 Forbidden 禁止访问。</li>\n<li style=\"padding: 0px; margin: 0px;\">404 Not Found 找不到如何与 URI 相匹配的资源。</li>\n<li style=\"padding: 0px; margin: 0px;\">500 Internal Server Error 最常见的服务器端错误。</li>\n<li style=\"padding: 0px; margin: 0px;\">503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li>\n</ul>","rank_id":325,"createdAt":"2021-06-16T02:55:19.986Z","updatedAt":"2021-06-16T02:55:19.986Z","__v":0},{"_id":"60c968597d119d797cb7b798","title":"http状态吗100,200,300,400,500分别代表什么意思？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">200 OK 正常返回信息</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">500 Internal Server Error 最常见的服务器端错误。</p>\n</li>\n</ul>","rank_id":326,"createdAt":"2021-06-16T02:56:25.698Z","updatedAt":"2021-06-16T02:56:25.698Z","__v":0},{"_id":"60c9689c7d119d797cb7b799","title":"聊聊 cache-control","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">网页的缓存是由HTTP消息头中的&ldquo;Cache-control&rdquo;来控制的，常见的取值 有private、no-cache、max-age、must-revalidate等，默认为private。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Expires 头部字段提供一个日期和时间，响应在该日期和时间后被认为失效。允许客户端在这个时间之前不去检查（发请求），等同max-age的效果。但是如果同时存在，则被Cache-Control的max-age覆盖。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Expires = \"Expires\" \":\" HTTP-date</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">例如</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Expires: Thu, 01 Dec 1994 16:00:00 GMT</code>&nbsp;（必须是GMT格式）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果把它设置为-1，则表示立即过期</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Expires和max-age都可以用来指定文档的过期时间，但是二者有一些细微差别</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">1.Expires在HTTP/1.0中已经定义，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Cache-Control:max-age</code>在HTTP/1.1中才有定义，为了向下兼容，仅使用max-age不够；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">2.Expires指定一个绝对的过期时间(GMT格式),这么做会导致至少2个问题：1)客户端和服务器时间不同步导致Expires的配置出现问题。 2）很容易在配置后忘记具体的过期时间，导致过期来临出现浪涌现象；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">3.max-age 指定的是从文档被访问后的存活时间，这个时间是个相对值(比如:3600s),相对的是文档第一次被请求时服务器记录的Request_time(请求时间)</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">4.Expires指定的时间可以是相对文件的最后访问时间(Atime)或者修改时间(MTime),而max-age相对对的是文档的请求时间(Atime)</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">5.如果值为no-cache,那么每次都会访问服务器。如果值为max-age,则在过期之前不会重复访问服务器。</p>\n</li>\n</ul>","rank_id":327,"createdAt":"2021-06-16T02:57:32.097Z","updatedAt":"2021-06-16T02:57:32.097Z","__v":0},{"_id":"60c9694e7d119d797cb7b79a","title":"实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">相较于不同页面的跳转，AJAX可以说大大提高了用户的浏览体验，不用看到页面切换之间的白屏是件很惬意的事情。但是很多早先的AJAX应用是不支持浏览器的前进后退的，这导致了用户不管在网站里浏览到何处，一旦刷新就会立刻回到起初的位置，并且用户也无法通过浏览器的前进后退按钮来实现浏览历史的切换。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于第一个问题，解决还算容易，只要用cookie或者localStorage来记录应用的状态即可，刷新页面时读取一下这个状态，然后发送相应ajax请求来改变页面即可。但是第二个问题就很麻烦了，先说下现代浏览器的解决方案。</p>\n<h2 id=\"html5-解决方案\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">HTML5 解决方案</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">要了解HTML5如何实现前进后退，就要先了解下history对象和location对象。</p>\n<h3 id=\"history对象\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">history对象</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">History 对象属性</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">length：返回浏览器历史列表中的URL数量，用户在当前标签每访问一个页面，此数量加1。因为隐私原因，URL具体内容不可见。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">state：与当前网址相关的对象，只能通过pushState和replaceState添加或修改。我们可以可以用它来存储跟url有关的信息。</p>\n</li>\n</ol>\n<h3 id=\"history-对象方法\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">History 对象方法</h3>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">history.back()</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">此方法无参数，触发后会返回前一个浏览的页面，相当于点击了浏览器的后退按钮。</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"2\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">history.forward()</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">此方法无参数，触发后会返回后退前浏览的页面，相当于点击了浏览器的前进按钮。</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"3\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">history.go(number)</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">此方法接受一个整形变量参数，history.go(-1)相当于后退一页，history.go(1)相当于前进一页，history.go(0)会刷新当前页面。</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"4\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">history.pushState(state, title, url)</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">改变url且不刷新页面的关键就是它了，此方法会改变当前页面的location.href并且修改当前的history.state对象，执行后history.length会增加1。此方法接受三个参数，</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">state：当前网址相关的对象。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">title：页面标题，但是所有浏览器都忽略它，要改变标题还是要用document.title。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">url：一个与当前页面同域的网址，location.href会变成此值。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">history.replaceState(state, title, url)</p>\n</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">此方法同上，但是它不会改变<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">history.length</code>，只会修改当<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">history.state</code>和location.href。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">注意&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">pushState</code>&nbsp;和&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">replaceState</code>&nbsp;第三个参数不可跨域，并且不会触发浏览器的popstate事件和onhashchange事件(chrome33下测试)。</p>\n<h2 id=\"location对象\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">location对象</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">除了点击前进/后退按钮和history事件，还可以通过location的方法和修改location的属性来改变Url：</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">location对象的属性(读写)：</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">host:域名+端口号</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">hostname:域名</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">port:端口号</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">protocol:协议</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">href：完整路径</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">origin：协议+域名+端口</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">hash：井号 (#) 开始的 URL(hash)</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">pathname:文档路径+文档名</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">search:(?)后面的内容</p>\n</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可以通过改变<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">location.href</code>或<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">location.hash</code>来达到无刷新的目的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">location对象的方法：</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">assign:改变url的值，并且将当前的url添加到历史记录中history.length会增加1。location.assig(&lsquo;#' + x)会改变url但是不刷新页面。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">reload:刷新页面。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">replace:改变url的值，但是history.length不变。使用方法同assign。</p>\n</li>\n</ol>\n<h3 id=\"popstate事件\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">popstate事件</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当url改变时，比如用户点击前进/后退按钮，history.go(n)（n不等于0）,location.hash = x(x不等于当前的location.hash)都会触发此事件。可以用它来监听url，来实现各种功能。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">代码如下:</p>\n<pre class=\"language-javascript\"><code>window.onpopstate = function(){ \n//do sth \n} </code></pre>\n<h3 id=\"onhashchange事件\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">onhashchange事件</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">改变hash值会触发popstate事件，而触发popstate事件不一定会触发onhashchange事件。经过测试：</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">hash改变但是location.pathname不变会触发onhashchange事件，比如<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">history.pushState(&rdquo;, &rdquo;, &lsquo;#abc');</code></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">hash和location.pathname一起改变则不触发，比如history.pushState(&rdquo;, &rdquo;, &lsquo;a#abc');</p>\n</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">老旧浏览器的写法</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">老旧浏览器也不支持<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">pushState</code>和<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">replaceState</code>，所以通过popstate(事实上也不支持这个方法)监听url变化的路走不通。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">那么只能通过改变url#后面的内容来达到无刷新，但是它们又不支持onhashchange，所以对url的变化是无动于衷的(除了页面会滚动至页面对应id的位置)。那么只能祭出大招：轮询，起一个setInterval来监听url的值。Like this:</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">代码如下:</p>\n<pre class=\"language-javascript\"><code>var prevHash = window.location.hash; \nvar callback = function(){\n  //...\n} \nwindow.setInterval(function() { \n    if (window.location.hash != prevHash) { \n        prevHash = window.location.hash; \n        callback(prevHash); \n    } \n}, 100); </code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当然这样写非常非常挫，如果不考虑点击页面带有id的a标签来改变hash的情况，可以利用设计模式来优雅的实现监听url。比如经典的观察者模式，专门用一个类来实现改变hash的功能，然后所有要监听url变化的类(观察者)去订阅这个(被观察者)类。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">代码如下:</p>\n<pre class=\"language-javascript\"><code>//改变url的类 \nfunction UrlChanger () {\n  var _this = this;\n  this.observers = [];\n  //添加观察者 \n  this.addObserver = function (obj) {\n    //...\n  }\n  //删除观察者 \n  this.deleteObserver = function (obj) {\n    //...\n  }\n  //通知观察者 \n  this._notifyObservers = function () {\n    var length = _this.observers.length;\n    console.log(length)\n    for (var i = 0; i &lt; length; i++) {\n      _this.observers[i].update();\n    }\n  }\n  //改变url \n  this.changeUrl = function (hash) {\n    window.location.hash = hash;\n    _this._notifyObservers();\n  }\n}\n//监听类 \nfunction oneOfObservers () {\n  var _this = this;\n  this.update = function () {\n    //...\n  }\n}\n//实现 \nvar o1 = new UrlChanger();\nvar o2 = new oneOfObservers();\no1.addObserver(o2);\no1.changeUrl('fun/arg1/arg2/');\n//o2 has do sth...</code></pre>","rank_id":328,"createdAt":"2021-06-16T03:00:30.392Z","updatedAt":"2021-06-16T03:00:30.392Z","__v":0},{"_id":"60c969ae7d119d797cb7b79b","title":"一个页面输入URL到页面加载显示完成，中间发生了什么？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">浏览器和向服务器发起一个HTTP请求</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">要进行DNS解析</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">先找浏览器缓存&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">chrome://net-internals/#dns</code></span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">再找操作系统缓存</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">读取本地HOST文件</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">发起网络DNS请求调用</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">得到最后的服务器IP</span></p>\n</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">客户端启动一个随机端口，经过三次握手进入到服务器的网卡。(cdm上可以输入netstat,可以看到本机开启的随机端口，小于65535的)</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">浏览器就可以发送真正的请求</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">服务器接收到HTTP请求，解析路径和参数，经后台的处理完成响应。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">浏览器可以收到服务器端的响应，并开始渲染页面。DOM树+CSS树=Render Tree</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">添加用户与界面的交互，绑定一些事件，执行一些动态的行为.</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">还可刷新一些局部内容。</span></p>\n</li>\n</ol>\n<h2 id=\"另一种总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">另一种总结</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">分为4个步骤：</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">（1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">（2）， 浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">（3），一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">（4），此时，Web服务器提供资源服务，客户端开始下载资源。</span></p>\n</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">请求返回后，便进入了我们关注的前端模块</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">简单来说，</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">浏览器会解析HTML生成DOM Tree，</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">其次会根据CSS生成CSS Rule Tree，</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">而javascript又可以根据DOM API操作DOM</span></p>\n<h2 id=\"基础版本\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">基础版本</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP ，向服务器发起请求；</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">服务器交给后台处理完成后返回数据，浏览器接收⽂件（ HTML、JS、CSS 、图象等）；</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">浏览器对加载到的资源（ HTML、JS、CSS 等）进⾏语法解析，建⽴相应的内部数据结构</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">（如 HTML 的 DOM ）；</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">载⼊解析到的资源⽂件，渲染⻚⾯，完成。</span></li>\n</ul>\n<h2 id=\"详细版本\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">详细版本</span></h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">在浏览器地址栏输⼊URL</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">如果资源未缓存，发起新请求</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验 证。</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">检验新鲜通常有两个HTTP头进⾏控制 Expires 和 Cache-Control ：</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">HTTP1.0提供Expires，值为⼀个绝对时间表示缓存新鲜⽇期</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最⼤新鲜时间</span></li>\n</ul>\n</li>\n</ol>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">浏览器解析URL获取协议，主机，端⼝，path</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">浏览器组装⼀个HTTP（GET）请求报⽂</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">浏览器获取主机ip地址，过程如下：</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">浏览器缓存</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">本机缓存</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">hosts⽂件</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">路由器缓存</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">ISP DNS缓存</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">DNS递归查询（可能存在负载均衡导致每次IP不⼀样）</span></li>\n</ol>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">打开⼀个socket与⽬标IP地址，端⼝建⽴TCP链接，三次握⼿如下：</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">客户端发送⼀个TCP的SYN=1，Seq=X的包到服务器端⼝</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">服务器发回SYN=1， ACK=X+1， Seq=Y的响应包</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">客户端发送ACK=Y+1， Seq=Z</span></li>\n</ol>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">TCP链接建⽴后发送HTTP请求</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使⽤HTTP Host头部判断请 求的服务程序</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">服务器将响应报⽂通过TCP连接发送回浏览器</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重⽤，关闭TCP连接的四 次握⼿如下：</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">主动⽅发送Fin=1， Ack=Z， Seq= X报⽂</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">被动⽅发送ACK=X+1， Seq=Z报⽂</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">被动⽅发送Fin=1， ACK=X， Seq=Y报⽂</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">主动⽅发送ACK=Y， Seq=X报⽂</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">如果资源可缓存，进⾏缓存</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">对响应进⾏解码（例如gzip压缩）</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">根据资源类型决定如何处理（假设资源为HTML⽂档）</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">解析HTML⽂档，构件DOM树，下载资源，构造CSSOM树，执⾏js脚本，这些操作没有严 格的先后顺序，以下分别解释</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">构建DOM树：</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">Tokenizing：根据HTML规范将字符流解析为标记</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">Lexing：词法分析将标记转换为对象并定义属性和规则</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">DOM construction：根据HTML标记关系将对象组成DOM树</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">解析过程中遇到图⽚、样式表、js⽂件，启动下载</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">构建CSSOM树：</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">Tokenizing：字符流转换为标记流</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">Node：根据标记创建节点</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">CSSOM：节点创建CSSOM树</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">根据DOM树和CSSOM树构建渲染树 :</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">从DOM树的根节点遍历所有可⻅节点，不可⻅节点包括：1） script , meta 这样本身 不可⻅的标签。2)被css隐藏的节点，如 display: none</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">对每⼀个可⻅节点，找到恰当的CSSOM规则并应⽤</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">发布可视节点的内容和计算样式</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">js解析如下：</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">浏览器创建Document对象并解析HTML，将解析到的元素和⽂本节点添加到⽂档中，此 时document.readystate为loading</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">HTML解析器遇到没有async和defer的script时，将他们添加到⽂档中，然后执⾏⾏内 或外部脚本。这些脚本会同步执⾏，并且在脚本下载和执⾏时解析器会暂停。这样就可 以⽤document.write()把⽂本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事件 处理程序，他们可以遍历和操作script和他们之前的⽂档内容</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">当解析器遇到设置了async属性的script时，开始下载脚本并继续解析⽂档。脚本会在它 下载完成后尽快执⾏，但是解析器不会停下来等它下载。异步脚本禁⽌使⽤ document.write()，它们可以访问⾃⼰script和之前的⽂档元素</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">当⽂档完成解析，document.readState变成interactive</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">所有defer脚本会按照在⽂档出现的顺序执⾏，延迟脚本能访问完整⽂档树，禁⽌使⽤ document.write()</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">浏览器在Document对象上触发DOMContentLoaded事件</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，等这些内容完成载⼊ 并且所有异步脚本完成载⼊和执⾏，document.readState变为complete，window触发 load事件</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">显示⻚⾯（HTML解析过程中会逐步显示⻚⾯）</span></p>\n</li>\n</ol>\n<h2 id=\"详细简版\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">详细简版</span></h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">从浏览器接收 url 到开启⽹络请求线程（这⼀部分可以展开浏览器的机制以及进程与线程 之间的关系）</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">开启⽹络线程到发出⼀个完整的 HTTP 请求（这⼀部分涉及到dns查询， TCP/IP 请求， 五层因特⽹协议栈等知识）</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">从服务器接收到请求到对应后台接收到请求（这⼀部分可能涉及到负载均衡，安全拦截以 及后台内部的处理等等）</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">后台和前台的 HTTP 交互（这⼀部分包括 HTTP 头部、响应码、报⽂结构、 cookie 等知 识，可以提下静态资源的 cookie 优化，以及编码解码，如 gzip 压缩等）</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">单独拎出来的缓存问题， HTTP 的缓存（这部分包括http缓存头部， ETag ， catch- control 等）</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">浏览器接收到 HTTP 数据包后的解析流程（解析 html -词法分析然后解析成 dom 树、解 析 css ⽣成 css 规则树、合并成 render 树，然后 layout 、 painting 渲染、复合图 层的合成、 GPU 绘制、外链资源的处理、 loaded 和 DOMContentLoaded 等）</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">CSS 的可视化格式模型（元素的渲染规则，如包含块，控制框， BFC ， IFC 等概念）</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">JS 引擎解析过程（ JS 的解释阶段，预处理阶段，执⾏阶段⽣成执⾏上下⽂， VO ，作 ⽤域链、回收机制等等）</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">其它（可以拓展不同的知识模块，如跨域，web安全， hybrid 模式等等内容）</span></li>\n</ol>","rank_id":329,"createdAt":"2021-06-16T03:02:06.631Z","updatedAt":"2021-06-16T03:02:06.631Z","__v":0},{"_id":"60c969d67d119d797cb7b79c","title":"重绘和回流是什么？谈一谈","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">浏览器呈现网页的处理流程图：</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">具体处理步骤：</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">浏览器把获取到的HTML代码解析成一棵DOM树，HTML中的每个标签（tag）都是DOM树中的一个节点，根节点就是我们常用的document对象。DOM树里包含了HTML所有标签，包括display：none隐藏，还有用JS动态添加的元素等；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">浏览器把所有样式（用户定义的css和用户代理）解析成样式结构体，在解析过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而Firefox会去掉_开头的样式；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">DOM树和样式结构体组合后构建render tree（渲染树），render tree类似于DOM树，但区别很大，render tree 能识别样式，render tree的每一个节点都有自己的样式，而且render tree中不包含隐藏的节点（比如display：none的节点，还有head节点），因为这些节点不会用于呈现，而且不会影响呈现。</p>\n</li>\n</ol>\n<blockquote style=\"padding: 0px 0px 8px; margin: 10px 0px; color: #828201; border-width: 1px 1px 1px 5px; border-style: solid; border-color: #e2e2e2 #e2e2e2 #e2e2e2 #fff000; border-image: initial; background-color: #ffffc0; overflow: hidden; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">注意：visibility：hidden隐藏的元素还是会包含到render tree中，因为visibility：hidden会影响布局（layout），会占有空间。根据css2的标准，render tree中的每个节点都称为Box（Box demensions）,理解页面元素为一个具有填充，边距，边框和位置的盒子。</p>\n</blockquote>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"4\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">一旦render tree构建完成后，浏览器就可以根据render tree来绘制页面了。</li>\n</ol>\n<h2 id=\"重绘\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">重绘</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility，outline，背景色属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>\n<h2 id=\"回流\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">回流</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">回流是更明显的一种改变，可以理解为render tree需要重新计算。每个页面至少需要一次回流，就是在页面加载的时候。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>注意：回流必将引起重绘，但重绘不一定引起回流。</strong></p>\n<h2 id=\"触发回流\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">触发回流</h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">调整窗口大小（Resizing the windown）;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">改变字体（changing the font）;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">增加或移除样式表（adding or removing a stylesheet）；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">内容变化，比如用户在input输入框中输入文字（content changes ,such as a user typing text in an input box）；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">激活css伪类，比如：hover（IE中为兄弟节点伪类的激活）（activation of css pseudo classes such as :hover (in IE the activation of the pseduo class of a silibing)）;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">操作class属性（manipulating the class attribute）；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">脚本操作DOM（a script manipulating the DOM）；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">计算offsetWidth和offsetHeight属性（calculating offsetWidth and offsetHeight）</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">设置style属性的值（setting a property of the style attribute）。</p>\n</li>\n</ol>","rank_id":330,"createdAt":"2021-06-16T03:02:46.180Z","updatedAt":"2021-06-16T03:02:46.180Z","__v":0},{"_id":"60c96a907d119d797cb7b79d","title":"横向滑动的原理？轮播图的原理","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">父元素</span></p>\n<pre class=\"language-css\"><code>overflow:hidden;\nposition:relative;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">子元素很宽&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">position:absolute</code>，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这样子元素可以相对父元素定位了！！只显示父元素的大小，当移动到最后一个子元素时候克隆整个子元素；当移动从克隆的第一个子元素到第二个子元素时候，此时瞬间移动到没有克隆的第二个图片</p>","rank_id":331,"createdAt":"2021-06-16T03:05:52.542Z","updatedAt":"2021-06-16T03:05:52.542Z","__v":0},{"_id":"60c96aa97d119d797cb7b79e","title":"下拉刷新怎么实现?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"font-size: 16px; padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">下拉</code>&ndash;&gt;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">提示松开刷新</code>&ndash;&gt;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">松开后</code>&ndash;&gt;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">开始刷新</code>&ndash;&gt;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">刷新成功后还原</code></p>\n<p style=\"font-size: 16px; padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; background-color: #ffffff;\">js部分：主要就是为一个节点绑定事件，可以是整个body，按照实际来看</p>\n<p style=\"font-size: 16px; padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; background-color: #ffffff;\">目前主要涉及三个事件，&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">touchstart</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">touchmove</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">touchend</code></p>\n<p style=\"font-size: 16px; padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; background-color: #ffffff;\">这里获取touch点坐标是用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">pageX</code>&nbsp;,&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">pageY</code>&nbsp;当然不兼容的话先不考虑</p>\n<p style=\"font-size: 16px; padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; background-color: #ffffff;\">因为是下滑才刷新，所以稍微控制一下way，其实也就是通过这个控制是获取&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">pageX</code>&nbsp;还是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">pageY</code></p>\n<p style=\"font-size: 16px; padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; background-color: #ffffff;\">滑一滑可以直接看到dist的变化，其实就把它看做px了吧</p>","rank_id":332,"createdAt":"2021-06-16T03:06:17.995Z","updatedAt":"2021-06-16T03:06:17.995Z","__v":0},{"_id":"60c96ac97d119d797cb7b79f","title":"图片延迟加载的原理，延迟加载的实现原理","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">核心原理是：</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">写一个onscroll事件，监听鼠标滚轮事件，计算每张图片是否会随着滚动条的滚动，而出现在视口（也就是浏览器中的 展现网站的空白部分 ）中；</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">为<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;img&gt;</code>标签设置一个暂存图片URL的自定义</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">如果图片已经加载显示了，用一个flag标记为true；当flag为flase的时候，就是需要加载的图片；</p>\n</li>\n</ol>","rank_id":333,"createdAt":"2021-06-16T03:06:49.611Z","updatedAt":"2021-06-16T03:06:49.611Z","__v":0},{"_id":"60c96b127d119d797cb7b7a0","title":"JavaScript JS延迟加载的方式有哪些","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当一个网站有很多js代码要加载，js代码放置的位置在一定程度上将会影像网页的加载速度；</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">延迟加载js代码\n<pre class=\"language-markup\"><code>&lt;script id=&rdquo;my&rdquo;&gt;&lt;/script&gt; \n&lt;script&gt; \n  setTimeout(document.getElementById('my').src='include/index.js',3000);//延时3秒 \n&lt;/script&gt; </code></pre>\n</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">这样通过延迟加载js代码，给网页加载留出更多的时间！</p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\" start=\"2\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">让JS最后加载方案</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">这个牵涉到网页的加载顺序问题，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">例如引入外部js脚本文件时，如果放入html的head中,则页面加载前该js脚本就会被加载入页面，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">而放入body中，则会按照页面从上倒下的加载顺序来运行javascript的代码~~~</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">所以我们可以把js外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">jquery的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$().ready(function)</code>&nbsp;/&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">window.onload</code>；以及&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">DOMContentLoaded</code>&nbsp;都是一样的思路；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">一般用第二种思路；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">经典的总结:&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">defer</code>和<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">async</code>、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack，用的最多）、按需异步载入js</p>","rank_id":334,"createdAt":"2021-06-16T03:08:02.428Z","updatedAt":"2021-06-16T03:08:02.428Z","__v":0},{"_id":"60c96b9f7d119d797cb7b7a1","title":"异步加载的方式有哪些？","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">延迟加载就是一开始并不加载这些暂时不用的js，而是在需要的时候或稍后再通过js 的控制来异步加载。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">也就是将 js 切分成许多模块，页面初始化时只加载需要立即执行的 js ，然后其它 js 的加载延迟到第一次需要用到的时候再加载。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">特别是页面有大量不同的模块组成，很多可能暂时不用或根本就没用到。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">就像图片的延迟加载，在图片出现在可视区域内时（在滚动条下拉）才加载显示图片。</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">onload</code>&nbsp;时的异步加载 ；</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">DOMContentLoaded</code>&nbsp;异步加载；也就是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$(document).ready</code>；需要引用jquery，兼容所有浏览器。</span></p>\n</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">DOMContentLoaded</code>&nbsp;与&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">onload</code>&nbsp;事件</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">DOMContentLoaded</code>&nbsp;: 页面(document)已经解析完成，页面中的dom元素已经可用。但是页面中引用的图片、subframe可能还没有加载完。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">onload</code>&nbsp;：页面的所有资源都加载完毕（包括图片）。浏览器的载入进度在这时才停止。</span></p>\n<ol class=\"linenums\" style=\"padding: 0px 0px 0px 10px; margin: 0px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace; font-size: 14px;\">\n<li class=\"L0\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">这两个时间点将页面加载的</span><span class=\"pln\" style=\"color: #000000;\">timeline</span><span class=\"pun\" style=\"color: #666600;\">分成了三个阶段。</span><span class=\"pln\" style=\"color: #000000;\"> </span></code></span></li>\n</ol>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"3\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"3\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">动态创建<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>标签；</span>\n<pre class=\"language-markup\"><code>&lt;script type=\"text/javascript\"&gt;\n        (function(){\n                var s = document.createElement('script');\n                s.type = 'text/javascript';\n                s.src = \"http://code.jquery.com/jquery-1.7.2.min.js\";\n                var tmp = document.getElementsByTagName('script')[0];\n                tmp.parentNode.insertBefore(s, tmp);\n        })();\n&lt;/script&gt;</code></pre>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">定时器；延迟加载js代码</span>\n<pre class=\"language-markup\"><code>&lt;script id=&rdquo;my&rdquo;&gt;&lt;/script&gt; \n&lt;script&gt; \n  setTimeout(document.getElementById('my').src='include/index.js',3000);//延时3秒 \n&lt;/script&gt; </code></pre>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">AJAX eval（使用AJAX得到脚本内容，然后通过&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">eval_r(xmlhttp.responseText)</code>来运行脚本）；兼容所有浏览器。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">iframe方式，兼容所有浏览器。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>标签的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">async=\"async\"</code>属性；async的定义和用法(是HTML5的属性)；<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">async</code>&nbsp;属性规定一旦脚本可用，则会异步执行。</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script type=\"text/javascript\" src=\"CSS CSS XXXXXXX.js\" async=\"async\"&gt;&lt;/script&gt;</code></span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">HTML5中新增的属性，Chrome、FF、IE9&amp;IE9+均支持（IE6~8不支持）。此外，这种方法不能保证脚本按顺序执行。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">async 属性仅适用于外部脚本（只有在使用 src 属性时）。</span></p>\n</li>\n</ol>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>标签的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">defer=\"defer\"</code>属性；<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">defer</code>&nbsp;属性规定是否对脚本执行进行延迟，直到页面加载为止。</span></p>\n</li>\n</ol>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">有的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">javascript</code>&nbsp;脚本&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">document.write</code>&nbsp;方法来创建当前的文档内容，其他脚本就不一定是了。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">如果您的脚本不会改变文档的内容，可将 defer 属性加入到&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>&nbsp;标签中，以便加快处理文档的速度。</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"3\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"3\">因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。</ol>\n</ol>\n<pre class=\"language-markup\"><code>&lt;script type=\"text/javascript\" defer=\"defer\"&gt; \n  alert(document.getElementById(\"p1\").firstChild.nodeValue); \n&lt;/script&gt;</code></pre>","rank_id":335,"createdAt":"2021-06-16T03:10:23.968Z","updatedAt":"2021-06-16T03:10:23.968Z","__v":0},{"_id":"60c96bbe7d119d797cb7b7a2","title":"异步加载和延迟加载","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">异步加载的方案: 动态插入script标签</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">通过ajax去获取js代码，然后通过eval执行</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">script标签上添加defer或者async属性</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">创建并插入iframe，让它异步执行js</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。</li>\n</ol>","rank_id":336,"createdAt":"2021-06-16T03:10:54.946Z","updatedAt":"2021-06-16T03:10:54.946Z","__v":0},{"_id":"60c96d0a7d119d797cb7b7a3","title":"线程与进程的区别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">javaScript单线程执行机制</p>\n<h3 id=\"首先解释下单线程和多线程\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">首先解释下，单线程和多线程。</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">什么是单线程？单线程就是一个进程中只有一个线程。程序顺序执行，前面的执行完，才会执行后面的程序。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">什么是多线程？多线程就是一个进程中只有多个线程。在进程内部进行线程间的切换，由于每个线程执行的时间片很短，所以在感觉上是并行的。</p>\n<h3 id=\"为什么感觉上javascript是多线程而且还支持ajax异步呢ajax是真正的异步吗\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">为什么感觉上javaScript是多线程？而且还支持AJAX异步呢？AJAX是真正的异步吗？</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">先说明，从哪里可以得出javaScript是单线程。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">比如你页面一上来就alert（&ldquo;hello world~&rdquo;）；只要你不关闭这个对话框，后续的js代码就不会再执行。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为，单线程就是这样一步一步的顺次执行，前面不执行完，后面不会执行。也就是说，在具体的某一时刻，只有一段代码在执行。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可是，JavaScript明明可以处理各种触发事件，感觉上是异步多线程啊。其实，它的原理是这样的，JavaScript单线程的执行浏览器的一个事件队列，要执行的函数和触发事件的回调函数都被放在这个队列中。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">比如，我点击率一下按钮，之后又将浏览器缩小了，那么这两个事件的回调函数就会顺次地被放在当前执行的&ldquo;函数&rdquo;之后，再一一执行。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">那么，既然JavaScript是单线程，那么如何维护这个函数队列呢，他分身无术啊。这时候，就需要知道，浏览器可不是单线程。虽然，每一个window只有一个js引擎，但是浏览器是事件驱动的、异步的、多线程的。</p>\n<pre class=\"language-javascript\"><code>//浏览器内部有一个事件轮询（event loop），是一个大的内部消息循环，会轮询大的消息队列，并执行。也就是js要处理的事件队列，是浏览器维护的。\n//浏览器至少有四个线程（不同浏览器会有差异）： js引擎线程、界面渲染线程、浏览器事件触发线程、http请求线程。</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">其实，到这里就说的很明白了。但是，又想到了延时函数（setTimeout）的例子，感觉上，因为没有阻塞执行，会感觉是异步，其实并不是。只是，js在执行到延时函数时，会触发浏览器的定时器，到设置时间，浏览器再将这个函数放入执行的函数队列，再由JavaScript引擎执行。都是在浏览器空闲了才会执行。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">关于AJAX的异步，是真正的异步。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">同样的道理，在调用AJAX的时候，浏览器会开辟一个新的线程，去处理这个请求，得到响应后，如果这个请求有回调，会将这个回调再放入事件队列中。再由JavaScript引擎执行。</p>\n<h3 id=\"关于javascript的阻塞\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">关于JavaScript的阻塞</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">浏览器虽然是多线程，但是由于JavaScript具有阻塞特性，无论外链还是内嵌脚本，在浏览器执行解释js脚本的时候，浏览器是不会去做别的事情的，比如渲染页面，而是直到js下载并执行完毕。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这样，js脚本的下载、解释执行，会反该页面的继续绘制，给用户带来不良的体验。所以，要对其优化，有如下几点：</p>\n<pre class=\"language-javascript\"><code>a、将`&lt;script&gt;`内嵌和外链，在可以的情况下，放在&lt;body&gt;底部。注：对于css，浏览器是并行下载\nb、在页面onload后，加载js\nc、html5 `&lt;script&gt;`标签的defer属性，在页面加载完成后下载\nd、使用创建`&lt;script&gt;`标签的方式，在页面加载完成后添加进去。\n注：解决阻塞就是一句话，先让页面渲染完，再加载js。</code></pre>\n<h3 id=\"下面是线程与进程的解析\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">下面是线程与进程的解析</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">线程和进程基本概念</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>进程</strong>：操作系统分配的占有CPU资源的最小单位。拥有独立的地址空间。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>线程</strong>：安排CPU执行的最小单位。同一个进程下的所有线程，共享进程的地址空间。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">简单讲，计算机就像工厂，进程是个大车间，计算机内部有很多个这样的大车间。线程是工人，每一个车间里的工人至少有一个。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">线程和进程的关系、通性</p>\n<ul>\n<li><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">关系：进程中包含着至少一个线程。在进程创建之初，就会包含一个线程，这个线程会根据需要，调用系统库函数去创建其他线程。但需要注意的是，这些线程之间是没有层级关系的，他们之间协同完成工作。在整个进程完成工作之后，其中的线程会被销毁，释放资源。</span></code></li>\n<li><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"></code>通性：都包含三个状态，就绪、阻塞、运行。通俗的讲，阻塞就是资源未到位，等待资源中。就绪，就是资源到位了，但是<span class=\"pln\" style=\"font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\">CPU</span><span class=\"pun\" style=\"font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace; color: #666600;\">未到位，还在运行其他。</span></li>\n</ul>\n<p><span class=\"pun\" style=\"font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace; color: #666600;\">既然，线程和进程是存在通性的，那么为什么操作系统还要设置线程这个单位，那就说说线程的几点好处：</span></p>\n<p>&nbsp;</p>\n<ol>\n<li><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">在一个程序中，多个线程可以同步或者互斥并行完成工作，简化了编程模型；</span></code></li>\n<li><span class=\"pun\" style=\"font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace; color: #666600;\">线程较进程来讲，更轻；</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"></code><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"></code></li>\n<li><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">线程虽然微观并行。但是，在一个进程内部，一个线程阻塞后，会执行这个进程内部的其他线程，而不是整体阻塞。从某种意义上，提高了</span><span class=\"pln\" style=\"color: #000000;\">CPU</span><span class=\"pun\" style=\"color: #666600;\">的利用率。</span></code></li>\n</ol>\n<h2 id=\"经典的解析\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">经典的解析：</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一个程序至少有一个进程,一个进程至少有一个线程.</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">线程的划分尺度小于进程，使得多线程程序的并发性高。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>\n<p><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"></code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>","rank_id":337,"createdAt":"2021-06-16T03:16:26.944Z","updatedAt":"2021-06-16T03:16:26.944Z","__v":0},{"_id":"60c96d867d119d797cb7b7a4","title":"什么叫优雅降级和渐进增强?","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<p><span style=\"font-size: 12pt;\"><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; background-color: #ffffff;\">之前在看一些css3效果demo的时候，发现有些写css3属性时，兼容性的写法顺序不太一样，比如</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; background-color: #ffffff;\">transition</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; background-color: #ffffff;\">属性，有些把</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; background-color: #ffffff;\">transition</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; background-color: #ffffff;\">放在前面有些是放在后面，当然这也有可能包含了coder个人的习惯或是强迫性&gt;\"&lt;，比如下面这两种：</span></span></p>\n<pre class=\"language-css\"><code>.transition{\n  -webkit-transition: all .5s;\n     -moz-transition: all .5s;\n       -o-transition: all .5s;\n          transition: all .5s;\n}</code></pre>\n<pre class=\"language-css\"><code>.transition{\n　　     transition: all .5s;\n　　  -o-transition: all .5s;\n  　-moz-transition: all .5s;\n -webkit-transition: all .5s;\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">但是transition放在前面还是后面却引申了两个概念：优雅降级和渐进增强。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">优雅降级和渐进增强印象中是随着css3流出来的一个概念。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">由于低级浏览器不支持css3，但css3的效果又太优秀不忍放弃，所以在高级浏览中使用css3而低级浏览器只保证最基本的功能。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">咋一看两个概念差不多，都是在关注不同浏览器下的不同体验，关键的区别是他们所侧重的内容，以及这种不同造成的工作流程的差异。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><strong>什么是渐进增强（progressive enhancement）、优雅降级（graceful degradation）呢？</strong></span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><strong>渐进增强</strong>：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><strong>优雅降级</strong>：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><strong>区别</strong>：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</span></p>\n<h3 id=\"优雅降级观点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">优雅降级观点</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">&ldquo;优雅降级&rdquo;观点认为应该针对那些最高级、最完善的浏览器来设计网站。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">而将那些被认为&ldquo;过时&rdquo;或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在这种设计范例下，旧版的浏览器被认为仅能提供&ldquo;简陋却无妨 (poor, but passable)&rdquo; 的浏览体验。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。</span></p>\n<h3 id=\"渐进增强观点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">渐进增强观点</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">&ldquo;渐进增强&rdquo;观点则认为应关注于内容本身。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这使得&ldquo;渐进增强&rdquo;成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其&ldquo;分级式浏览器支持 (Graded Browser Support)&rdquo;策略的原因所在。</span></p>\n<h2 id=\"经典的总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">经典的总结</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><strong>优雅降级</strong>：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><strong>渐进增强</strong>：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</span></p>","rank_id":338,"createdAt":"2021-06-16T03:18:30.029Z","updatedAt":"2021-06-16T03:18:30.029Z","__v":0},{"_id":"60c96db17d119d797cb7b7a5","title":"对网站重构的理解？怎么重构页面？","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<h3 id=\"怎么重构页面\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">怎么重构页面？</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">编写 CSS、让页面结构更合理化，提升用户体验，实现良好的页面效果和提升性能。</span></p>\n<h3 id=\"对网站重构的理解\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">对网站重构的理解</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><strong>网站重构</strong>：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</span></p>\n<h3 id=\"对于传统的网站来说重构通常是\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">对于传统的网站来说重构通常是</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">表格(table)布局改为DIV+CSS</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">对于移动平台的优化</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">针对于SEO进行优化</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">深层次的网站重构应该考虑的方面</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">减少代码间的耦合</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">让代码保持弹性</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">严格按规范编写代码</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">设计可扩展的API</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">代替旧有的框架、语言(如VB)</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">增强用户体验</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">通常来说对于速度的优化也包含在重构中</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">压缩JS、CSS、image等前端资源(通常是由服务器来解决)</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">程序的性能优化(如数据读写)</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">采用CDN来加速资源加载</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">对于JS DOM的优化</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">HTTP服务器的文件缓存</span></p>\n</li>\n</ul>","rank_id":339,"createdAt":"2021-06-16T03:19:13.456Z","updatedAt":"2021-06-16T03:19:13.456Z","__v":0},{"_id":"60c96de07d119d797cb7b7a6","title":"HTML页面加载和解析流程","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">浏览器开始载入html代码，发现&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;head&gt;</code>&nbsp;标签内有一个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;link&gt;</code>&nbsp;标签引用外部CSS文件。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">浏览器又发出CSS文件的请求，服务器返回这个CSS文件。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">浏览器继续载入html中&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;body&gt;</code>&nbsp;部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">浏览器在代码中发现一个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;img&gt;</code>&nbsp;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">浏览器发现了一个包含一行Javascript代码的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;script&gt;</code>&nbsp;标签，赶快运行它。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;style&gt;</code>（style.display=&rdquo;none&rdquo;）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">终于等到了<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;/html&gt;</code>的到来，浏览器泪流满面&hellip;&hellip;&nbsp;</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">等等，还没完，用户点了一下界面中的&ldquo;换肤&rdquo;按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">浏览器召集了在座的各位<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;div&gt;``&lt;span&gt;``&lt;ul&gt;``&lt;li&gt;</code>们，&ldquo;大伙儿收拾收拾行李，咱得重新来过&hellip;&hellip;&rdquo;，浏览器向服务器请求了新的CSS文件，重新渲染页面。</p>\n</li>\n</ol>","rank_id":340,"createdAt":"2021-06-16T03:20:00.649Z","updatedAt":"2021-06-16T03:20:00.649Z","__v":0},{"_id":"60c96e147d119d797cb7b7a7","title":"浏览器加载和渲染html的顺序","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">IE下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行的。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">在渲染到页面的某一部分时，其上面的所有部分都已经下载完成（并不是说所有相关联的元素都已经下载完）。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">如果遇到语义解释性的标签嵌入文件（JS脚本，CSS样式），那么此时IE的下载过程会启用单独连接进行下载。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">样式表在下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前已经渲染的）重新进行渲染。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">JS、CSS中如有重定义，后定义函数将覆盖前定义函数。</p>\n</li>\n</ol>","rank_id":341,"createdAt":"2021-06-16T03:20:52.760Z","updatedAt":"2021-06-16T03:20:52.760Z","__v":0},{"_id":"60c96e347d119d797cb7b7a8","title":"JavaScript 的加载","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">不能并行下载和解析（阻塞下载）。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有</p>\n</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">代码直接改变了DOM树结构，比如使用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">document.write</code>&nbsp;或&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">appendChild</code>,甚至是直接使用的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">location.href</code>进行跳转，浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现.</p>","rank_id":342,"createdAt":"2021-06-16T03:21:24.159Z","updatedAt":"2021-06-16T03:21:24.159Z","__v":0},{"_id":"60c96e5a7d119d797cb7b7a9","title":"JavaScript new操作符具体干了什么呢?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">创建一个空对象,并且 this 变量引用该对象,同时还继承了该函数的原型</li>\n<li style=\"padding: 0px; margin: 0px;\">属性和方法被加入到 this 引用的对象中</li>\n<li style=\"padding: 0px; margin: 0px;\">新创建的对象由 this 所引用,并且最后隐式的返回 this\n<pre class=\"language-javascript\"><code>var obj = {};\nobj.__proto__ = Base.prototype;\nBase.call(obj);</code></pre>\n</li>\n</ul>","rank_id":343,"createdAt":"2021-06-16T03:22:02.913Z","updatedAt":"2021-06-16T03:22:02.913Z","__v":0},{"_id":"60c96eab7d119d797cb7b7aa","title":"对JSON的了解?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">它是基于JavaScript的一个子集。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">数据格式简单, 易于读写, 传输占用带宽小。</p>","rank_id":344,"createdAt":"2021-06-16T03:23:23.818Z","updatedAt":"2021-06-16T03:23:23.818Z","__v":0},{"_id":"60c96ec37d119d797cb7b7ab","title":"JavaScript document.write 和 innerHTML的区别;","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">document.write 只能重绘整个页面</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">innerHTML 可以重绘页面的一部分</p>\n</li>\n</ul>","rank_id":345,"createdAt":"2021-06-16T03:23:47.775Z","updatedAt":"2021-06-16T03:23:47.775Z","__v":0},{"_id":"60c96efc7d119d797cb7b7ac","title":"JavaScript call和apply()的作用和区别;","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"核心\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">核心</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">动态改变某个类的某个方法的运行环境，就是改变&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;关键字</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">call是参数一个一个的传</li>\n<li style=\"padding: 0px; margin: 0px;\">apply是把参数当做一个数据统一传进去，类似arguments；</li>\n</ul>\n<h2 id=\"call和apply的区别\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">call和apply的区别</h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">Function.prototype.call 和 Function.prototype.apply 它们的作用一样,区别仅在于传入参数的形式的不同。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">当使用 call 或者 apply 的时候,如果我们传入的第一个参数为 null,函数体内的 this 会指 向默认的宿主对象,在浏览器中则是 window</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">有时候我们使用 call 或者 apply 的目的不在于指 定this 指向,而是另有用途,比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象</p>\n</li>\n</ul>\n<h2 id=\"call和apply的用途\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">call和apply的用途</h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">改变this指向</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">Function.prototype.bind</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">借用其他对象的方法</li>\n</ol>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">call</h2>\n<pre class=\"language-javascript\"><code>function add (a, b) {\n  console.log(a + b);\n}\nfunction sub (a, b) {\n  console.log(a - b);\n}\nadd.call(sub, 3, 1);\n//用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为: (4);</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">js 中的函数其实是对象，函数名是对 Function 对象的引用</span></p>\n<h2 id=\"call\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":346,"createdAt":"2021-06-16T03:24:44.000Z","updatedAt":"2021-06-16T03:24:44.000Z","__v":0},{"_id":"60c96f977d119d797cb7b7ad","title":"JavaScript 哪些操作会造成内存泄露?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"知识点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">知识点</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">另一种说法是：内存泄漏是指分配给应用的内存不能被重新分配，即使在内存已经不被使用的时候。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">垃圾回收器定期扫描对象,并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象）,或对该对象的惟一引用是循环的,那么该对象的内存即可回收。</span></p>\n<h2 id=\"参考答案\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">参考答案</span></h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">setTimeout 的第一个参数使用字符串而非函数的话,会引发内存泄漏。</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">闭包</span></li>\n</ol>\n<ul>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">因为</span><span class=\"typ\" style=\"color: #660066;\">Javascript</span><span class=\"pun\" style=\"color: #666600;\">范围的限制，许多实现依赖</span><span class=\"typ\" style=\"color: #660066;\">Javascript</span><span class=\"pun\" style=\"color: #666600;\">闭包。</span></code></span></li>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">闭包可以导致内存泄漏是因为内部方法保持一个对外部方法变量的引用，所以尽管方法返回了内部方法还可以继续访问在外部方法中定义的私有变量。</span></code></span></li>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">对</span><span class=\"typ\" style=\"color: #660066;\">Javascript</span><span class=\"pun\" style=\"color: #666600;\">程序员来说最好的做法是在页面重载前断开所有的事件处理器</span></code></span></li>\n</ul>\n<p><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"></code></span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"3\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">控制台日志</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">循环引用（在两个对象彼此引用且彼此保留时,就会产生一个循环）</span></li>\n</ol>\n<ul>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">一个很简单的例子</span></code></span></li>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">一个</span><span class=\"pln\" style=\"color: #000000;\">DOM</span><span class=\"pun\" style=\"color: #666600;\">对象被一个</span><span class=\"typ\" style=\"color: #660066;\">Javascript</span><span class=\"pun\" style=\"color: #666600;\">对象引用，与此同时又引用同一个或其它的</span><span class=\"typ\" style=\"color: #660066;\">Javascript</span><span class=\"pun\" style=\"color: #666600;\">对象，这个</span><span class=\"pln\" style=\"color: #000000;\">DOM</span><span class=\"pun\" style=\"color: #666600;\">对象可能会引发内存泄漏。</span></code></span></li>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">这个</span><span class=\"pln\" style=\"color: #000000;\">DOM</span><span class=\"pun\" style=\"color: #666600;\">对象的引用将不会在脚本停止的时候被垃圾回收器回收。</span></code></span></li>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">要想破坏循环引用，引用</span><span class=\"pln\" style=\"color: #000000;\">DOM</span><span class=\"pun\" style=\"color: #666600;\">元素的对象或</span><span class=\"pln\" style=\"color: #000000;\">DOM</span><span class=\"pun\" style=\"color: #666600;\">对象的引用需要被赋值为</span><span class=\"kwd\" style=\"color: #000088;\">null</span><span class=\"pun\" style=\"color: #666600;\">。</span></code></span></li>\n</ul>\n<p><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"></code></span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"5\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">DOM插入顺序</span></li>\n</ol>\n<ul>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">当</span><span class=\"lit\" style=\"color: #006666;\">2</span><span class=\"pun\" style=\"color: #666600;\">个不同范围的</span><span class=\"pln\" style=\"color: #000000;\"> DOM </span><span class=\"pun\" style=\"color: #666600;\">对象连添加到一起的时候一个临时的对象会被创建。</span></code></span></li>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">这个</span><span class=\"pln\" style=\"color: #000000;\">DOM</span><span class=\"pun\" style=\"color: #666600;\">对象改变范围到</span><span class=\"pln\" style=\"color: #000000;\">document</span><span class=\"pun\" style=\"color: #666600;\">时，那个临时对象就没用了。</span></code></span></li>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">也就是说，</span><span class=\"pln\" style=\"color: #000000;\"> DOM </span><span class=\"pun\" style=\"color: #666600;\">对象应该按照从当前页面存在的最上面的</span><span class=\"pln\" style=\"color: #000000;\"> DOM </span><span class=\"pun\" style=\"color: #666600;\">元素开始往下直到剩下的</span><span class=\"pln\" style=\"color: #000000;\"> DOM </span><span class=\"pun\" style=\"color: #666600;\">元素的顺序添加，</span></code></span></li>\n<li><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">这样它们就总是有同样的范围，不会产生临时对象。</span></code></span></li>\n</ul>\n<h2 id=\"如何检测\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">如何检测</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">内存泄漏对开发者来说一般很难检测因为它们是由一些大量代码中的意外的错误引起的，但它在系统内存不足前并不影响程序的功能。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这就是为什么会有人在很长时间的测试期中收集应用程序性能指标来测试性能。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">最简单的检测内存泄漏的方式是用任务管理器检查内存使用情况。在Chrome浏览器的新选项卡中打开应用并查看内存使用量是不是越来越多。</span></p>\n<p><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"></code></span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">还有其他的调试工具提供内存监视器，比如Chrome开发者工具。这是谷歌开者这网站中的堆分析的特性的教程。</span></p>","rank_id":347,"createdAt":"2021-06-16T03:27:19.353Z","updatedAt":"2021-06-16T03:27:19.353Z","__v":0},{"_id":"60c96fda7d119d797cb7b7ae","title":"JavaScript 什么是\"use strict\"?使用它的好处和坏处分别是什么?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">ECMAscript 5添加了第二种运行模式：&ldquo;严格模式&rdquo;（strict mode）。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">顾名思义,这种模式使得Javascript在更严格的条件下运行。</span></p>\n<h2 id=\"设立严格模式的目的\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">设立\"严格模式\"的目的</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">主要有以下几个：</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">消除Javascript语法的一些不合理、不严谨之处,减少一些怪异行为;</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">消除代码运行的一些不安全之处,保证代码运行的安全;</span></li>\n</ol>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">默认支持的糟糕特性都会被禁用，比如不能用with</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">严格模式下的eval函数的行为和非严格模式的也不相同</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">也不能在意外的情况下给全局变量赋值;全局变量的显示声明;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">函数必须声明在顶层，不允许在非函数代码块内声明函数,</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">限制函数中的arguments修改;arguments.callee也不允许使用；</span></li>\n</ul>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"3\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">提高编译器效率,增加运行速度;</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">为未来新版本的Javascript做好铺垫。</span></li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">注：经过测试 IE6,7,8,9 均不支持严格模式。</span></p>\n<h2 id=\"缺点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">缺点</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">现在网站的 JS 都会进行压缩,一些文件用了严格模式,而另一些没有。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这时这些本来是严格模式的文件,被 merge 后,这个串就到了文件的中间,不仅没有指示严格模式,反而在压缩后浪费了字节。</span></p>","rank_id":348,"createdAt":"2021-06-16T03:28:26.862Z","updatedAt":"2021-06-16T03:28:26.862Z","__v":0},{"_id":"60c970097d119d797cb7b7af","title":"JavaScript 如何获取UA","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"核心\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">核心</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">获取用户浏览器/代理设备，这个是属于BOM部分的</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">主要考察对&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">navigator</code>&nbsp;的理解</p>\n<h2 id=\"代码\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">代码</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">封装一个 browser() 方法</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">为了方便使用，这里创建一个方法来返回浏览器的检查结果。返回结果包含有如下属性：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">webkit：webkit 版本号。如果浏览器为非 webkit 内核，此属性为 undefined。</li>\n<li style=\"padding: 0px; margin: 0px;\">chrome：chrome 浏览器版本号。如果浏览器为 chrome，此属性为 undefined。</li>\n<li style=\"padding: 0px; margin: 0px;\">ie：ie 浏览器版本号。如果浏览器为非 ie，此属性为 undefined。暂不支持 ie10+</li>\n<li style=\"padding: 0px; margin: 0px;\">firefox：firefox 浏览器版本号。如果浏览器为非 firefox，此属性为 undefined。</li>\n<li style=\"padding: 0px; margin: 0px;\">safari：safari 浏览器版本号。如果浏览器为非 safari，此属性为 undefined。</li>\n<li style=\"padding: 0px; margin: 0px;\">opera：opera 浏览器版本号。如果浏览器为非 opera，此属性为 undefined。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">新版本webkit 内核\n<pre class=\"language-javascript\"><code>// 浏览器检查结果\nfunction browser() {\n  var ua = navigator.userAgent;\n  var ret = {},\n      webkit = ua.match( /WebKit\\/([\\d.]+)/ ),\n      chrome = ua.match( /Chrome\\/([\\d.]+)/ ) ||\n          ua.match( /CriOS\\/([\\d.]+)/ ),\n \n      ie = ua.match( /MSIE\\s([\\d\\.]+)/ ) ||\n          ua.match( /(?:trident)(?:.*rv:([\\w.]+))?/i ),\n      firefox = ua.match( /Firefox\\/([\\d.]+)/ ),\n      safari = ua.match( /Safari\\/([\\d.]+)/ ),\n      opera = ua.match( /OPR\\/([\\d.]+)/ );\n \n  webkit &amp;&amp; (ret.webkit = parseFloat( webkit[ 1 ] ));\n  chrome &amp;&amp; (ret.chrome = parseFloat( chrome[ 1 ] ));\n  ie &amp;&amp; (ret.ie = parseFloat( ie[ 1 ] ));\n  firefox &amp;&amp; (ret.firefox = parseFloat( firefox[ 1 ] ));\n  safari &amp;&amp; (ret.safari = parseFloat( safari[ 1 ] ));\n  opera &amp;&amp; (ret.opera = parseFloat( opera[ 1 ] ));\n  return ret;\n}\nbrowser()</code></pre>\n</li>\n</ul>\n</li>\n</ul>","rank_id":349,"createdAt":"2021-06-16T03:29:13.991Z","updatedAt":"2021-06-16T03:29:13.991Z","__v":0},{"_id":"60c9703a7d119d797cb7b7b0","title":"JavaScript eval是做什么的?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">eval()</code>函数,这个函数可以把一个字符串当作一个JavaScript表达式一样去执行它。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">它的功能是把对应的字符串解析成JS代码并运行;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">应该避免使用eval,不安全,耗性能（2次,一次解析成js语句,一次执行）。</p>","rank_id":350,"createdAt":"2021-06-16T03:30:02.668Z","updatedAt":"2021-06-16T03:30:02.668Z","__v":0},{"_id":"60c9707c7d119d797cb7b7b1","title":"JavaScript 对象的深度克隆代码实现;","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"原理\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">原理</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">使用JSON实现，或者使用递归来实现</span></p>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">深拷贝代码</span></h2>\n<pre class=\"language-javascript\"><code>function clone(obj){\n    if(typeof(obj) != 'object') return obj;\n    var r = Array.prototype.splice === obj.splice ? []:{};\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)){\n            r[i] = clone(obj[i]);\n        }\n    }\n    return r;\n}\n//数组、对象都可以for in,同时针对对象必须需要判断hasOwnProperty属性,以防克隆原型链上的属性</code></pre>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">浅拷贝</span></h2>\n<pre class=\"language-javascript\"><code>Object.assign()</code></pre>\n<h2 id=\"浅拷贝\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>\n<h2 id=\"深拷贝代码\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":351,"createdAt":"2021-06-16T03:31:08.125Z","updatedAt":"2021-06-16T03:31:08.125Z","__v":0},{"_id":"60c970a67d119d797cb7b7b2","title":"浏览器的严格模式与混杂模式","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<h2 id=\"严格模式\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">严格模式</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">又称标准模式，是指浏览器按照 W3C 标准解析代码。</span></p>\n<h2 id=\"混杂模式\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">混杂模式</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。</span></p>\n<h2 id=\"区分\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">区分</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD(Document Type Definition) 直接相关。</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD &mdash;&mdash;严格模式）</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD &mdash;&mdash;严格模式；没有 URI 的过渡 DTD &mdash;&mdash;混杂模式）</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确&mdash;&mdash;混杂模式）</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）</span></p>\n</li>\n</ul>\n<h2 id=\"意义\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">意义</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。</span></p>","rank_id":352,"createdAt":"2021-06-16T03:31:50.113Z","updatedAt":"2021-06-16T03:31:50.113Z","__v":0},{"_id":"60c970c57d119d797cb7b7b3","title":"JavaScript 谈谈 this 对象的理解","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;指的是调用函数的那个对象</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;在没有运行之前不能知道代表谁;js的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;指向是不确定的；和定义没有关系，和执行有关，</li>\n<li style=\"padding: 0px; margin: 0px;\">执行的时候，点前面是谁，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;就是谁；自执行函数里面的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;代表的是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">window</code></li>\n<li style=\"padding: 0px; margin: 0px;\">定时器书写的时候，window可以省略掉；定时器执行的时候，里面的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;代表的也是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">window</code>&nbsp;；</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;是js的一个关键字，随着函数使用场合不同，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;的值会发生变化。</li>\n</ul>\n<h3 id=\"总原则\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">总原则</h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;指的是调用函数的那个对象,如果没有被调用，则未知。</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;一般情况下：是全局对象Global。 作为方法调用，那么<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;就是指这个对象</li>\n</ul>","rank_id":353,"createdAt":"2021-06-16T03:32:21.137Z","updatedAt":"2021-06-16T03:32:21.137Z","__v":0},{"_id":"60c971267d119d797cb7b7b4","title":"JavaScript 什么是window对象? 什么是document对象?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">document 是 window 的一个对象属性。</li>\n<li style=\"padding: 0px; margin: 0px;\">window 对象表示浏览器中打开的窗口。</li>\n<li style=\"padding: 0px; margin: 0px;\">如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。</li>\n<li style=\"padding: 0px; margin: 0px;\">所有的全局函数和对象都属于Window 对象的属性和方法。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">例如，可以只写 document，而不必写 window.document。</li>\n<li style=\"padding: 0px; margin: 0px;\">同样，可以把当前窗口对象的方法当作函数来使用，如只写 alert()，而不必写 Window.alert()。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">document 对 Document 对象的只读引用。</li>\n</ul>","rank_id":354,"createdAt":"2021-06-16T03:33:58.626Z","updatedAt":"2021-06-16T03:33:58.626Z","__v":0},{"_id":"60c971837d119d797cb7b7b5","title":"JavaScript tepyof(null)返回什么","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">返回&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">object</code></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">请注意，这个是因为typeof的特殊，因为null本身属于Object；万物皆对象；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">但是typeof返回的不准确；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一般面试官可能会追着问，如何做精准的判断；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">那么这个时候，你需要了解下面这个；</p>\n<h2 id=\"扩展如何精确判断null类型\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">扩展：如何精确判断null类型</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">核心代码</p>\n<pre class=\"language-javascript\"><code>Object.prototype.toString.call(data)</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">封装如下</span></p>\n<pre class=\"language-javascript\"><code>let _typeof = function (data) {\n    let value = /\\[object (\\w+)\\]/.exec(\n        Object.prototype.toString.call(data)\n    );\n    return value ? value[1].toLowerCase() : '';\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">这时候判断</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">_typeof(null)</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">,返回的是&nbsp;</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">\"null\"</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">;</span></p>","rank_id":355,"createdAt":"2021-06-16T03:35:31.684Z","updatedAt":"2021-06-16T03:35:31.684Z","__v":0},{"_id":"60c971ca7d119d797cb7b7b6","title":"JavaScript [\"1\", \"2\", \"3\"].map(parseInt) 答案是多少","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">[1, NaN, NaN]</code></li>\n</ul>\n<p><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\"></code></p>\n<h2 id=\"原理解释\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">原理解释</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">map()</code>&nbsp;方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">map参考 :&nbsp;<a style=\"text-decoration-line: none; color: #900b09;\" href=\"https://www.axihe.com/api/js-es/ob-array/map.html\">https://www.axihe.com/api/js-es/ob-array/map.html</a></li>\n<li style=\"padding: 0px; margin: 0px;\">parseInt参考 :&nbsp;<a style=\"text-decoration-line: none; color: #900b09;\" href=\"https://www.axihe.com/api/js-es/ob-attr-fn/parse-int.html\">https://www.axihe.com/api/js-es/ob-attr-fn/parse-int.html</a></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">[1, NaN, NaN]</code>&nbsp;因为 parseInt 需要两个参数 (val, index) 但 map 传了 3 个 (element, index, array)</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">而&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">parseInt</code>&nbsp;需要两个参数中的 index 表示解析时用的基数。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">map 传了 3 个 (element, index, array)，对应的 index 不合法导致解析失败。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">下面的代码可以帮助你理解</p>\n<pre class=\"language-javascript\"><code>let _typeof = function (data) {\n  let value = /\\[object (\\w+)\\]/.exec(\n    Object.prototype.toString.call(data)\n  );\n  return value ? value[1].toLowerCase() : '';\n}\nvar kvArray = [\"1\", \"2\", \"3\"];\nvar reformattedArray = kvArray.map(function (arg1, arg2, arg3) {\n  console.log(`\n  arg1:${arg1}, ${_typeof(arg1)}\n  arg2:${arg2}, ${_typeof(arg2)}\n  arg3:${arg3}, ${_typeof(arg3)}\n  `)\n  return parseInt(arg1, arg2, arg3)\n});\nconsole.log('---', reformattedArray)</code></pre>","rank_id":356,"createdAt":"2021-06-16T03:36:42.782Z","updatedAt":"2021-06-16T03:36:42.782Z","__v":0},{"_id":"60c972127d119d797cb7b7b7","title":"JavaScript 作用链域","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">子域访问父域,函数可以限定变量的作用域，那么在函数中的函数就成为该作用域的子域.</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">在子域中的代码可以访问到父域中的变量. 有了JavaScript的作用域的划分，那么可以将JavaScript的访问作用域连成一个链式树状结构.</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">有了JavaScript的作用域的划分，那么可以将JavaScript的访问作用域连成一个链式树状结构.</span></li>\n</ul>\n<ol>\n<li style=\"list-style-type: none;\">\n<ol>\n<li><span style=\"font-size: 12pt;\">作用域链就是对象的数组</span></li>\n<li><span style=\"font-size: 12pt;\">全部script是0级链，每个对象占一个位置</span></li>\n<li><span style=\"font-size: 12pt;\">凡是看到函数延伸一个链出来，一级级展开</span></li>\n<li><span style=\"font-size: 12pt;\">访问首先看当前函数，如果没有定义往上一级链检查</span></li>\n<li><span style=\"font-size: 12pt;\">如此往复，直到0级链</span></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"引申什么是js作用域链\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">引申:什么是JS作用域链</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">全局函数无法查看局部函数的内部信息，但局部函数可以查看其上层的函数信息，直至全局信息。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">直至全局函数，这种组织形式就是作用域链。</span></li>\n</ul>","rank_id":357,"createdAt":"2021-06-16T03:37:54.710Z","updatedAt":"2021-06-16T03:37:54.710Z","__v":0},{"_id":"60c9727b7d119d797cb7b7b8","title":"JavaScript 的作用域与变量声明提升","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">作用域\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">就是作用域里面套作用域；也就是闭包的机制；子集作用域可以访问父级作用域，父级不能访问子级；</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">变量提升\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">作用域里面的带var的这些是该作用域的，如果没有某个变量直接到上一级查找；如果不在var声明，就直接变为上一级作用域的变量；</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">javascript中一个名字(name)以四种方式进入作用域(scope)，其优先级顺序如下：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">1、语言内置：所有的作用域中都有&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;和&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments</code>&nbsp;关键字</li>\n<li style=\"padding: 0px; margin: 0px;\">2、形式参数：函数的参数在函数作用域中都是有效的</li>\n<li style=\"padding: 0px; margin: 0px;\">3、函数声明：形如<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">function foo() {}</code></li>\n<li style=\"padding: 0px; margin: 0px;\">4、变量声明：形如<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">var bar</code>&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">let aaa</code>;</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">名字声明的优先级如上所示;\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">就是说如果一个变量的名字与函数的名字相同，那么函数的名字会覆盖变量的名字，无论其在代码中的顺序如何。</li>\n<li style=\"padding: 0px; margin: 0px;\">但名字的初始化却是按其在代码中书写的顺序进行的，不受以上优先级的影响。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">命名函数表达式\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">可以像函数声明一样为函数表达式指定一个名字，但这并不会使函数表达式成为函数声明。</li>\n<li style=\"padding: 0px; margin: 0px;\">命名函数表达式的名字不会进入名字空间，也不会被提升。</li>\n<li style=\"padding: 0px; margin: 0px;\">命名函数表达式的名字只在该函数的作用域内部有效。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">javascript中则是这样</li>\n<li style=\"padding: 0px; margin: 0px;\">var v;//声明变量v</li>\n<li style=\"padding: 0px; margin: 0px;\">v = &ldquo;hello&rdquo;;//(定义并)初始化变量v</li>\n</ul>\n</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">因为javascript为动态语言，其变量并没有固定的类型，其存储空间大小会随初始化与赋值而变化，所以其变量的&ldquo;定义&rdquo;就不像传统的静态语言一样了，其定义显得无关紧要。</li>\n</ul>","rank_id":358,"createdAt":"2021-06-16T03:39:39.744Z","updatedAt":"2021-06-16T03:39:39.744Z","__v":0},{"_id":"60c972a27d119d797cb7b7b9","title":"JavaScript 如何判断一个对象是否属于某个类","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">instanceof 用于判断一个变量是否某个对象的实例；</span></p>\n<pre class=\"language-javascript\"><code>function Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\nvar auto = new Car('Honda', 'Accord', 1998);\nconsole.log(auto instanceof Car);\n// expected output: true\nconsole.log(auto instanceof Object);\n// expected output: true</code></pre>","rank_id":359,"createdAt":"2021-06-16T03:40:18.467Z","updatedAt":"2021-06-16T03:40:18.467Z","__v":0},{"_id":"60c972f77d119d797cb7b7ba","title":"JavaScript原型，原型链 ? 有什么特点","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h3 id=\"原型原型链\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">原型，原型链</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><strong>函数的原型，每个函数都有一个原型；</strong></span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">在JavaScript中,一共有两种类型的值,原始值和对象值.每个对象都有一个内部属性&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">prototype</code>,我们通常称之为原型.</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">原型的值可以是一个对象,也可以是null.</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">如果它的值是一个对象,则这个对象也一定有自己的原型.</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">这样就形成了一条线性的链,我们称之为原型链.</span></li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">访问一个对象的原型可以使用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Object.getPrototypeOf</code>方法,或者<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">__proto__</code>属性.</span></li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">原型向上查找的过程属于原型链；</span></li>\n</ul>\n<h3 id=\"特点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">特点</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">可以向上查找，不能向下查找</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">我们没有办法遍历到所有以某个对象为原型的对象,但我们可以向上遍历,获取到一个对象所有的上层原型,这个原型链必定是线性的,尽头是null；</span></li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">原型链的作用是用来实现继承的；</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">原型链的作用是用来实现继承,比如我们新建一个数组,数组的方法就是从数组的原型上继承而来的.</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">虽然我们都说原型链,但实际上,在不考虑网页中frame的情况,js引擎在执行期间的某一时刻,所有存在的对象组成的是一棵原型树.默认情况下,只有一棵树.根节点可以说是Object.prototype,也可以说是null.</span></li>\n</ul>\n</li>\n</ul>","rank_id":360,"createdAt":"2021-06-16T03:41:43.154Z","updatedAt":"2021-06-16T03:41:43.154Z","__v":0},{"_id":"60c973997d119d797cb7b7bb","title":"Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">hasOwnProperty</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">，相关的一个</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">isPrototypeOf</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">是判断是否是实例</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。</li>\n</ul>\n</li>\n</ul>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">使用方法</h3>\n<pre class=\"language-javascript\"><code>object.hasOwnProperty(proName)</code></pre>\n<p><span class=\"mce-nbsp-wrap\" contenteditable=\"false\">&nbsp;</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">其中参数&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">object</code>&nbsp;是必选项。一个对象的实例。</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">proName</code>&nbsp;是必选项。一个属性名称的字符串值。</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">obj.hasOwnProperty(attr)</code></li>\n<li style=\"padding: 0px; margin: 0px;\">如果&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">object</code>&nbsp;具有指定名称的属性，那么<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">hasOwnProperty</code>函数方法返回&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">true</code>&nbsp;，反之则返回&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">false</code>&nbsp;。</li>\n</ul>\n<h3 id=\"使用方法\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>","rank_id":361,"createdAt":"2021-06-16T03:44:25.244Z","updatedAt":"2021-06-16T03:44:25.244Z","__v":0},{"_id":"60c973cc7d119d797cb7b7bc","title":"用原生JavaScript的实现过什么功能吗","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">用原生JavaScript的实现过什么功能吗</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这主要考察你的对原生JS的应用，可以回答你正常写过的案例；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果没有写过就不要说；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">建议平时多积累；多做些轮子；一般是考察实现的逻辑；</p>","rank_id":362,"createdAt":"2021-06-16T03:45:16.654Z","updatedAt":"2021-06-16T03:45:16.654Z","__v":0},{"_id":"60c974267d119d797cb7b7bd","title":"JavaScript 解释下面这段代码的意思 / 给所有HTML层添加一个高亮的边框","code":"<ol class=\"linenums\" style=\"padding: 0px 0px 0px 10px; margin: 0px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace; font-size: 14px; color: #f8f8f2; white-space: pre;\">\n<li class=\"L0\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\">\n<pre class=\"language-javascript\"><code>[].forEach.call($$(\"*\"), function (a) {\na.style.outline = \"1px solid #\" + (~~(Math.random() * (1 &lt;&lt; 24))).toString(16)\n})</code></pre>\n</li>\n</ol>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在你的Chrome浏览器的控制台中输入这段代码，你会发现不同HTML层都被使用不同的颜色添加了一个高亮的边框。是不是非常酷？但是，简单来说，这段代码只是首先获取了所有的页面元素，然后使用一个不同的颜色为它们添加了一个1ps的边框。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$$(\"*\")</code>&nbsp;函数是现代浏览器命令行的API的一部分，它等同于使用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">document.querySelectorAll</code> 方法。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">你可以将一个CSS选择器作为参数传入<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">document.querySelectorAl</code>l去选取当前页面的元素。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">所以如果你想在浏览器的控制台以外使用那个单行代码，你可以用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">document.querySelectorAll('*')</code>来替代</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">[].forEach.call</code>是借助数组的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">forEach</code>方法</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这个可以用来分析HTML的层级</p>","rank_id":363,"createdAt":"2021-06-16T03:46:46.799Z","updatedAt":"2021-06-16T03:46:46.799Z","__v":0},{"_id":"60c974437d119d797cb7b7be","title":"把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">从实际效果来看，是没有区别的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">但是放在 html 结束标签之前应该是不规范的(通不过 HTML 验证)，放在 body 结束之前才对。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当然你完全可以选择无视验证。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">dom树是根据html生成的，js放在底部是因为放在头部很容易导致getElementById得到一个空的元素，因为那个时候dom树都不存在</p>\n<h2 id=\"扩展script标签的位置会影响首屏时间么\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">扩展:script标签的位置会影响首屏时间么？</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">答案是：不影响但有可能截断首屏的内容，使其只显示上面一部分；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果这里里的首屏指的是页面完全显示，并且用户可以交互</p>","rank_id":364,"createdAt":"2021-06-16T03:47:15.270Z","updatedAt":"2021-06-16T03:47:15.270Z","__v":0},{"_id":"60c974637d119d797cb7b7bf","title":"什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h3 id=\"什么是前端路由\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">什么是前端路由</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">接收前端请求url</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">比如前端的地址栏是&nbsp;<a style=\"text-decoration-line: none; color: #900b09;\" href=\"http://www.xxx.com/show;\">www.xxx.com/show;</a></span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">这个地址没准请求的是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">www.xxx.com/aaa</code></span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">那么对于后端来说接收的是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">www.xxx.com/aaa</code>&nbsp;而不是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">www.xxx.com/show</code></span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">无论前端还是后端，我们看到的URL都是马甲，需要通过路由触发/执行真实需要执行的逻辑路径</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">你看到的不一定是真实的。也为以后的业务变更提供了回旋的余地</span></li>\n</ul>\n<h2 id=\"应用场景在哪里\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">应用场景在哪里</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">前端路由应用场景就是所谓的单页应用。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在业务允许浏览器允许的情况下使用前端路由可以让页面体验较好。但是在例如很多业务情景下就不适用了;</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">例如展示广告，几乎不需要在页面上有其他逻辑，例如严谨的下单流程，后端路由可以严格控制前端不可进入页面;</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">还有后端路由可以应用于API层面提供接口等等许多的场景都是可以的。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">灵活选择前后端路由会让你的业务体验相当不错，或者更深层次的你用到了同构，前后端共用一套路由，在直接由回车进入页面时将这套路由在服务端渲染输出，但是页面点击跳转等动作时又是前端路由&hellip;</span></p>","rank_id":365,"createdAt":"2021-06-16T03:47:47.015Z","updatedAt":"2021-06-16T03:47:47.015Z","__v":0},{"_id":"60c9749f7d119d797cb7b7c0","title":"知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">chrome, F12。这是最常用的方案。</p>\n<h3 id=\"webkit-是浏览器引擎\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">Webkit 是浏览器引擎</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">包括 html 渲染和 js 解析功能，手机浏览器的主流内核，与之相对应的引擎有 Gecko（Mozilla Firefox 等使用）和 Trident（也称 MSHTML，IE 使用）。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于浏览器的调试工具要熟练使用，主要是页面结构分析，后台请求信息查看，js 调试工具使用，熟练使用这些工具可以快速提高解决问题的效率</p>","rank_id":366,"createdAt":"2021-06-16T03:48:47.590Z","updatedAt":"2021-06-16T03:48:47.590Z","__v":0},{"_id":"60c974c77d119d797cb7b7c1","title":"前端开发常用的IE，firefox上的调试工具；分别举例说明用法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Chrome 的调试工具用的最多，也是用的最舒服的一个。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">VSCode + Chrome 应该是大家比较认可的前端开发套装之一。</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">Chrome 的调试工具，其中的亮点有：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">移动设备模拟、多分辨率模拟、多种网络情况模拟；</li>\n</ol>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\" start=\"2\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">Mobile Chrome/Webview 调试；</li>\n</ol>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\" start=\"3\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">workspace 和代码编辑保存；</li>\n</ol>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\" start=\"4\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">性能监测；</li>\n</ol>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\" start=\"5\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">交互式 JavaScript 执行 等。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">现在火狐，新版本的IE等都是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Chromium</code>&nbsp;的内核，用法差不多了；</p>","rank_id":367,"createdAt":"2021-06-16T03:49:27.246Z","updatedAt":"2021-06-16T03:49:27.246Z","__v":0},{"_id":"60c975217d119d797cb7b7c2","title":"JavaScript 如何outerHTML,注意浏览器兼容性","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">uterHTML可以用来更改或获取元素内所有的html和文本内容，包含引用该方法元素自身的标签．</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">innerHTML是用来获取元素内的html内容和文本．</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">innerText只获取元素内的文本内容，html标签将被忽略．</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">以上三者方法类似大家不要混淆．</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">注意outerHTML、innerText不是W3C标准，使用时请注意浏览器兼容性！</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">使用innerHTML的时候将找着元素的内容（不包含元素本身）</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">使用outerHTML的时候将找着元素的内容（包含元素本身）</p>\n</li>\n</ul>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">jquery获取和设置outerHTML</h2>\n<pre class=\"language-javascript\"><code>$('textarea').prop('outerHTML');\n$('textarea').prop('outerHTML', '&lt;input&gt;');</code></pre>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">原生JS获取和设置outerHTML的方法</h2>\n<pre class=\"language-javascript\"><code>document.getElementById('anbang').outerHTML = '&lt;textarea id=\"anbang\"&gt;&lt;hr&gt;原生DOM设置outerHTML&lt;/textarea&gt;';</code></pre>\n<h2 id=\"原生js获取和设置outerhtml的方法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>\n<h2 id=\"jquery获取和设置outerhtml\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":368,"createdAt":"2021-06-16T03:50:57.805Z","updatedAt":"2021-06-16T03:50:57.805Z","__v":0},{"_id":"60c9754c7d119d797cb7b7c3","title":"JavaScript (new Date).getTime() 和 +new Date() 都可以取到当前时间戳，它们的实现原 理是什么，哪个效率更高？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">js中单独调用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">new Date()</code>; 显示这种格式&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Thu Mar 05 2020 14:52:28 GMT+0800 (中国标准时间)</code>；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><strong>但是用new Date() 参与计算会自动转换为从1970.1.1开始的毫秒数</strong></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">第一种写法所耗的时间基本上只有第二种写法的一半。<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Date.getTime()</code>&nbsp;这个函数本身实际上等价于 valueOf。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为第一种方法实际上直接调用了 valueOf ，而第二种方法涉及到JS内部的类型转换，尽管最终的结果也是调用了 valueOf 函数，但是毕竟有个转换的过程，所以效率理应比前者要来的低。</p>","rank_id":369,"createdAt":"2021-06-16T03:51:40.350Z","updatedAt":"2021-06-16T03:51:40.350Z","__v":0},{"_id":"60c9756c7d119d797cb7b7c4","title":"JavaScript 查找页面所有类是edit的input，且type是text的元素，遍历他们并返回他们的value","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var values = [];\n$(\"input[type=text][.edit]\").each(function (i, d) {\n  values.push($(d).val());\n});</code></pre>","rank_id":370,"createdAt":"2021-06-16T03:52:12.753Z","updatedAt":"2021-06-16T03:52:12.753Z","__v":0},{"_id":"60c975e97d119d797cb7b7c5","title":"请设计一个 JavaScript 函数，该函数接受一个 CSS 属性名作为参数，并返回一个 boolean 值，表明浏览器是否支持这个属性","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">首先看单个怎么来判断，可以下面这种的；</span></p>\n<pre class=\"language-javascript\"><code>var element = document.createElement('div');\nif ('text-overflow' in element.style) {\n  element.style['text-overflow'] = 'ellipsis';\n  return element.style['text-overflow'] === 'ellipsis';\n} else {\n  return false;\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">然后开始封装</span></p>\n<pre class=\"language-javascript\"><code>var supports = (function () {\n  var div = document.createElement('div'),\n    vendors = 'Khtml Ms O Moz Webkit'.split(' '),\n    len = vendors.length;\n  return function (prop) {\n    if (prop in div.style) return true;\n    prop = prop.replace(/^[a-z]/, function (val) {\n      return val.toUpperCase();\n    });\n    while (len--) {\n      if (vendors[len] + prop in div.style) {\n        // browser supports box-shadow. Do what you need.\n        // Or use a bang (!) to test if the browser doesn't.\n        return true;\n      }\n    }\n    return false;\n  };\n})();\nif (supports('textShadow')) {\n  document.documentElement.className += ' textShadow';\n}</code></pre>","rank_id":371,"createdAt":"2021-06-16T03:54:17.712Z","updatedAt":"2021-06-16T03:54:17.712Z","__v":0},{"_id":"60c976197d119d797cb7b7c6","title":"如何让 input 元素在默认情况下显示“alipay WD Team”，而在光标移入后则显示空白？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">css3&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">placeholder</code>&nbsp;必须输入文字才会消失，所以不行，用 JS 实现</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">核心代码如下</p>\n<pre class=\"language-javascript\"><code>onblur = this.value == '' ? this.defaultValue : this.value\nonfocus = this.value == this.defaultValue ? '' : this.value</code></pre>","rank_id":372,"createdAt":"2021-06-16T03:55:05.039Z","updatedAt":"2021-06-16T03:55:05.039Z","__v":0},{"_id":"60c9767b7d119d797cb7b7c7","title":"JavaScript console(Function instanceof Object); 和这个alert(Object instanceof Function);分别是什么结果","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">结果都是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">return true</code>；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Object, Function, Array等等这些都被称作是构造&ldquo;函数&rdquo;，他们都是函数。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">而所有的函数都是构造函数Function的实例。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的Function构造函数的构造原型Function.protorype对象，所以：</p>\n<pre class=\"language-javascript\"><code>alert(Object instanceof Function);   // return true</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">与此同时，又因为<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Function.prototype</code>是一个对象，所以他的构造函数是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Object</code>.</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">从原型链机制的的角度来说，那就是说所有的函数都能通过原型链找到创建他们的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Object</code>构造函数的构造原型<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Object.prototype</code>对象，所以：</p>\n<pre class=\"language-javascript\"><code>alert(Function instanceof Object);   // return true</code></pre>","rank_id":373,"createdAt":"2021-06-16T03:56:43.124Z","updatedAt":"2021-06-16T03:56:43.124Z","__v":0},{"_id":"60c976c37d119d797cb7b7c8","title":"JavaScript 请至少写出2种方法，不通过第三个中间变量，交换2个变量的值","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var a = 2;\nvar b = 5;\na = a + b;\nb = a - b;\na = a - b;\nconsole.log(a, b);//5 2</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">上面的加法换成乘法和除法也可以的；</span></p>\n<pre class=\"language-javascript\"><code>var a = 2;\nvar b = 5;\na = b / a;\nb = b / a;\na = b * a;\nconsole.log(a, b);//5 2</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">扩展：JS运算的精度问题</span></p>","rank_id":374,"createdAt":"2021-06-16T03:57:55.193Z","updatedAt":"2021-06-16T03:57:55.193Z","__v":0},{"_id":"60c976e37d119d797cb7b7c9","title":"JavaScript 你了解 arguments 对象么,它有哪些属性?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在函数体内，标识符&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments</code>&nbsp;是指向实参对象的引用，实参对象是一个类数组对象&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments[0]</code>&nbsp;，&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments.length</code>&nbsp;；有legth属性；</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments</code>&nbsp;是收到的实参副本；在词法分析中, 首先按形参形成AO的属性,值为undefined，当实参传来时, 再修改AO的相应属性.</li>\n<li style=\"padding: 0px; margin: 0px;\">并把所有收到实参收集起来,放到一个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments</code>&nbsp;对象，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">t(a,b,c){}</code>,调用时:&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">t(1,2,3,4,5)</code>&nbsp;5个参数；此时 , AO属性只有a,bc,3个属性,&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments</code>&nbsp;里有1,2,3,4,5, 所有的值，对于超出形参个数之外的实参, 可以通过&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments</code>&nbsp;来获得</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments</code>&nbsp;的索引 从 0, 1,2,&hellip;.递增,与实参逐个对应</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments.length</code>&nbsp;属性代表实参的个数</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments</code>&nbsp;一定不是数组, 是长的比较像数组的一个对象,虽然也有length属性</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments</code>&nbsp;每个函数都会有,因此,arguemnts只会在内部找自身的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments</code>&nbsp;,无法引用到外层的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">arguments</code></li>\n</ul>","rank_id":375,"createdAt":"2021-06-16T03:58:27.045Z","updatedAt":"2021-06-16T03:58:27.045Z","__v":0},{"_id":"60c977157d119d797cb7b7ca","title":"JavaScript arguments 是数组么?如果不是请写一段代码将其转化为真正的数组,什么情 况下需要这么做?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">不是数组，但是有length属性；</span></p>\n<pre class=\"language-javascript\"><code>function test () {\n  var a = [].slice.call(arguments);\n  console.log(a)\n}</code></pre>\n<h2 id=\"什么情况下需要这么做\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">什么情况下需要这么做</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">aarguments</code>&nbsp;需要借用数组方法的时候；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">以及参数的数量不确定时；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">比如求很多个评分的平均数时候；</span></p>","rank_id":376,"createdAt":"2021-06-16T03:59:17.965Z","updatedAt":"2021-06-16T03:59:17.965Z","__v":0},{"_id":"60c9772e7d119d797cb7b7cb","title":"JavaScript arguments 有什么特性,可以用这些特性做什么?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">函数的实参，函数只在本函数内查找，不去上层查找；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">arguments有隐私性；和变量不一样；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可以用这个属性来实现函数的多态；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">同一个函数来做不同的功能；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">比如一个参数的时候是获取，两个是设置；</p>","rank_id":377,"createdAt":"2021-06-16T03:59:42.672Z","updatedAt":"2021-06-16T03:59:42.672Z","__v":0},{"_id":"60c977d17d119d797cb7b7cc","title":"Javascript创建对象的几种方式","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">工厂模式</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">构造函数模式</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">原型模式</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">混合构造函数和原型模式</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">动态原型模式</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">寄生构造函数模式</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">稳妥构造函数模式</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象. 当然还可以用JSON；但写法有很多种. 也能混合使用。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">1、对象字面量的方式</p>\n<pre class=\"language-javascript\"><code>person={\n  firstname:\"zhu\",\n  lastname:\"anbang\",\n  age:25,\n  eyecolor:\"black\"};</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">2、用function来模拟无参的构造函数</span></p>\n<pre class=\"language-javascript\"><code>function Person(){}\n    var person=new Person();//定义一个function. 如果使用new\"实例化\",该function可以看作是一个Class\n    person.name=\"zhu\";\n    person.age=\"25\";\n    person.work=function(){\n      alert(person.name+\" hello...\");\n}\nperson.work();</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">3.用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</span></p>\n<pre class=\"language-javascript\"><code>function Pet(name,age,hobby){\n    this.name=name;//this作用域：当前对象\n    this.age=age;\n    this.hobby=hobby;\n    this.eat=function(){\n      alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\");\n    }\n}\nvar maidou =new Pet(\"麦兜\",25,\"coding\");//实例化、创建对象\nmaidou.eat();//调用eat方法</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">4、用工厂方式来创建（内置对象）</span></p>\n<pre class=\"language-javascript\"><code>var wcDog =new Object();\nwcDog.name=\"旺财\";\nwcDog.age=3;\nwcDog.work=function(){\n  alert(\"我是\"+wcDog.name+\",汪汪汪......\");\n}\nwcDog.work();</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">5.用原型方式来创建</span></p>\n<pre class=\"language-javascript\"><code>function Dog(){}\nDog.prototype.name=\"旺财\";\nDog.prototype.eat=function(){\nalert(this.name+\"是个吃货\");\n}\nvar wangcai =new Dog();\nwangcai.eat();</code></pre>\n<p>6.<span style=\"background-color: #ffffff; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px;\">用混合方式来创建</span></p>\n<pre class=\"language-javascript\"><code>function Car(name,price){\n  this.name=name;\n  this.price=price; \n}\nCar.prototype.sell=function(){\n  alert(\"我是\"+this.name+\". 我现在卖\"+this.price+\"万元\");\n}\nvar camry =new Car(\"凯美瑞\",27);\ncamry.sell();</code></pre>","rank_id":378,"createdAt":"2021-06-16T04:02:25.139Z","updatedAt":"2021-06-16T04:02:25.139Z","__v":0},{"_id":"60c97b8a7d119d797cb7b7cf","title":"用JavaScript实现单利模式的所有实现方式，用说明各种实现方法区别？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">实现1： 最简单的对象字面量</h3>\n<pre class=\"language-javascript\"><code>var singLeton = {\n  attr: 1,\n  method: function () {\n    return this.attr;\n  }\n}\nvar t1 = singLeton;\nvar t2 = singLeton;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">t1 === t2</code>&nbsp;十分简单，并且非常使用，不足之处在于没有什么封装性，所有的属性方法都是暴露的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于一些需要使用私有变量的情况就显得心有余而力不足了。当然在对于 this 的问题上也是有一定弊端的。</p>\n<h3 id=\"实现2构造函数内部判断\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">实现2：构造函数内部判断</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">其实和最初的JS实现有点类似，不过是将对是否已经存在该类的实例的判断放入构造函数内部。</p>\n<pre class=\"language-javascript\"><code>function Construct () {\n  //确保只有单例\n  if (Construct.unique !== undefined) {\n    return Construct.unique;\n  }\n  //其他代码\n  this.name = 'anhang';\n  this.age = '25';\n  Construct.unique = this;\n}\nvar t1 = new Construct();\nvar t2 = new Construct();</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">那么也有的， t1 === t2 。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">也是非常简单，无非就是提出一个属性来做判断，但是该方式也没有安全性，一旦我在外部修改了Construct的unique属性，那么单例模式也就被破坏了。</p>\n<h3 id=\"实现3--闭包方式\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">实现3 : 闭包方式</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于 灵活的JS来说，任何问题都能找到 n 种答案，只不过让我自己去掂量孰优孰劣而已，下面就简单的举几个使用闭包实现单例模式的方法，无非也就是将创建了的单例缓存而已。</p>\n<pre class=\"language-javascript\"><code>var single = (function () {\n  var unique;\n  function Construct () {\n    //确保只有单例\n    if (Construct.unique !== undefined) {\n      return Construct.unique;\n    }\n    //其他代码\n    this.name = 'anhang';\n    this.age = '25';\n    Construct.unique = this;\n  }\n  unique = new Construct();\n  return unique;\n})()</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">只要 每次讲&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">var t1 = single; var t2 = single;</code>即可。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">与对象字面量方式类似。不过相对而言更安全一点，当然也不是绝对安全。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果希望会用调用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">single()</code>&nbsp;方式来使用，那么也只需要将内部的 return 改为</p>\n<pre class=\"language-javascript\"><code>return function(){\n    return unique;\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">以上方式也可以使用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">new</code>&nbsp;的方式来进行（形式主义的）。当然这边只是给了闭包的一种例子而已，也可以在 Construct 中判断单例是否存在 等等。 各种方式在各个不同情况做好选着即可。</p>\n<h2 id=\"总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">总结</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">总的来说，单例模式相对而言是各大模式中较为简单的，但是单例模式也是较为常用并且很有用的模式。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在JS中尤为突出（每个对象字面量都可以看做是一个单例么~）。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">记住，是否严格的只需要一个实例对象的类（虽然JS没有类的概念），那么就要考虑使用单例模式。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">使用数据缓存来存储该单例，用作判断单例是否已经生成，是单例模式主要的实现思路。</p>\n<h3 id=\"实现1-最简单的对象字面量\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>","rank_id":379,"createdAt":"2021-06-16T04:18:18.970Z","updatedAt":"2021-06-16T04:18:18.970Z","__v":0},{"_id":"60c97c277d119d797cb7b7d0","title":"JavaScript 继承的实现方法有哪些？分别怎么写？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">js实现继承的5种方式;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">根据js语言的本身的特性,js实现继承有以下通用的几种方式;</p>\n<h2 id=\"1-使用对象冒充实现继承\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">1. 使用对象冒充实现继承</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">该种实现方式可以实现多继承</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">实现原理:让父类的构造函数成为子类的方法,然后调用该子类的方法,通过this关键字给所有的属性和方法赋值</p>\n<pre class=\"language-javascript\"><code>function Parent (firstname) {\n  this.fname = firstname;\n  this.age = 30;\n  this.sayAge = function () {\n    console.log(this.age)\n  }\n}\nfunction Child (firstname) {\n  this.parent = Parent;\n  this.parent(firstname);\n  delete this.parent;\n  this.saySomeThing = function () {\n    console.log(this.fname)\n    this.sayAge();\n  }\n}\nvar mychild = new Child('anbang')\nmychild.saySomeThing();</code></pre>\n<h2 id=\"2-采用call方法改变函数上下文实现继承\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">2. 采用call方法改变函数上下文实现继承</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">该种方式不能继承原型链,若想继承原型链，则采用5混合模式</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">实现原理:改变函数内部的函数上下文this,使它指向传入函数的具体对象;</p>\n<pre class=\"language-javascript\"><code>function Parent (firstname) {\n  this.fname = firstname;\n  this.age = 30;\n  this.sayAge = function () {\n    console.log(this.age)\n  }\n}\nfunction Child (firstname) {\n  this.saySomeThing = function () {\n    console.log(this.fname)\n    this.sayAge();\n  }\n  this.getName = function () {\n    return firstname;\n  }\n}\nvar child = new Child('anbang')\nParent.call(child, child.getName())\nchild.saySomeThing();</code></pre>\n<h2 id=\"3-采用apply方法改变函数上下文实现继承\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">3. 采用Apply方法改变函数上下文实现继承</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">该种方式不能继承原型链,若想继承原型链，则采用5混合模式</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">实现原理:改变函数内部的函数上下文this,使它指向传入函数的具体对象</p>\n<pre class=\"language-javascript\"><code>function Parent (firstname) {\n  this.fname = firstname;\n  this.age = 30;\n  this.sayAge = function () {\n    console.log(this.age)\n  }\n}\nfunction Child (firstname) {\n  this.saySomeThing = function () {\n    console.log(this.fname)\n    this.sayAge();\n  }\n  this.getName = function () {\n    return firstname;\n  }\n}\nvar child = new Child('anbang')\nParent.apply(child, [child.getName()])\nchild.saySomeThing();</code></pre>\n<h2 id=\"4-采用原型链的方式实现继承\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">4. 采用原型链的方式实现继承</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">实现原理:使子类原型对象指向父类的实例以实现继承,即重写类的原型,弊端是不能直接实现多继承</p>\n<pre class=\"language-javascript\"><code>function Parent () {\n  this.sayAge = function () {\n    console.log(this.age)\n  }\n}\nfunction Child (firstname) {\n  this.fname = firstname;\n  this.age = 30;\n  this.saySomeThing = function () {\n    console.log(this.fname)\n    this.sayAge();\n  }\n}\nChild.prototype = new Parent();\nvar child = new Child('anbang')\nchild.saySomeThing();</code></pre>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">5. 采用混合模式实现继承</h2>\n<pre class=\"language-javascript\"><code>function Parent () {\n  this.sayAge = function () {\n    console.log(this.age)\n  }\n}\nParent.prototype.sayParent = function () {\n  console.log(\"sayParent\")\n}\nfunction Child (firstname) {\n  Parent.call(this);\n  this.fname = firstname;\n  this.age = 30;\n  this.saySomeThing = function () {\n    console.log(this.fname)\n    this.sayAge();\n  }\n}\nChild.prototype = new Parent();\nvar child = new Child('anbang')\nchild.saySomeThing();\nchild.sayParent();</code></pre>\n<h2 id=\"5-采用混合模式实现继承\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":380,"createdAt":"2021-06-16T04:20:55.816Z","updatedAt":"2021-06-16T04:20:55.816Z","__v":0},{"_id":"60c97d6a7d119d797cb7b7d1","title":"JavaScript 模块的封装方法，比如怎样实现私有变量，不能直接赋值，只能通过共有方法访问。","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function MyObject () {\n  var privateVariable = 10;\n  function privateFunction () {\n    console.log(privateVariable);\n    return privateVariable;\n  }\n  //特权方法\n  this.publicMethod = function () {\n    privateVariable++;\n    return privateFunction();\n  }\n}\nvar obj = new MyObject();\nvar temp = obj.publicMethod();\nconsole.log(\"temp\", temp)</code></pre>","rank_id":381,"createdAt":"2021-06-16T04:26:18.227Z","updatedAt":"2021-06-16T04:26:18.227Z","__v":0},{"_id":"60c97d8e7d119d797cb7b7d2","title":"JavaScript 继承的6种方法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">1，原型链继承</li>\n<li style=\"padding: 0px; margin: 0px;\">2，借用构造函数继承</li>\n<li style=\"padding: 0px; margin: 0px;\">3，组合继承(原型+借用构造)</li>\n<li style=\"padding: 0px; margin: 0px;\">4，原型式继承</li>\n<li style=\"padding: 0px; margin: 0px;\">5，寄生式继承</li>\n<li style=\"padding: 0px; margin: 0px;\">6，寄生组合式继承</li>\n</ul>","rank_id":382,"createdAt":"2021-06-16T04:26:54.845Z","updatedAt":"2021-06-16T04:26:54.845Z","__v":0},{"_id":"60c97dc27d119d797cb7b7d3","title":"JavaScript 如何实现继承？如何避免原型链上面的对象共享？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"如何实现继承\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">如何实现继承</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">1、构造继承</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">2、原型继承</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">3、实例继承</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">4、拷贝继承</span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">原型<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">prototype</code>机制或<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">apply</code>和<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">call</code>方法去实现较简单，建议使用构造函数与原型混合方式。</span></p>\n<pre class=\"language-javascript\"><code>function Parent () {\n  this.name = 'anbang';\n}\nfunction Child () {\n  this.age = 30;\n}\nChild.prototype = new Parent();//继承了Parent，通过原型\nvar demo = new Child();\nconsole.log(demo.age);\nconsole.log(demo.name);//得到被继承的属性</code></pre>\n<h2 id=\"如何避免原型链上面的对象共享\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">如何避免原型链上面的对象共享</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">extend(</code>)函数，很多前端框架都有封装的，就是用一个空函数当做中间变量</span></p>","rank_id":383,"createdAt":"2021-06-16T04:27:46.975Z","updatedAt":"2021-06-16T04:27:46.975Z","__v":0},{"_id":"60c97e5a7d119d797cb7b7d4","title":"JavaScript JS 怎么实现一个class(类)","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在js中利用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">new</code>、<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">this</code>&nbsp;和&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">prototype</code>&nbsp;三个关键字可以实现完备的面向对象特征。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">而创建一个新的对象new关键字是不可缺少的。</p>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">只用new创建一个最简单的对象</h3>\n<pre class=\"language-javascript\"><code>var t = new Object();\nt.a = 'anbang';\nt.b = function () {\n  console.log(t.a);\n}\nt.b();</code></pre>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">再利用new和this关键字改进</h3>\n<pre class=\"language-javascript\"><code>var t = new Object();\nt.a = 'anbang';\nt.b = function () {\n  console.log(this.a);\n}\nt.b();</code></pre>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">再改进</h3>\n<pre class=\"language-javascript\"><code>function test () {\n  this.a = 'anbang';\n  this.b = function () {\n    alert(this.a);\n  }\n  return 1;\n}\nvar t = test();\nalert(a);\nb();\nalert(t);\nalert(t.a);\nt.b();</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">依次弹出</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">弹出<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">anbang</code>、</li>\n<li style=\"padding: 0px; margin: 0px;\">弹出<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">anbang</code>、</li>\n<li style=\"padding: 0px; margin: 0px;\">弹出<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">1</code>、</li>\n<li style=\"padding: 0px; margin: 0px;\">弹出<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">undefined</code>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">因为上的b不是方法。控制台还会输出\n<pre class=\"language-javascript\"><code>Uncaught TypeError: t.b is not a function</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可见，直接调用函数时，t只是函数的返回值，并不是需要的对象。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">由于test是由window对象调用的，this指代了window对象，把a和b赋给了window对象。</p>\n<h3 id=\"加上new\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">加上new</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">依次弹出，</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">弹出[object Object]</li>\n<li style=\"padding: 0px; margin: 0px;\">弹出test、</li>\n<li style=\"padding: 0px; margin: 0px;\">弹出test、</li>\n<li style=\"padding: 0px; margin: 0px;\">编译错误&rsquo;a&rsquo;未定义、停止执行。\n<pre class=\"language-javascript\"><code>Uncaught ReferenceError: a is not defined</code></pre>\n</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可见，用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">new</code>运算符时，调用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">test</code>函数的对象被赋给了<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">t</code>，this指代t对象，函数返回值被忽略。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">a</code>和<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">b()</code>在window上未定义。</p>\n<h3 id=\"再改进\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>\n<h3 id=\"再利用new和this关键字改进\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>\n<h3 id=\"只用new创建一个最简单的对象\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>","rank_id":384,"createdAt":"2021-06-16T04:30:18.904Z","updatedAt":"2021-06-16T04:30:18.904Z","__v":0},{"_id":"60c97e987d119d797cb7b7d5","title":"JavaScript 模块化开发怎么做？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">核心：立即执行函数,不暴露私有成员</span></p>\n<pre class=\"language-javascript\"><code>var module1 = (function () {\n  var _count = 0;\n  var m1 = function () {\n    //...\n  };\n  var m2 = function () {\n    //..\n  };\n  return {\n    m1: m1,\n    m2: m2\n  };\n})();</code></pre>","rank_id":385,"createdAt":"2021-06-16T04:31:20.593Z","updatedAt":"2021-06-16T04:31:20.593Z","__v":0},{"_id":"60c97f6b7d119d797cb7b7d6","title":"JavaScript 的原型，原型链都有什么特点？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"参考答案\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">参考答案</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">原型对象也是普通的对象，是对象一个自带隐式的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">__proto__</code>&nbsp;属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链</span></li>\n</ul>\n<h2 id=\"详细的总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">详细的总结</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">原型链一直是个很抽象的概念,看不到,摸不着.随着最近对JavaScript进一步的学习,我对原型链有了一点理解,下面讲出来.</span></p>\n<h3 id=\"基础知识\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">基础知识</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在JavaScript中,一共有两种类型的值,原始值和对象值.每个对象都有一个内部属性<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">prototype</code>,我们通常称之为原型.</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">原型的值可以是一个对象,也可以是null.如果它的值是一个对象,则这个对象也一定有自己的原型.这样就形成了一条线性的链,我们称之为原型链.</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">访问一个对象的原型可以使用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Object.getPrototypeOf</code>方法,或者<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">__proto__</code>属性.</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">原型链的作用是用来实现继承,比如我们新建一个数组,数组的方法就是从数组的原型上继承而来的.</span></p>\n<pre class=\"language-javascript\"><code>var arr = [];\narr.map === Array.prototype.map //arr.map是从arr.__proto__上继承下来的,arr.__proto__也就\n</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Array.prototype</code></span></p>\n<h2 id=\"图形化原型链\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">图形化原型链</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">虽然我们都说原型链,但实际上,在不考虑网页中frame的情况,js引擎在执行期间的某一时刻,所有存在的对象组成的是一棵原型树.</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">默认情况下,只有一棵树.根节点可以说是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Object.prototype</code>,也可以说是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">null</code>.</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">&nbsp;</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">但我们可以再建立一棵原型树,通过使用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Object.create</code>方法</p>\n<pre class=\"language-javascript\"><code>var foo = Object.create(null); //foo是一个对象,但它是游离的,不属于已有的那棵原型树\nvar bar = Object.create(foo); //bar的原型是foo\nvar baz = Object.create(foo); //baz的原型是foo </code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这样我们有了第二棵原型树</p>\n<h2 id=\"遍历原型链\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">遍历原型链</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我们没有办法遍历到所有以某个对象为原型的对象,但我们可以向上遍历,获取到一个对象所有的上层原型,这个原型链必定是线性的,尽头是null.</p>\n<pre class=\"language-javascript\"><code>function getPrototypeChain(object) {\n  var protoChain = [];\n  while (object = object.__proto__) {\n    protoChain.push(object);\n  }\n  protoChain.push(null);\n  return protoChain;\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">试验一下,不同的环境实现不同,显示形式也不同.下面是在chrome控制台中的显示.</span></p>\n<pre class=\"language-javascript\"><code>&gt;getPrototypeChain(new String(\"\"))\n[String, Object, null] //依次是String.prototype,Object.prototype,null\n&gt;getPrototypeChain(function(){})\n[function Empty() {}, Object, null] //依次是Function.prototype,Object.prototype,null</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这个就长多了.</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">超长原型链</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可以看出来,我们平时使用的对象并没有很长的原型链.但可以自己构造一个.</p>\n<pre class=\"language-javascript\"><code>function Foo() {}\nfor (var i = 0; i &lt; 100; i++) {\nFoo.prototype[\"foo\" + i] = i;\nFoo.prototype = new Foo;\n}\nconsole.dir(getPrototypeChain(new Foo));</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">最后的这个<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">new Foo</code>有多少个上层原型呢?</p>\n<h2 id=\"经典的总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">经典的总结</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">每个对象都会在其内部初始化一个属性，就是<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">prototype</code>(原型)，当我们访问一个对象的属性时，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果这个对象内部不存在这个属性，那么他就会去<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">prototype</code>里找这个属性，这个<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">prototype</code>又会有自己的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">prototype</code>，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">于是就这样一直找下去，也就是我们平时所说的原型链的概念。</p>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">关系</h3>\n<pre class=\"language-javascript\"><code>instance.constructor.prototype = instance.__proto__</code></pre>\n<h3 id=\"特点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">特点</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当我们修改原型时，与之相关的对象也会继承这一改变。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">就会查找他的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">prototyp</code>e对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。</p>\n<pre class=\"language-javascript\"><code>function Func () { }\nFunc.prototype.name = \"Sean\";\nFunc.prototype.getInfo = function () {\n  return this.name;\n}\nvar person = new Func();//现在可以参考var person = Object.create(oldObject);\nconsole.log(person.getInfo());//它拥有了Func的属性和方法\n//\"Sean\"\nconsole.log(Func.prototype);\n// Func { name=\"Sean\", getInfo=function()}</code></pre>\n<h3 id=\"关系\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>","rank_id":386,"createdAt":"2021-06-16T04:34:51.462Z","updatedAt":"2021-06-16T04:34:51.462Z","__v":0},{"_id":"60c9dc0f7d119d797cb7b7d7","title":"JavaScript DOM创建元素，添加元素，移动元素，复制节点，删除，替换元素，查找节点的方法？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">创建元素</span></h3>\n<pre class=\"language-javascript\"><code>document.createElement('tagName');</code></pre>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">添加元素</span></h3>\n<pre class=\"language-javascript\"><code>parent.appendChild(childNode);</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">注：父元素调用该方法</span></p>\n<h3 id=\"移动元素\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">移动元素</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">由于DOM对象属于引用类型，所以在操作appendChild和insertBefore方法时，</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">控制的节点如果是文档中存在的节点，那么将把这个节点移到目标处。</span></p>\n<h3 id=\"复制节点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">复制节点</span></h3>\n<pre class=\"language-javascript\"><code>oLi.cloneNode(true);</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 12pt; background-color: #ffffff;\">注：参数true表示深度克隆（深拷贝），false 表示浅度克隆（浅拷贝），深拷贝也就是复制节点及整个节点数；浅拷贝复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。因此，整个节点副本就成为一个&lsquo;孤儿&rsquo;：</span></p>\n<pre class=\"language-markup\"><code>&lt;ul id='oUl'&gt;\n  &lt;li&gt;item 1&lt;/li&gt;\n  &lt;li&gt;item 2&lt;/li&gt;\n  &lt;li&gt;item 3&lt;/li&gt;\n&lt;ul&gt;\n&lt;script&gt;\nvar myList = document.getElementById(\"oUl\");\nvar deepList = myList.cloneNode(true);\nconsole.log(deepList.childNodes.length);//3  (IE&lt;9) 或7 （其它浏览器）\nvar shallowList = myList.cloneNode(false);\nconsole.log(shallowList.childNodes.length);//0\n&lt;/script&gt;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">以上代码注意childNode包含文本节点。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">cloneNode()</code>方法不会复制添加DOM节点的JS属性，例如事件处理程序等。这个方法只复制特性，其他一切都不会复制。</span></p>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">删除节点</span></h3>\n<pre class=\"language-javascript\"><code>parentNode.removeChild(childNode);</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">注：父元素调用该方法，返回值为被删除的节点</span></p>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">替换元素</span></h3>\n<pre class=\"language-javascript\"><code>parentNode.replaceChild(newNode,oldNode);</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">注：oldNode节点必须是parentNode的子节点。</span></p>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">插入元素</span></h3>\n<pre class=\"language-javascript\"><code>parentNode.insertBefore(newEle, oldNode);</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">注：父元素调用该方法</span></p>\n<h2 id=\"查找节点的总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">查找节点的总结</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">childNodes&mdash;返回节点到子节点的节点列表</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">firstChild&mdash;返回节点的首个子节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">lastChild&mdash;返回节点的最后一个子节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">nextSibling&mdash;返回节点之后紧跟的同级节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">nodeName&mdash;返回节点的名字，根据其类型;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">nodeType&mdash;返回节点的类型;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">nodeValue&mdash;设置或返回节点的值，根据其类型;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">ownerDocument&mdash;返回节点的根元素（document对象）;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">parentNode&mdash;返回节点的父节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">previousSibling&mdash;返回节点之前紧跟的同级节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">text&mdash;返回节点及其后代的文本（IE独有）;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">xml&mdash;返回节点及其后代的XML（IE独有）;</span></li>\n</ul>\n<h2 id=\"节点对象的方法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">节点对象的方法</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">appendChild()&mdash;向节点的子节点列表的结尾添加新的子节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">cloneNode()&mdash;复制节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">hasChildNodes()&mdash;判断当前节点是否拥有子节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">insertBefore()&mdash;在指定的子节点前插入新的子节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">normalize()&mdash;合并相邻的Text节点并删除空的Text节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">removeChild()&mdash;删除（并返回）当前节点的指定子节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">replaceChild()&mdash;用新节点替换一个子节点;</span></li>\n</ul>\n<h2 id=\"ie6独有方法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">IE6独有方法</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">selectNodes()&mdash;用一个XPath表达式查询选择节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">selectSingleNode()&mdash;查找和XPath查询匹配的一个节点;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">transformNode()&mdash;使用XSLT把一个节点转换为一个字符串。transformNodeToObject()&mdash;使用XSLT把一个节点转换成为一个文档。</span></li>\n</ul>\n<h2 id=\"经典的问题解析\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">经典的问题解析</span></h2>\n<h3 id=\"创建新节点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">创建新节点</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">createDocumentFragment() //创建一个DOM片段</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">createElement() //创建一个具体的元素</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">createTextNode() //创建一个文本节点</span></li>\n</ul>\n<h3 id=\"添加移除替换插入\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">添加、移除、替换、插入</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">appendChild()</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">removeChild()</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">replaceChild()</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">insertBefore() //在已有的子节点前插入一个新的子节点</span></li>\n</ul>\n<h3 id=\"查找\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">查找</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">getElementsByTagName() //通过标签名称</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">getElementById() //通过元素Id，唯一性</span></li>\n</ul>\n<h3 id=\"插入元素\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>\n<h3 id=\"替换元素\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>\n<h3 id=\"删除节点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>\n<h3 id=\"添加元素\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>\n<h3 id=\"创建元素\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>","rank_id":387,"createdAt":"2021-06-16T11:10:07.529Z","updatedAt":"2021-06-16T11:10:07.529Z","__v":0},{"_id":"60c9dc9c7d119d797cb7b7d8","title":"JavaScript innerHTML，innerText，textContent，value、nodeValue属性的区别是什么？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">innerHTML是标签内的文本，解析html代码。</li>\n<li style=\"padding: 0px; margin: 0px;\">innerText标签内的文本，不解析html代码。</li>\n<li style=\"padding: 0px; margin: 0px;\">textContent火狐不支持innerText属性，用它替代。</li>\n<li style=\"padding: 0px; margin: 0px;\">value表单元素的属性。</li>\n<li style=\"padding: 0px; margin: 0px;\">nodeValue是文本节点textNode的属性（DOM）。</li>\n</ul>","rank_id":388,"createdAt":"2021-06-16T11:12:28.720Z","updatedAt":"2021-06-16T11:12:28.720Z","__v":0},{"_id":"60c9dce07d119d797cb7b7d9","title":"JavaScript 写一个insertBefore和insertAfter方法，并且写出完整测试用例","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function innerAfter (oldEle, newEle) {\n  if (oldEle &amp;&amp; oldEle.nodeType === 1 &amp;&amp; newEle &amp;&amp; newEle.nodeType === 1) {\n    oldEle.nextSibling ? oldEle.parentNode.innertBefore(newEle, oldEle.nextSibling) \n                                   : oldEle.parentNode.appendChild(newEle);\n  } else {\n    throw new Error(\"参数错误\")\n  }\n}\nvar oDiv2 = document.getElementById(\"div2\");\nvar oDiv1 = document.getElementById(\"div1\").cloneNode(true);\ninnerAfter(oDiv2, oDiv1);</code></pre>","rank_id":389,"createdAt":"2021-06-16T11:13:36.012Z","updatedAt":"2021-06-16T11:13:36.012Z","__v":0},{"_id":"60c9dd547d119d797cb7b7da","title":"JavaScript 写出和appendChild向对象的prependChild方法并且写出完整的测试用例","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function prependChild (newNode, parentEle) {\n  var child = parentEle.firstChild;\n  child ? parentEle.insertBefore(newNode, child) : parentEle.appendChild(newNode);\n}\nvar oDiv1 = document.getElementById(\"div1\");\nvar oDiv4 = document.getElementById(\"div4\");\nprependChild(oDiv4, oDiv1);</code></pre>","rank_id":390,"createdAt":"2021-06-16T11:15:32.806Z","updatedAt":"2021-06-16T11:15:32.806Z","__v":0},{"_id":"60c9dd887d119d797cb7b7db","title":"JavaScript 写一个方法，能够实现：获得某元素节点指定标签名的子元素节点，并且写出测试用例","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var oDiv1 = document.getElementById(\"div1\");\nconsole.log(getChildren(oDiv1, 'div'));\nfunction getChildren (ele, tag) {\n  var children = ele.childNodes;\n  if (typeof tag === 'string') {\n    tag = tag.toUpperCase();\n    var a = [];\n    for (let i = 0; i &lt; children.length; i++) {\n      const node = children[i];\n      if (node.nodeType === 1 &amp;&amp; node.nodeName === tag) {\n        a.push(node);\n      }\n    }\n    return a;\n  } else if (typeof tag === 'undefined') {\n    var a = [];\n    for (let j = 0; j &lt; children.length; j++) {\n      const nodej = children[i];\n      if (nodej.nodeType === 1) {\n        a.push(nodej);\n      }\n    }\n    return a;\n  } else {\n    throw new Error(\"Tag参数类型错误!\")\n  }\n}</code></pre>","rank_id":391,"createdAt":"2021-06-16T11:16:24.251Z","updatedAt":"2021-06-16T11:16:24.251Z","__v":0},{"_id":"60c9de4c7d119d797cb7b7dc","title":"JavaScript setInterval和setTimeout的区别，他们的返回值是什么类型的？表示什么含意呢？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>window.setInterval(fn,1000);//每隔1000ms执行一次fn方法,不会停止。\nwindow.setTimeout(fn,1000);//1000ms后只运行一次fn方法，虽然只运行一次，可以递归调用自身模拟setInterval方法。</code></pre>\n<p>例如：</p>\n<pre class=\"language-javascript\"><code>window.setTimeout(fn, 1000 * 1)\nfunction fn () {\n  console.log(Date.now());\n  fn();\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">这2个方法的返回值都是number类型，是该定时器的队列号。</span></p>","rank_id":392,"createdAt":"2021-06-16T11:19:40.133Z","updatedAt":"2021-06-16T11:19:40.133Z","__v":0},{"_id":"60c9e0417d119d797cb7b7dd","title":"JavaScript DOM中节点有多少类型？元素节点和文本节点的区别？他们有浏览器兼容性问题吗？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">共有13种类型，常见的类型如下</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">element的节点类型是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">1</code></li>\n<li style=\"padding: 0px; margin: 0px;\">textNode节点类型是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">3</code></li>\n<li style=\"padding: 0px; margin: 0px;\">comment节点类型是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">8</code></li>\n<li style=\"padding: 0px; margin: 0px;\">document节点类型是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">9</code></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">元素节点就是html标签，文本节点是逻辑上的节点，只有元素节点才能添加文本节点，文本节点不能有子元素。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">主要是IE8中把回车、换行当做文本节点</p>","rank_id":393,"createdAt":"2021-06-16T11:28:01.849Z","updatedAt":"2021-06-16T11:28:01.849Z","__v":0},{"_id":"60c9e0667d119d797cb7b7de","title":"JavaScript childNodes和children的区别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">childNodes在标准浏览器中获取所有类型的子节点，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">children在标准浏览器中获取的是元素节点，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">但是在IE6、7、8中childNodes和children能够获取到元素节点和注释节点。</p>","rank_id":394,"createdAt":"2021-06-16T11:28:38.131Z","updatedAt":"2021-06-16T11:28:38.131Z","__v":0},{"_id":"60c9e1707d119d797cb7b7df","title":"JavaScript 中的document.documentElement和document.body的区别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">document.body</code>&nbsp;是DOM对象里的body子节点，即&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;body&gt;</code>&nbsp;标签</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">document.documentElement</code>&nbsp;是整个节点树的根节点root，即&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;html&gt;</code>&nbsp;标签</li>\n</ul>","rank_id":395,"createdAt":"2021-06-16T11:33:04.224Z","updatedAt":"2021-06-16T11:33:04.224Z","__v":0},{"_id":"60c9e1c87d119d797cb7b7e0","title":"JavaScript documentFragment是什么？它有什么用途，它对浏览器的性能有什么影响","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">是文档碎片，为了节约使用DOM，每次JavaScript对DOM的操作都会改变页面的变现，并重新刷新整个页面，从而消耗了大量的时间。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可以创建一个文档碎片，把所有的新节点附加其上，然后把文档碎片的内容一次性添加到document中，在处理大数量时此方法很高效，代码如下：</p>\n<pre class=\"language-javascript\"><code>var oFrag = document.createDocumentFragment();\nfor (let index = 0; index &lt; 100; index++) {\n  var op = document.createElement('p');\n  var oText = document.createTextNode('我是文本');\n  op.appendChild(oText);\n  oFrag.appendChild(op);\n}\ndocument.body.appendChild(oFrag);</code></pre>","rank_id":396,"createdAt":"2021-06-16T11:34:32.627Z","updatedAt":"2021-06-16T11:34:32.627Z","__v":0},{"_id":"60c9e1ef7d119d797cb7b7e1","title":"JavaScript 说出常用的数字方法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.abs(-55);</code>//绝对值，返回结果为55</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.ceil(2.1);</code>//向上取整 3</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.round(2.3)</code>//四舍五入结果为2\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.round(2.6)</code>//四舍五入结果为3</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.floor(2.9);</code>// 向下取整 2\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.floor(-2.9);</code>// 向下取整 -3</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.random();</code>//随机数，是个0~1之间的数，取1-100之间的随机正数： n=Math.random()*100;//n&gt;0 n&lt;100</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.max(x,y,z);</code>//获取最大值，可以有n个参数 不一定是2个</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.min(x,y,z,w);</code>//获取最小值</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">还有一些不是那么常用的</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.sqrt(3);</code>//开平方 1.732&hellip;&hellip;..</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.pow(2,2);</code>//2的2次方 为4</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.sin(number);</code></li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Math.cos(number);</code></li>\n</ul>","rank_id":397,"createdAt":"2021-06-16T11:35:11.968Z","updatedAt":"2021-06-16T11:35:11.968Z","__v":0},{"_id":"60c9e2967d119d797cb7b7e2","title":"JavaScript 编写一个；取得指定范围的随机数的方法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function randomInt (m, n) {\n  return Math.floor(Math.random() * (n - m + 1) + m);\n}\nconsole.log(randomInt(1, 30))</code></pre>","rank_id":398,"createdAt":"2021-06-16T11:37:58.370Z","updatedAt":"2021-06-16T11:37:58.370Z","__v":0},{"_id":"60c9e3c27d119d797cb7b7e3","title":"JavaScript 常用的时间方法有哪些？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var time = new Date();//可有参数也可以无,时间戳（无参数表示代码运行的时间点）\nvar y = time.getFullYear();//年\nvar m = time.getMonth() + 1;//月,表示 从0开始，一月是0、二月是1\nvar day = time.getDate();//日\nvar week = time.getDay();//星期 ，从0开始， 0是周日\nvar h = time.getHours();\nvar minu = time.getMinutes();\nvar s = time.getSeconds();//秒\nvar ms = time.getMilliseconds();//毫秒</code></pre>","rank_id":399,"createdAt":"2021-06-16T11:42:58.560Z","updatedAt":"2021-06-16T11:42:58.560Z","__v":0},{"_id":"60c9e3e77d119d797cb7b7e4","title":"JavaScript 时间类型创建实例时带参数的方式有几种?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var d1 = new Date();\nvar d2 = new Date('2022-08-08 12:12:12');\nvar d3 = new Date('2022, 8, 8 4:4:4');</code></pre>","rank_id":400,"createdAt":"2021-06-16T11:43:35.023Z","updatedAt":"2021-06-16T11:43:35.023Z","__v":0},{"_id":"60c9e41c7d119d797cb7b7e5","title":"JavaScript 说一说Date类中的getTime方法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">getTime()</code>&nbsp;方法可返回当下（或某一时间点）距 1970 年 1 月 1 日之间的毫秒数。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这个问题一般会引申到倒计时，双十一抢购，距离某个时间点还有多少时间的问题；</p>","rank_id":401,"createdAt":"2021-06-16T11:44:28.425Z","updatedAt":"2021-06-16T11:44:28.425Z","__v":0},{"_id":"60c9e43a7d119d797cb7b7e6","title":"JavaScript this关键字的表达什么意思?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">谁调用指向谁，如果函数没有执行，则this未知</span></p>","rank_id":402,"createdAt":"2021-06-16T11:44:58.296Z","updatedAt":"2021-06-16T11:44:58.296Z","__v":0},{"_id":"60c9e48b7d119d797cb7b7e7","title":"JavaScript innerText这个属性firefox浏览是不支持的，firefox用什么属性替代innerText这个属性，请写一个没有浏览器兼容性的获取元素文本的方法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">textContent</span></p>\n<pre class=\"language-javascript\"><code>var oDiv = document.getElementById('div');\nif (typeof oDiv.innerText === 'undefined') {\n  oDiv.textContent = '火狐';\n  console.log(oDiv.textContent);\n} else {\n  oDiv.innerText = '非火狐';\n  console.log(oDiv.innerText);\n}</code></pre>","rank_id":403,"createdAt":"2021-06-16T11:46:19.945Z","updatedAt":"2021-06-16T11:46:19.945Z","__v":0},{"_id":"60c9e4a97d119d797cb7b7e8","title":"JavaScript 如何获取网页元素的CSS样式值","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>if(window.getComputedStyle){\n  return window.getComputedStyle(ele,null);//标准浏览器\n}else{\n  ele.currentStyle;//currentStyle是IE的属性\n}</code></pre>","rank_id":404,"createdAt":"2021-06-16T11:46:49.010Z","updatedAt":"2021-06-16T11:46:49.010Z","__v":0},{"_id":"60c9e5477d119d797cb7b7e9","title":"JavaScript 点击下面的li，会弹出什么结果?","code":"<pre class=\"language-markup\"><code>  &lt;ul&gt;\n    &lt;li&gt;1111&lt;/li&gt;\n    &lt;li&gt;2222&lt;/li&gt;\n    &lt;li&gt;3333&lt;/li&gt;\n    &lt;li&gt;4444&lt;/li&gt;\n  &lt;/ul&gt;\n  &lt;script&gt;\n    var aLi = document.getElementsByTagName('li');\n    console.log(\"aLi\", aLi)\n    for (let index = 0; index &lt; aLi.length; index++) {\n      aLi[index].onclick = function () {\n        console.log(index);\n      }\n    }\n  &lt;/script&gt;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">闭包的选项卡的那个，都输出最后一个数，可以用闭包来解决，也可以用自定义属性，自定义属性的性能会更好；）</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">都会弹出3，因为for中的i不是局部变量，是全局变量，window的属性，是累加的结果。</p>","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-markup\"><code>&lt;ul&gt;\n  &lt;li&gt;1111&lt;/li&gt;\n  &lt;li&gt;2222&lt;/li&gt;\n  &lt;li&gt;3333&lt;/li&gt;\n  &lt;li&gt;4444&lt;/li&gt;\n&lt;/ul&gt;\n&lt;script&gt;\n  var aLi = document.getElementsByTagName('li');\n  console.log(\"aLi\", aLi)\n  for (let index = 0; index &lt; aLi.length; index++) {\n    (function (i) {\n      aLi[i].onclick = function () {\n        console.log(i);\n      }\n    })(index)\n  }\n&lt;/script&gt;</code></pre>","rank_id":405,"createdAt":"2021-06-16T11:49:27.321Z","updatedAt":"2021-06-16T11:49:27.321Z","__v":0},{"_id":"60c9e56f7d119d797cb7b7ea","title":"JavaScript 怎么得到浏览器滚动条的位置?","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function scollPostion () {\n  var t, l, w, h;\n  if (document.documentElement &amp;&amp; document.documentElement.scrollTop) {\n    t = document.documentElement.scrollTop;\n    l = document.documentElement.scrollLeft;\n    w = document.documentElement.scrollWidth;\n    h = document.documentElement.scrollHeight;\n  } else if (document.body) {\n    t = document.body.scrollTop;\n    l = document.body.scrollLeft;\n    w = document.body.scrollWidth;\n    h = document.body.scrollHeight;\n  }\n  return {\n    top: t,\n    left: l,\n    width: w,\n    height: h\n  }\n}</code></pre>","rank_id":406,"createdAt":"2021-06-16T11:50:07.638Z","updatedAt":"2021-06-16T11:50:07.638Z","__v":0},{"_id":"60c9e58e7d119d797cb7b7eb","title":"JavaScript 怎么得到浏览器的高和宽度","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function getBrowser () {\n  var w = document.documentElement.clientWidth || document.body.clientWidth;\n  var h = document.documentElement.clientHeight || document.body.clientHeight;\n  return {\n    width: w,\n    height: h\n  }\n}</code></pre>","rank_id":407,"createdAt":"2021-06-16T11:50:38.218Z","updatedAt":"2021-06-16T11:50:38.218Z","__v":0},{"_id":"60c9e5a47d119d797cb7b7ec","title":"JavaScript clientHeight和offsetHeight有什么区别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">clientHeight</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">不包括boder的宽度&nbsp;</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">offsetHeight</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">包含。</span></p>","rank_id":408,"createdAt":"2021-06-16T11:51:00.086Z","updatedAt":"2021-06-16T11:51:00.086Z","__v":0},{"_id":"60c9e5c17d119d797cb7b7ed","title":"JavaScript offsetLeft的值和由定位产生的Left属性的值之间，有什么异同","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">如果父div的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">position</code>&nbsp;定义为&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">relative</code>&nbsp;,子div的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">position</code>&nbsp;定义为&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">absolute</code>&nbsp;，那么子div的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">style.left</code>&nbsp;的值是相对于父div的值，这同 offsetLeft 是相同的，区别在于:\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">style.left</code>&nbsp;返回的是字符串类型， offsetLeft 返回的是数值类型</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">style.left</code>&nbsp;是读写的， offsetLeft 是只读的，所以要改变div的位置，只能修改&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">style.left</code>&nbsp;。</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">style.left</code>&nbsp;的值需要事先定义，否则取到的值为空。必须是行内样式否则取不到&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">style.left</code>&nbsp;的值。offsetLeft则仍然能够取到。</li>\n</ul>\n</li>\n</ul>","rank_id":409,"createdAt":"2021-06-16T11:51:29.650Z","updatedAt":"2021-06-16T11:51:29.650Z","__v":0},{"_id":"60c9e61e7d119d797cb7b7ee","title":"JavaScript 请写一个获取元素相对于屏幕距离的方法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">实现一个<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">getPos();</code>方法，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">用法:</p>\n<pre class=\"language-javascript\"><code>var L=getPos(obj).x;\nvar R=getPos(obj).y;</code></pre>\n<p><span style=\"font-size: 12pt;\">具体的代码：</span></p>\n<pre class=\"language-javascript\"><code>function getPos (ele) {\n  var top = ele.offsetTop;\n  var left = ele.offsetLeft;\n  while (ele.offsetParent) {\n    ele = ele.offsetParent;\n    if (window.navigator.userAgent.indexOf('MSIE 8') &gt; -1) {\n      top += ele.offsetTop;\n      left += ele.offsetLeft;\n    } else {\n      top += ele.offsetTop + clientTop;\n      left += ele.offsetLeft + clientLeft;\n    }\n  }\n  return {\n    x: left,\n    y: top\n  }\n}</code></pre>","rank_id":410,"createdAt":"2021-06-16T11:53:02.630Z","updatedAt":"2021-06-16T11:53:02.630Z","__v":0},{"_id":"60c9e6cc7d119d797cb7b7ef","title":"JavaScript DOM加载过程是怎么样的","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">解析HTML结构。</li>\n<li style=\"padding: 0px; margin: 0px;\">加载外部脚本和样式表文件。</li>\n<li style=\"padding: 0px; margin: 0px;\">解析并执行脚本代码。</li>\n<li style=\"padding: 0px; margin: 0px;\">构造HTML DOM模型。</li>\n<li style=\"padding: 0px; margin: 0px;\">加载图片等外部文件。</li>\n<li style=\"padding: 0px; margin: 0px;\">页面加载完毕。</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">基于这个顺序，我们会发现如果在DOM完全加载之前使用DOM可能会发生错误（这个可能是很多初学者曾遇到的问题），而如果用onload加载函数又必须等待图片、视频等元素的加载，造成无法运行JavaScript。</p>","rank_id":411,"createdAt":"2021-06-16T11:55:56.828Z","updatedAt":"2021-06-16T11:55:56.828Z","__v":0},{"_id":"60c9e6f47d119d797cb7b7f0","title":"JavaScript DOM加载后，运行代码的问题","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">window.onload</code>&nbsp;必须等到页面内包括图片的所有元素加载完毕后才能执行。</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$(document).ready()</code>&nbsp;是DOM结构绘制完毕后就执行，不必等到加载完毕。</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">window.onload</code>&nbsp;不能同时编写多个，如果有多个&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">window.onload</code>&nbsp;方法，只会执行一个</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$(document).ready()</code>&nbsp;可以同时编写多个，并且都可以得到执行；</li>\n<li style=\"padding: 0px; margin: 0px;\">Jquery的这个<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">ready</code>的实现原理是\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">在jquery脚本加载的时候,会设置一个isReady的标记,监听&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">DOMContentLoaded</code>&nbsp;事件(这个不是什么浏览器都有的,不同浏览器,jquery运作方式不一样).</li>\n<li style=\"padding: 0px; margin: 0px;\">当然遇到调用ready函数的时候,如果isReady未被设置,那就是说页面未加载完,就会把要执行的函数用一个数组缓存起来,当页面加载完后,再把缓存的函数一一执行.</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">此外,它目前已在HTML5中被标准化,下面的代码显示了&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">DOMContentLoaded</code>&nbsp;是如何在document对象中被触发的;\n<pre class=\"language-javascript\"><code>document.addeventListener('DOMContentLoaded',function(){...},false);</code></pre>\n</li>\n</ul>","rank_id":412,"createdAt":"2021-06-16T11:56:36.472Z","updatedAt":"2021-06-16T11:56:36.472Z","__v":0},{"_id":"60c9e7107d119d797cb7b7f1","title":"JavaScript DOM结构,两个节点之间可能存在哪些关系以及如何在节点之间任意移动","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">document.documentElement 返回文档的根节点<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;html&gt;</code></li>\n<li style=\"padding: 0px; margin: 0px;\">document.body&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;body&gt;</code></li>\n<li style=\"padding: 0px; margin: 0px;\">document.activeElement 返回当前文档中被击活的标签节点(ie)</li>\n<li style=\"padding: 0px; margin: 0px;\">event.fromElement 返回鼠标移出的源节点(ie)</li>\n<li style=\"padding: 0px; margin: 0px;\">event.toElement 返回鼠标移入的源节点(ie)</li>\n<li style=\"padding: 0px; margin: 0px;\">event.srcElement 返回激活事件的源节点(ie)</li>\n<li style=\"padding: 0px; margin: 0px;\">event.target 返回激活事件的源节点(firefox)</li>\n<li style=\"padding: 0px; margin: 0px;\">当前对象为node</li>\n<li style=\"padding: 0px; margin: 0px;\">返回父节点：node.parentNode, node.parendElement,</li>\n<li style=\"padding: 0px; margin: 0px;\">返回所有子节点：node.childNodes（包含文本节点及标签节点）,node.children</li>\n<li style=\"padding: 0px; margin: 0px;\">返回第一个子节点：node.firstChild</li>\n<li style=\"padding: 0px; margin: 0px;\">返回最后一个子节点： node.lastChild</li>\n<li style=\"padding: 0px; margin: 0px;\">返回同属上一个子节点：node.nextSibling</li>\n<li style=\"padding: 0px; margin: 0px;\">返回同属下一个子节点：node.previousSibling</li>\n<li style=\"padding: 0px; margin: 0px;\">parentNode和parentElement功能一样，childNodes和children功能一样。但是parentNode和childNodes是符合W3C标准的，可以说比较通用。而另外两个只是IE支持，不是标准，Firefox就不支持 ,所以大家只要记得有parentElement和children就行了</li>\n</ul>","rank_id":413,"createdAt":"2021-06-16T11:57:04.592Z","updatedAt":"2021-06-16T11:57:04.592Z","__v":0},{"_id":"60c9e7477d119d797cb7b7f2","title":"JavaScript 请写一个 getParents 方法让它可以获取某一个 DOM 元素的所有父亲节点","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function getParents(ele) {\n    var matched = []\n    // 防止获取 document\n    while ( (ele = ele.parentNode) &amp;&amp; ele.nodeType !== 9) {\n        matched.push(ele)\n    }\n    return matched\n}</code></pre>","rank_id":414,"createdAt":"2021-06-16T11:57:59.669Z","updatedAt":"2021-06-16T11:57:59.669Z","__v":0},{"_id":"60c9e7b57d119d797cb7b7f3","title":"jQuery 对象是数组吗？jquery 是用什么方法来保存查找的 DOM 对象的？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"jquery-对象是数组吗\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jQuery 对象是数组吗？</span></h2>\n<blockquote style=\"padding: 0px 0px 8px; margin: 10px 0px; color: #828201; border-width: 1px 1px 1px 5px; border-style: solid; border-color: #e2e2e2 #e2e2e2 #e2e2e2 #fff000; border-image: initial; background-color: #ffffc0; overflow: hidden; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">不是数组，是类数组。</span></p>\n</blockquote>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jQuery 对象是一个伪数组，以键值対的方式保存了一个 DOM 元素列表</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jQuery 虽然不是数组，但是却有模拟数组的方法和属性，可以以类似数组的方法访问其 DOM 元素</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$.size()</code>：DOM 元素数量</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$.length</code>：DOM 元素属性</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$.get(0)</code>：首个 DOM 元素</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$[0]</code>：首个 DOM 元素</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$.index()</code>：DOM 元素在父级节点中的位置</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$.index($)</code>：DOM 元素在 jQuery 伪数组中的位置</span>\n<pre class=\"language-markup\"><code>&lt;script type=\"text/javascript\" src=\"jquery-3.4.0.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\"&gt;\n\t$(() =&gt; {\n\t\tlet a = $('#btn1').index();\n\t\tlet b = $('button').index($('#btn1'));\n\t\talert(a); //返回元素在父级节点中的位置，1\n\t\talert(b); //返回元素在jQuery伪数组中的位置，0\n\t});\n&lt;/script&gt;\n&lt;body&gt;\n\t用户名&lt;input type=\"text\" id=\"username\"/&gt;\n\t&lt;button id=\"btn1\"&gt;原生DOM&lt;/button&gt;\n\t&lt;button id=\"btn2\"&gt; jQuery&lt;/button&gt;\n&lt;/body&gt;</code></pre>\n</li>\n</ul>\n<h2 id=\"jquery-是用什么方法来保存查找的-dom-对象的\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jquery 是用什么方法来保存查找的 DOM 对象的？</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">用&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$()</code>&nbsp;把 DOM 对象包装起来，就可以获得一个 jQuery 对象了；</span></p>\n<h2 id=\"在-dom-元素中存取数据\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在 DOM 元素中存取数据</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在 DOM 元素中存数据，可以使用 DOM 元素的属性（内置的）和特性（自定义的）。但直接这样做，可能会导致内存泄漏等安全问题。下面将介绍 一种 由 jQuery 提供的更安全的在 DOM 元素存取数据的方法。</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">获取数据的值：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">data( [name] )</code></span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">设置数据的值：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">data(name, value)</code>&nbsp;&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">data(object)</code>&nbsp;&mdash;- 批量传入，传对象即可。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">返回该 DOM 所有的 data：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">data()</code></span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">删除数据：removeData([name])</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">判断是否有数据：jQuery.hasData(element)</span></li>\n</ul>","rank_id":415,"createdAt":"2021-06-16T11:59:49.182Z","updatedAt":"2021-06-16T11:59:49.183Z","__v":0},{"_id":"60c9e7eb7d119d797cb7b7f4","title":"jQuery 选择器中 :has（selector）和 is(selector) 有什么区别？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">has(selector) 保留包含特定后代的元素，去掉那些不含有指定后代的元素。</li>\n</ol>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\" start=\"2\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">is(selector) 根据选择器、DOM 元素或 jQuery 对象来检测匹配元素集合，如果其中至少有一个元素符合这个给定的表达式就返回 true。</li>\n</ol>\n</li>\n</ul>","rank_id":416,"createdAt":"2021-06-16T12:00:43.480Z","updatedAt":"2021-06-16T12:00:43.480Z","__v":0},{"_id":"60c9e8837d119d797cb7b7f5","title":"jquery first-child 和 first 有什么区别？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"first-只匹配一个元素\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">:first 只匹配一个元素</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">只会选择第一个 li（john）</p>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">HTML 代码：</h3>\n<pre class=\"language-markup\"><code>&lt;ul&gt;\n    &lt;li&gt;john&lt;/li&gt;\n    &lt;li&gt;Karl&lt;/li&gt;\n    &lt;li&gt;Brandon&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ul&gt;\n    &lt;li&gt;Glen&lt;/li&gt;\n    &lt;li&gt;Tane&lt;/li&gt;\n    &lt;li&gt;Ralph&lt;/li&gt;\n&lt;/ul&gt;</code></pre>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">jQuery 代码</h3>\n<pre class=\"language-javascript\"><code>$(\"ul li:first\")</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">结果：</span></p>\n<pre class=\"language-javascript\"><code>[ &lt;li&gt;John&lt;/li&gt; ]</code></pre>\n<h2 id=\"first-child\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">:first-child</code></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在每个 ul 中查找第一个 li</p>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">HTML 代码：</h3>\n<pre class=\"language-markup\"><code>&lt;ul&gt;\n    &lt;li&gt;john&lt;/li&gt;\n    &lt;li&gt;Karl&lt;/li&gt;\n    &lt;li&gt;Brandon&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ul&gt;\n    &lt;li&gt;Glen&lt;/li&gt;\n    &lt;li&gt;Tane&lt;/li&gt;\n    &lt;li&gt;Ralph&lt;/li&gt;\n&lt;/ul&gt;</code></pre>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">jQuery 代码：</h3>\n<pre class=\"language-javascript\"><code>$(\"ul li:first-child\")</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">结果：</span></p>\n<pre class=\"language-markup\"><code>[ &lt;li&gt;John&lt;/li&gt;, &lt;li&gt;Glen&lt;/li&gt; ]</code></pre>\n<h3 id=\"jquery-代码-1\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>\n<h3 id=\"html-代码-1\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>\n<h3 id=\"jquery-代码\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>\n<h3 id=\"html-代码\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>","rank_id":417,"createdAt":"2021-06-16T12:03:15.332Z","updatedAt":"2021-06-16T12:03:15.332Z","__v":0},{"_id":"60c9e8b37d119d797cb7b7f6","title":"简述在 jQuery 中，innerWidth(),outerWidth(),outerWidth(true) 和 width 区别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"innerwidth\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">innerWidth</span></h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">innerWidth()：获取第一个匹配元素内部区域宽度（包括补白、不包括边框）。</span></li>\n</ol>\n<h2 id=\"outerwidth\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">outerWidth()</span></h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"2\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">outerWidth(): 获取第一个匹配元素外部宽度（默认包括补白和边框）。</span></li>\n</ol>\n<h2 id=\"outerwidthtrue\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">outerWidth(true)</span></h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"3\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">outerWidth(true): 设置为 true 时，计算边距在内。默认是 false。</span></li>\n</ol>\n<h2 id=\"width\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">width</span></h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"4\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">width: 定义元素内容区的宽度。</span></li>\n</ol>","rank_id":418,"createdAt":"2021-06-16T12:04:03.872Z","updatedAt":"2021-06-16T12:04:03.872Z","__v":0},{"_id":"60c9e8cd7d119d797cb7b7f7","title":"简述在 jQuery 中，scroll 和 scrollTop 这两个方法的区别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">在每一个匹配元素的 scroll 事件中绑定一个处理函数。</li>\n</ol>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px;\" start=\"2\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">获取匹配元素相对滚动条顶部的偏移。</li>\n</ol>\n</li>\n</ul>","rank_id":419,"createdAt":"2021-06-16T12:04:29.599Z","updatedAt":"2021-06-16T12:04:29.599Z","__v":0},{"_id":"60c9e9317d119d797cb7b7f8","title":"选择器中不能加逗号，filter 过滤器方法可以解决这一个问题；","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"选择器中不能加逗号filter-过滤器方法可以解决这一个问题\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">选择器中不能加逗号，filter 过滤器方法可以解决这一个问题；</h2>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">HTML 代码：</h2>\n<pre class=\"language-markup\"><code>&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;Hello Again&lt;/p&gt;&lt;p class=\"selected\"&gt;And Again&lt;/p&gt;</code></pre>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">jQuery 代码：</h2>\n<pre class=\"language-javascript\"><code>$(\"p\").filter(\".selected, :first\")</code></pre>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">结果：</h2>\n<pre class=\"language-markup\"><code> [ &lt;p&gt;Hello&lt;/p&gt;, &lt;p class=\"selected\"&gt;And Again&lt;/p&gt; ]</code></pre>\n<h2 id=\"结果\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>\n<h2 id=\"jquery-代码\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>\n<h2 id=\"html-代码\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":420,"createdAt":"2021-06-16T12:06:09.533Z","updatedAt":"2021-06-16T12:06:09.533Z","__v":0},{"_id":"60c9e9567d119d797cb7b7f9","title":"只能通过选择器获得每个 UL 下索引号大于 2 的 li，怎么取","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>$('ul').find('li:gt(2)').css('background','green')</code></pre>","rank_id":421,"createdAt":"2021-06-16T12:06:46.976Z","updatedAt":"2021-06-16T12:06:46.976Z","__v":0},{"_id":"60c9e98d7d119d797cb7b7fa","title":"($(\"li:first-child,li:last-child,li:contains(4)\").css(\"background\",green)); 是什么意思 ？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">获取每个 ul 下第一个、最后一个和文本字符串包含 4 的元素，并将他们的背景设置为绿色</span></p>","rank_id":422,"createdAt":"2021-06-16T12:07:41.742Z","updatedAt":"2021-06-16T12:07:41.742Z","__v":0},{"_id":"60c9e9b37d119d797cb7b7fb","title":"jquery find,children,filter 的区别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"jquery-findchildrenfilter-的区别\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jquery find,children,filter 的区别；</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">filter 是对自身集合元素的操作，</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">children 是对子元素的检索，</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">find 是对它的后代元素的检索操作</span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">.children(selector) 方法是返回匹配元素集合中每个元素的所有子元素（仅儿子辈）。参数可选，添加参数表示通过选择器进行过滤，对元素进行筛选。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">.find(selector) 方法是返回匹配元素集合中每个元素的后代。参数是必选的，可以为选择器、jquery 对象可元素来对元素进行筛选。</span></p>\n<div class=\"google-auto-placed ap_container\" style=\"padding: 0px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff; width: 870px; height: auto; clear: both; text-align: center;\"><span style=\"font-size: 12pt;\"><ins class=\"adsbygoogle adsbygoogle-noablate\" style=\"display: block; margin: auto; background-color: transparent; height: 0px;\" data-ad-format=\"auto\" data-ad-client=\"ca-pub-3504340093271389\" data-adsbygoogle-status=\"done\" data-ad-status=\"unfilled\"><ins id=\"aswift_3_expand\" style=\"display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent;\" tabindex=\"0\" title=\"Advertisement\" aria-label=\"Advertisement\"><ins id=\"aswift_3_anchor\" style=\"display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent; overflow: hidden; opacity: 0;\"><iframe id=\"aswift_3\" style=\"left: 0px; position: absolute; top: 0px; border-width: 0px; border-style: initial; width: 870px; height: 0px;\" src=\"https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3504340093271389&amp;output=html&amp;h=280&amp;adk=109321987&amp;adf=3163410877&amp;pi=t.aa~a.2817947589~i.7~rp.4&amp;w=870&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1622810661&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9523024247&amp;psa=1&amp;ad_type=text_image&amp;format=870x280&amp;url=https%3A%2F%2Fwww.axihe.com%2Ffocus%2Fjquery%2F11.html&amp;flash=0&amp;fwr=0&amp;pra=3&amp;rh=200&amp;rw=870&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;uach=WyJXaW5kb3dzIiwiMTAuMCIsIng4NiIsIiIsIjkxLjAuNDQ3Mi4xMDEiLFtdXQ..&amp;dt=1623845269091&amp;bpp=1&amp;bdt=297&amp;idt=1&amp;shv=r20210610&amp;cbv=%2Fr20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3Dc42b20e6ee6efa3d-221193c456c90083%3AT%3D1623293344%3ART%3D1623293344%3AS%3DALNI_MbzQJ6BWGNxs0oRE7-tp-4q8E74oA&amp;prev_fmts=0x0%2C890x280%2C878x280&amp;nras=2&amp;correlator=8744136931671&amp;frm=20&amp;pv=1&amp;ga_vid=1650257871.1623845269&amp;ga_sid=1623845269&amp;ga_hid=1031739501&amp;ga_fc=0&amp;u_tz=480&amp;u_his=4&amp;u_java=0&amp;u_h=864&amp;u_w=1536&amp;u_ah=824&amp;u_aw=1536&amp;u_cd=24&amp;u_nplug=3&amp;u_nmime=4&amp;adx=325&amp;ady=757&amp;biw=1519&amp;bih=722&amp;scr_x=0&amp;scr_y=0&amp;eid=42530672&amp;oid=3&amp;pvsid=1476473340187422&amp;pem=199&amp;ref=https%3A%2F%2Fwww.axihe.com%2Fmap%2Fjquery-focus.html&amp;eae=0&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1536%2C0%2C1536%2C824%2C1536%2C722&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;ifi=4&amp;uci=a!4&amp;btvi=2&amp;fsb=1&amp;xpc=EkSKF01tv4&amp;p=https%3A//www.axihe.com&amp;dtd=13\" name=\"aswift_3\" width=\"870\" height=\"0\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" sandbox=\"allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation\" allowfullscreen=\"allowfullscreen\" data-google-container-id=\"a!4\" data-load-complete=\"true\" data-google-query-id=\"CK6e_oOPnPECFRhuvQodi_IFpw\"></iframe></ins></ins></ins></span></div>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">.find() 与 .children() 方法类似，不同的是后者仅沿着 DOM 树向下遍历单一层级。这里的 children，我理解为儿子，只在儿子这一级遍历。</span></p>","rank_id":423,"createdAt":"2021-06-16T12:08:19.929Z","updatedAt":"2021-06-16T12:08:19.929Z","__v":0},{"_id":"60c9e9e97d119d797cb7b7fc","title":"写出和 $(\"#div+li\") 选择器对应的 jQuery 方法","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>$('#div1).next('li')</code></pre>","rank_id":424,"createdAt":"2021-06-16T12:09:13.542Z","updatedAt":"2021-06-16T12:09:13.542Z","__v":0},{"_id":"60c9ea037d119d797cb7b7fd","title":"让 JS 再 DOM 加载完成后再执行，（可以模拟 $(document).ready 事件）","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code> function ready(fn){\n \tif(document.addEventListener){\t\t//标准浏览器\n \t\tdocument.addEventListener('DOMContentLoaded',function(){\n \t\t\t//注销时间，避免反复触发\n     \t      document.removeEventListener('DOMContentLoaded',arguments.callee,false);\n \t      fn();\t\t//执行函数\n \t\t},false);\n \t}else if(document.attachEvent){\t\t//IE浏览器\n \t\tdocument.attachEvent('onreadystatechange',function(){\n \t\t\tif(document.readyState=='complete'){\n \t\t              document.detachEvent('onreadystatechange',arguments.callee);\n \t\t\t\tfn();\t\t//函数执行\n \t\t\t}\n \t\t});\n \t}\n }</code></pre>","rank_id":425,"createdAt":"2021-06-16T12:09:39.381Z","updatedAt":"2021-06-16T12:09:39.381Z","__v":0},{"_id":"60c9ea517d119d797cb7b7fe","title":"jquery 中如何将数组转化为 json 字符串，然后再转化回来？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>$.fn.stringifyArray = function(array) {\n\treturn JSON.stringify(array)\n}\n$.fn.parseArray = function(array) {\n\treturn JSON.parse(array)\n}\n\n$(\"\").stringifyArray(array)</code></pre>","rank_id":426,"createdAt":"2021-06-16T12:10:57.791Z","updatedAt":"2021-06-16T12:10:57.791Z","__v":0},{"_id":"60c9ea6f7d119d797cb7b7ff","title":"jquery 对象和 dom 对象怎么转换的？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">[0]</code>&nbsp;可以转化为 DOM 对象</li>\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$(domObject)</code>&nbsp;可以转化为 jQuery 对象</li>\n</ul>","rank_id":427,"createdAt":"2021-06-16T12:11:27.477Z","updatedAt":"2021-06-16T12:11:27.477Z","__v":0},{"_id":"60c9ea9b7d119d797cb7b800","title":"用 jquery 实现，将页面中所有 class 为 a 的 div 找出，并把字体颜色设置为红色；","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>$(\"div.a\") .css(\"color\",\"red\");</code></pre>","rank_id":428,"createdAt":"2021-06-16T12:12:11.143Z","updatedAt":"2021-06-16T12:12:11.143Z","__v":0},{"_id":"60c9eac17d119d797cb7b801","title":"jQuery 的队列是如何实现的？队列可以用在哪些地方？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"jquery-的队列是如何实现的队列可以用在哪些地方\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jQuery 的队列是如何实现的？队列可以用在哪些地方？</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jQuery 核心中，有一组队列控制方法，这组方法由 queue()/dequeue()/clearQueue() 三个方法组成，它对需要连续按序执行的函数的控制可以说是简明自如，主要应用于 animate () 方法，ajax 以及其他要按时间顺序执行的事件中。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">先解释一下这组方法各自的含义。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">queue(name,[callback])</code>: 当只传入一个参数时，它返回并指向第一个匹配元素的队列（将是一个函数数组，队列名默认是 fx); 当有两个参数传入时，第一个参数还是默认为 fx 的的队列名，第二个参数又分两种情况，当第二个参数是一个函数时，它将在匹配的元素的队列最后添加一个函数。当第二个参数是一个函数数组时，它将匹配元素的队列用新的一个队列来代替（函数数组）. 可能，这个理解起来有点晕。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">dequeue(name)</code>: 这个好理解，就是从队列最前端移除一个队列函数，并执行它。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">clearQueue([queueName])</code>: 这是 1.4 新增的方法。清空对象上尚未执行的所有队列。参数可选，默认为 fx. 但个人觉得这个方法没多大用，用 queue() 方法传入两个参数的第二种参数即可实现 clearQueue 方法。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">现在，我们要实现这样一个效果，有标有 1 至 7 的数字方块，要求这七个方块自左到右依次下落；写好以后</span></p>\n<div class=\"google-auto-placed ap_container\" style=\"padding: 0px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff; width: 870px; height: auto; clear: both; text-align: center;\"><span style=\"font-size: 12pt;\"><ins class=\"adsbygoogle adsbygoogle-noablate\" style=\"display: block; margin: auto; background-color: transparent; height: 0px;\" data-ad-format=\"auto\" data-ad-client=\"ca-pub-3504340093271389\" data-adsbygoogle-status=\"done\" data-ad-status=\"unfilled\"><ins id=\"aswift_3_expand\" style=\"display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent;\" tabindex=\"0\" title=\"Advertisement\" aria-label=\"Advertisement\"><ins id=\"aswift_3_anchor\" style=\"display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent; overflow: hidden; opacity: 0;\"><iframe id=\"aswift_3\" style=\"left: 0px; position: absolute; top: 0px; border-width: 0px; border-style: initial; width: 870px; height: 0px;\" src=\"https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3504340093271389&amp;output=html&amp;h=280&amp;adk=109321987&amp;adf=3163410877&amp;pi=t.aa~a.2817947589~i.13~rp.4&amp;w=870&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1622810661&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9523024247&amp;psa=1&amp;ad_type=text_image&amp;format=870x280&amp;url=https%3A%2F%2Fwww.axihe.com%2Ffocus%2Fjquery%2F22.html&amp;flash=0&amp;fwr=0&amp;pra=3&amp;rh=200&amp;rw=870&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;uach=WyJXaW5kb3dzIiwiMTAuMCIsIng4NiIsIiIsIjkxLjAuNDQ3Mi4xMDEiLFtdXQ..&amp;dt=1623845539188&amp;bpp=1&amp;bdt=335&amp;idt=1&amp;shv=r20210610&amp;cbv=%2Fr20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3Dc42b20e6ee6efa3d-221193c456c90083%3AT%3D1623293344%3ART%3D1623293344%3AS%3DALNI_MbzQJ6BWGNxs0oRE7-tp-4q8E74oA&amp;prev_fmts=0x0%2C890x280%2C878x280&amp;nras=2&amp;correlator=2065252257503&amp;frm=20&amp;pv=1&amp;ga_vid=1036418927.1623845539&amp;ga_sid=1623845539&amp;ga_hid=1196716326&amp;ga_fc=0&amp;u_tz=480&amp;u_his=4&amp;u_java=0&amp;u_h=864&amp;u_w=1536&amp;u_ah=824&amp;u_aw=1536&amp;u_cd=24&amp;u_nplug=3&amp;u_nmime=4&amp;adx=325&amp;ady=972&amp;biw=1519&amp;bih=722&amp;scr_x=0&amp;scr_y=0&amp;eid=31061406&amp;oid=3&amp;pvsid=427954264326297&amp;pem=199&amp;ref=https%3A%2F%2Fwww.axihe.com%2Fmap%2Fjquery-focus.html&amp;eae=0&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1536%2C0%2C1536%2C824%2C1536%2C722&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;ifi=4&amp;uci=a!4&amp;btvi=2&amp;fsb=1&amp;xpc=Y3pW6QTiXr&amp;p=https%3A//www.axihe.com&amp;dtd=14\" name=\"aswift_3\" width=\"870\" height=\"0\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" sandbox=\"allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation\" allowfullscreen=\"allowfullscreen\" data-google-container-id=\"a!4\" data-load-complete=\"true\" data-google-query-id=\"COvm44SQnPECFdUpKgodtKcOSA\"></iframe></ins></ins></ins></span></div>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">；如果此时，你想调换一个某个的执行顺序，比如，你想让 5 落下后再开始下落 3, 或者新加 8 至 15 八个方块，怎么办？</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">重写吗？在里面小心冀冀的改吗？显然，我们需要另外一种列简明便捷的方法来实现这个效果，那就是 jQuery 队列控制方法。；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这样一来，看起来是不是简明多了。如何实现？</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">新建一个数组，把动画函数依次放进去（这样更改顺序，新加动画是不是方便多了？);</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">用 queue 将这组动画函数数组加入到 slideList 队列中；</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">用 dequeue 取出 slideList 队列中第一个函数，并执行它；</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">初始执行第一个函数。</span></li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">至于 clearQueue() 方法，就不多说了，演示中停止按钮调用的就是 clearQueue() 方法，当然你还可以用 queue() 方法直接将现在的函数列队替换成 [] 空数组实现（个人比较推荐空数组替换。, 更直观）.</span></p>","rank_id":429,"createdAt":"2021-06-16T12:12:49.631Z","updatedAt":"2021-06-16T12:12:49.631Z","__v":0},{"_id":"60c9eb377d119d797cb7b802","title":"谈一下 jQuery 中的 bind(),live(),delegate(),on() 的区别？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; background-color: #ffffff;\">bind(type,[data],fn)</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; background-color: #ffffff;\">&nbsp;为每个匹配元素的特定事件绑定事件处理函数</span></span></p>\n<pre class=\"language-javascript\"><code>$(\"a\").bind(\"click\",function(){alert(\"ok\");});</code></pre>\n<p><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; background-color: #ffffff;\">live(type,[data],fn)</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; background-color: #ffffff;\">&nbsp;给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的</span></span></p>\n<pre class=\"language-javascript\"><code>$(\"a\").live(\"click\",function(){alert(\"ok\");});</code></pre>\n<p><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; background-color: #ffffff;\">delegate(selector,[type],[data],fn)</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; background-color: #ffffff;\">&nbsp;指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数</span></span></p>\n<pre class=\"language-javascript\"><code>$(\"#container\").delegate(\"a\",\"click\",function(){alert(\"ok\");})</code></pre>\n<p><span style=\"font-size: 12pt;\"><strong style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; background-color: #ffffff;\">on(events,[selector],[data],fn)</strong><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; background-color: #ffffff;\">&nbsp;在选择元素上绑定一个或多个事件的事件处理函数</span></span></p>\n<h2 id=\"差别\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">差别</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">1、.bind() 是直接绑定在元素上</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">2、.live() 则是通过冒泡的方式来绑定到元素上的。更适合列表类型的，绑定到 document DOM 节点上。和。bind() 的优势是支持动态数据。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">3、.delegate() 则是更精确的小范围使用事件代理，性能优于。live()</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">4、.on() 则是最新的 1.9 版本整合了之前的三种方式的新事件绑定机制</span></li>\n</ul>","rank_id":430,"createdAt":"2021-06-16T12:14:47.354Z","updatedAt":"2021-06-16T12:14:47.354Z","__v":0},{"_id":"60c9eb877d119d797cb7b803","title":"jQuery 一个对象可以同时绑定多个事件，这是如何实现的？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>$ele.on('eventName', handle1);\n$ele.on('eventName', handle2);\n$ele.on('eventName', handle3);</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">其实&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$ele</code>&nbsp;元素的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">eventName</code>&nbsp;事件有一个处理函数数组 监听一次就往里面放一个 handle，数组是先进后出型的</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">也就是栈， 然后触发事件的时候一次执行</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">上面的监听相当于</p>\n<pre class=\"language-javascript\"><code>$ele.eventHandle['eventName'] = [];\n$ele.eventHandle['eventName'].push(handle1);\n$ele.eventHandle['eventName'].push(handle2);\n$ele.eventHandle['eventName'].push(handle3);</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">然后&nbsp;</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">$ele.trigger('eventName')</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">&nbsp;触发的时候， 从栈里面取出处理函数执行</span></p>\n<pre class=\"language-javascript\"><code>while($ele.eventHandle['eventName'].length) {\n\thandle = $ele.eventHandle['eventName'].pop();\n\thandle();\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">最先监听的最后执行；</span></p>","rank_id":431,"createdAt":"2021-06-16T12:16:07.866Z","updatedAt":"2021-06-16T12:16:07.866Z","__v":0},{"_id":"60c9ebfd7d119d797cb7b804","title":"jQuery 的 slideUp 动画 ，如果目标元素是被外部事件驱动，当鼠标快速地连续触发外部元素事件，动画会滞后的反复执行，该如何处理呢？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jQuery 中 slideUp 、slideDown、animate 等动画运用时，如果目标元素是被外部事件驱动，当鼠标快速地连续触发外部元素事件，动画会滞后的反复执行，其表现不雅。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">则解决办法：</span></p>\n<ul>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">1、在触发元素上的事件设置为延迟处理，即可避免滞后反复执行的问题（使用 setTimeout）</span></li>\n<li><span style=\"font-size: 12pt;\">2、在触发元素的事件时预先停止所有的动画，再执行相应的动画事件（使用 stop）</span></li>\n</ul>\n<p><span style=\"font-size: 12pt;\">jquery stop：</span></p>\n<pre class=\"language-javascript\"><code>// 语法结构\n$(\"#div\").stop();// 停止当前动画，继续下一个动画\n$(\"#div\").stop(true);// 清除元素的所有动画\n$(\"#div\").stop(false, true);// 让当前动画直接到达末状态 ，继续下一个动画\n$(\"#div\").stop(true, true);// 清除元素的所有动画，让当前动画直接到达末状态</code></pre>\n<h2 id=\"jquery-stop\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; letter-spacing: 2px;\"></h2>\n<h2 id=\"一般推荐使用第二种方法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">一般推荐使用第二种方法</span></h2>\n<pre class=\"language-javascript\"><code>$(\"#div\").stop().animate({width:\"100px\"},100);</code></pre>","rank_id":432,"createdAt":"2021-06-16T12:18:05.972Z","updatedAt":"2021-06-16T12:18:05.972Z","__v":0},{"_id":"60c9ec267d119d797cb7b805","title":"jquery 特点，聊一聊 jquery","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"jquery-特点聊一聊-jquery\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jquery 特点，聊一聊 jquery；</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">jQuery 是一款轻量级的 js 框架，jQuery 核心 js 文件才几十 kb，不会影响页面加载速度。与 Extjs 相比要轻便的多。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">jQuery 的选择器用起来很方便，好比说我要找到某个 dom 对象的相邻元素 js 可能要写好几行代码，而 jQuery 一行代码就搞定了，再比如我要将一个表格的隔行变色，jQuery 也是一行代码搞定。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">jQuery 的链式操作可以把多个操作写在一行代码里。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">jQuery 还简化了 js 操作 css 的代码，并且代码的可读性也比 js 要强。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">jQuery 简化了 AJAX 操作，后台只需返回一个 JSON 格式的字符串就能完成与前台的通信。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">jQuery 基本兼容了现在主流的浏览器，不用再为浏览器的兼容问题而伤透脑筋。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">jQuery 有着丰富的第三方的插件，例如：树形菜单、日期控件、图片切换插件、弹出窗口等等基本前台页面上的组件都有对应插件，并且用 jQuery 插件做出来的效果很炫，并且可以根据自己需要去改写和封装插件，简单实用。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">jQuery 可扩展性强，jQuery 提供了扩展接口：jQuery.extend(object), 可以在 jQuery 的命名空间上增加新函数。jQuery 的所有插件都是基于这个扩展接口开发的。</span></li>\n</ul>","rank_id":433,"createdAt":"2021-06-16T12:18:46.941Z","updatedAt":"2021-06-16T12:18:46.941Z","__v":0},{"_id":"60c9ec887d119d797cb7b806","title":"jquery 的链式写法的原理是什么？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol>\n<li><span style=\"font-size: 12pt;\">通过简单扩展原型方法并通过&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">return this</code>&nbsp;的形式来实现跨浏览器的链式调用。</span></li>\n<li><span style=\"font-size: 12pt;\">利用 JS 下的简单工厂模式，来将所有对于同一个 DOM 对象的操作指定同一个实例。</span></li>\n</ol>\n<p><span style=\"font-size: 12pt;\">链式代码：</span></p>\n<pre class=\"language-javascript\"><code>$('input[type=\"button\"]')\n    .eq(0).click(function() {\n        alert('点击我!');\n}).end().eq(1)\n.click(function() {\n    $('input[type=\"button\"]:eq(0)').trigger('click');\n}).end().eq(2)\n.toggle(function() {\n    $('.aa').hide('slow');\n}, function() {\n    $('.aa').show('slow');\n});</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">找出 type 类型为 button 的 input 元素</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">找到第一个按钮，并绑定 click 事件处理函数</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">返回所有按钮，再找到第二个</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">为第二个按钮绑定 click 事件处理函数</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">为第三个按钮绑定 toggle 事件处理函数</span></p>","rank_id":434,"createdAt":"2021-06-16T12:20:24.993Z","updatedAt":"2021-06-16T12:20:24.993Z","__v":0},{"_id":"60c9ecc47d119d797cb7b807","title":"模拟 jquery 的 $ 选择器","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"模拟-jquery-的--选择器\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">模拟 jquery 的 $ 选择器</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">直接看代码的吧</span></p>\n<pre class=\"language-javascript\"><code>/*********************************************\n  JS 模拟 jQuery 选择器\n  by http://www.cnblogs.com/zjfree\n  Date 2012-02-22\n  已实现：\n  $('#div1') ID 选择器 （直接返回对象）\n  $('.aCur') 类选择器\n  $('div') 元素选择器\n  $('#div1 li') 组合选择器\n  $('input[type=text]:checked') 属性值选择器\n  $('a', myDiv) 选择 myDiv 下的所有 a 元素\n/*********************************************/\n//q 查询表达式 o 父对象\nfunction $(q, o){\n    //debugger;\n    // 查询表达式必须为字符串，并且不能为空。\n    if(typeof(q)!=='string' || q == '') return [];\n    // 使用空格分割，只处理第一个表达式\n    var ss = q.split(' ');\n    // 获取属性\n    var attr = '';\n    var s = ss[0].split(':')[0];\n    if(s != ss[0])\n        attr = ss[0].split(':')[1];\n    var val = s.split('[')[0];\n    if(val != s)\n        val = s.split('[')[1].replace(/[\",\\]]/g,'');\n    else\n        val = '';\n    s = s.split('[')[0];\n    var obj = [];\n    var sObj = null;\n    // 当父对象不存在时，使用 document;\n    o = o || document;\n    switch(s.charAt(0))\n    {\n        case '#':\n            //ID 选择器\n            sObj = document.getElementById(s.substr(1));\n            if(sObj)obj.push(sObj);\n            break;\n        case '.':\n            // 类选择器\n            var l = o.getElementsByTagName('*');\n            var c = s.substr(1);\n            for(var i=0; i&lt;l.length; i++)\n            if(l[i].className.search('\\\\b' + c + '\\\\b')!=-1)obj.push(l[i]);\n            break;\n        default:\n            // 根据 tag 获取元素\n            obj = o.getElementsByTagName(s);\n            break;\n    }\n    if(val)\n    {\n        //[t=val] 筛选属性匹配\n        var l = [];\n        var a = val.split('=');\n        for(var i=0; i&lt;obj.length; i++)\n            if(a.length == 2 &amp;&amp; obj[i](a[0)] == a[1]) l.push(obj[i]);\n        obj = l;\n    }\n    if(attr)\n    {\n        //: 筛选属性匹配\n        var l = [];\n        for(var i=0; i&lt;obj.length; i++)\n            if(obj[i](attr)) l.push(obj[i]);\n        obj = l;\n    }\n    if(ss.length &gt; 1)\n    {\n        // 递归处理表达式后续内容\n        // 父元素为已获取的所有元素\n        var l = [];\n        for(var i=0; i&lt;obj.length; i++){\n            var ll = arguments.callee(q.substr(ss[0].length+1), obj[i]);\n            if(ll.tagName) l.push(ll);\n            else\n            for(var j=0; j&lt;ll.length; j++)l.push(ll[j]);\n        }\n        obj = l;\n    }\n    if(sObj &amp;&amp; ss.length == 1){\n        // 当为 ID 选择器时，直接返回对象。\n        obj=sObj;\n        if(obj)obj.length = 1;\n    } else {\n        // 去除数组中重复元素\n        var l = [];\n        for(var i=0; i&lt;obj.length; i++)obj[i].$isAdd = false;\n        for(var i=0; i&lt;obj.length; i++){\n            if(!obj[i].$isAdd){\n                obj[i].$isAdd = true;\n                l.push(obj[i]);\n            }\n        }\n        obj = l;\n    }\n    return obj;\n }</code></pre>","rank_id":435,"createdAt":"2021-06-16T12:21:24.085Z","updatedAt":"2021-06-16T12:21:24.085Z","__v":0},{"_id":"60c9ed887d119d797cb7b808","title":"jQuery 的源码看过吗？能不能简单概况一下它的实现原理？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">1、闭包机制；</span></h2>\n<pre class=\"language-javascript\"><code>// 以下截取自 jquery 源码片段\n (function( window, undefined ) {\n    /*    源码内容    */\n })( window );</code></pre>\n<h2 id=\"1闭包机制\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">上面这一小段代码来自于 1.9.0 当中 jquery 的源码，它是一个无污染的 JS 插件的标准写法，专业名词叫闭包。可以把它简单的看做是一个函数，与普通函数不同的是，这个函数没有名字，而且会立即执行</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">我们将里面的变量变成了局域变量，这不仅可以提高运行速度，更重要的是我们在引用 jquery 的 JS 文件时，不会因为 jquery 当中的变量太多，而与其它的 JS 框架的变量命名产生冲突；闭包中的变量声明没有污染到外面的全局变量；;</span></p>\n<h2 style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">2、作为全局的一个属性；</span></h2>\n<pre class=\"language-javascript\"><code>window.jQuery = window.$ = jQuery;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这一句话将我们在闭包当中定义的 jQuery 对象导出为全局变量 jQuery 和 $，因此我们才可以在外部直接使用 jQuery 和 $。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">window 是默认的 JS 上下文环境，因此将对象绑定到 window 上面，就相当于变成了传统意义上的全局变量，</span></p>\n<h2 id=\"3最核心的功能就是选择器\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">3、最核心的功能，就是选择器；</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">首先我们进入 jquery 源码中，可以很容易的找到 jquery 对象的声明，看过以后会发现，原来我们的 jquery 对象就是 init 对象。</span></p>\n<pre class=\"language-javascript\"><code>jQuery = function( selector, context ) {\n\treturn new jQuery.fn.init( selector, context, rootjQuery );\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 12pt; background-color: #ffffff;\">这里出现了 jQuery.fn 这样一个东西，它的由来可以在 jquery 的源码中找到，它其实代表的就是 jQuery 对象的原型。</span></p>\n<pre class=\"language-javascript\"><code>jQuery.fn = jQuery.prototype;\njQuery.fn.init.prototype = jQuery.fn;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这两句话，第一句把 jQuery 对象的原型赋给了 fn 属性，第二句把 jQuery 对象的原型又赋给了 init 对象的原型。也就是说，init 对象和 jQuery 具有相同的原型，因此我们在上面返回的 init 对象，就与 jQuery 对象有一样的属性和方法。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">我们不打算深究 init 这个方法的逻辑以及实现，但是我们需要知道的是，jQuery 其实就是将 DOM 对象加了一层包裹，而寻找某个或者若干个 DOM 对象是由 sizzle 选择器负责的，jQuery 对象有很多的属性和方法；对于属性来说，我们最需要关注的只有一个属性，就是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">[0]</code>&nbsp;属性，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">[0]</code>&nbsp;其实就是原生的 DOM 对象。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">很多时候，我们在 jQuery 和 DOM 对象之间切换时需要用到&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">[0]</code>&nbsp;这个属性。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">从截图也可以看出，jQuery 对象其实主要就是把原生的 DOM 对象存在了&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">[0]</code>&nbsp;的位置，并给它加了一系列简便的方法。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这个索引 0 的属性我们可以从一小段代码简单的看一下它的由来，下面是 init 方法中的一小段对 DOMElement 对象作为选择器的源码。</span></p>\n<pre class=\"language-javascript\"><code>// Handle $(DOMElement)\nif ( selector.nodeType ) {\n\t/*     可以看到，这里将 DOM 对象赋给了 jQuery 对象的 [0] 这个位置  */\n\tthis.context = this[0] = selector;\n\tthis.length = 1;\n\treturn this;\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这一小段代码可以在 jquery 源码中找到，它是处理传入的选择参数是一个 DOM 对象的情况。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">可以看到，里面很明显的将 jQuery 对象索引 0 的位置以及 context 属性，都赋予了 DOM 对象</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">。代码不仅说明了这一点，也同时说明了，我们使用 $(DOMElement) 可以将一个 DOM 对象转换为 jQuery 对象，从而通过转换获得 jQuery 对象的简便方法。</span></p>\n<h2 id=\"4ready-方法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">4、ready 方法</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$(function(){})</code>&nbsp;或者是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">ready</code>&nbsp;方法；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">实现类似 jquery 的 ready 方法的效果我们是可以简单做到的，它的实现原理就是，维护一个函数数组，然后不停的判断 DOM 是否加载完毕，倘若加载完毕就触发所有数组中的函数。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">遵循着这一思想，LZ 拿出很久之前写的一个小例子，来给各位看一下。</span></p>\n<pre class=\"language-javascript\"><code>(function( window, undefined ) {\nvar jQuery = {\n        isReady:false,// 文档加载是否完成的标识\n        readyList:[],// 函数序列\n        //onload 事件实现\n        ready : function(fn){\n                // 如果是函数，加入到函数序列\n                if(fn &amp;&amp; typeof fn == 'function' ){\n                    jQuery.readyList.push(fn);\n                }\n                // 文档加载完成，执行函数序列。\n                if(jQuery.isReady){\n                    for(var i = 0;i &lt; jQuery.readyList.length ;i++){\n                        fn = jQuery.readyList[i];\n                        jQuery.callback(fn);\n                    }\n                    return jQuery;\n                }\n            },\n        // 回调\n        callback : function(fn){\n            fn.call(document,jQuery);\n        }\n    };\n    // 导出对象\n    window.$ = window.jQuery = jQuery;\n    // 判断加载是否完成\n    var top = false;\n    try {\n        top = window.frameElement == null &amp;&amp; document.documentElement;\n    } catch(e) {}\n    if ( top &amp;&amp; top.doScroll ) {\n        (function doScrollCheck() {\n            try {\n                top.doScroll(\"left\");\n                jQuery.isReady = true;\n                jQuery.ready();\n            } catch(e) {\n                setTimeout( doScrollCheck, 50 );\n            }\n        })();\n    }\n}(window));</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">这段代码是 LZ 从之前的例子摘出来的，它的实现逻辑非常简单，但是可以达到 jQuery 的 ready 方法的效果，</span></p>\n<h2 id=\"5extend-方法\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">5、extend 方法</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">简单说两个 extend 方法的常用方式。</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">1、使用 jQuery.fn.extend 可以扩展 jQuery 对象，使用 jQuery.extend 可以扩展 jQuery，前者类似于给类添加普通方法，后者类似于给类添加静态方法。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">2、两个 extend 方法如果有两个 object 类型的参数，则会将后面的参数对象属性扩展到第一个参数对象上面，扩展时可以再添加一个 boolean 参数控制是否深度拷贝。</span></li>\n</ul>\n<h2 id=\"2作为全局的一个属性\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"></h2>","rank_id":436,"createdAt":"2021-06-16T12:24:40.931Z","updatedAt":"2021-06-16T12:24:40.931Z","__v":0},{"_id":"60c9edd67d119d797cb7b809","title":"jQuery.fn 的 init 方法返回的 this 指的是什么对象？为什么要返回 this？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"jqueryfn-的-init-方法返回的-this-指的是什么对象为什么要返回-this\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">jQuery.fn 的 init 方法返回的 this 指的是什么对象？为什么要返回 this？</h2>\n<blockquote style=\"padding: 0px 0px 8px; margin: 10px 0px; color: #828201; border-width: 1px 1px 1px 5px; border-style: solid; border-color: #e2e2e2 #e2e2e2 #e2e2e2 #fff000; border-image: initial; background-color: #ffffc0; overflow: hidden; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">为了怎么调用返回都是 JQ 对象，可以不断调用 JQ 函数；</p>\n</blockquote>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在 jQuery 源码中是这么定义的</p>\n<pre class=\"language-javascript\"><code>jQuery = function( selector, context ) {\n   // The jQuery object is actually just the init constructor 'enhanced'\n   return new jQuery.fn.init( selector, context, rootjQuery );\n },</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">然后通过</span></p>\n<pre class=\"language-javascript\"><code>jQuery.fn = jQuery.prototype\n\njQuery.fn.init.prototype=jQuery.fn</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">把它们联系在一起。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">为什么要这么做呢？为什么定义 jQuery 的时候不直接实现而是让 jQuery.fn.init 实现呢？</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">是属于拷贝属性，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">理解这个问题的关键是 new 关键字。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我的理解大致是这样的：</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果是 jQuery 自己实现的话也可以，但是像原本的&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">$(\"#id\")</code>&nbsp;就要写成<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&nbsp;new $(\"#id\")</code>。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为直接调用方法并且方法体内没有 return 的话返回的是 undefined, 即使 return this，其实他的 this 是指的 window。</p>\n<div class=\"google-auto-placed ap_container\" style=\"padding: 0px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff; width: 870px; height: auto; clear: both; text-align: center;\"><ins class=\"adsbygoogle adsbygoogle-noablate\" style=\"display: block; margin: auto; background-color: transparent; height: 0px;\" data-ad-format=\"auto\" data-ad-client=\"ca-pub-3504340093271389\" data-adsbygoogle-status=\"done\" data-ad-status=\"unfilled\"><ins id=\"aswift_3_expand\" style=\"border: none; height: 0px; width: 870px; margin: 0px; padding: 0px; position: relative; visibility: visible; background-color: transparent; display: inline-table;\" tabindex=\"0\" title=\"Advertisement\" aria-label=\"Advertisement\"><ins id=\"aswift_3_anchor\" style=\"border: none; height: 0px; width: 870px; margin: 0px; padding: 0px; position: relative; visibility: visible; background-color: transparent; display: block; overflow: hidden; opacity: 0;\"><iframe id=\"aswift_3\" style=\"left: 0px; position: absolute; top: 0px; border-width: 0px; border-style: initial; width: 870px; height: 0px;\" src=\"https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3504340093271389&amp;output=html&amp;h=280&amp;adk=109321987&amp;adf=3163410877&amp;pi=t.aa~a.2817947589~i.26~rp.4&amp;w=870&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1622810661&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9523024247&amp;psa=1&amp;ad_type=text_image&amp;format=870x280&amp;url=https%3A%2F%2Fwww.axihe.com%2Ffocus%2Fjquery%2F18.html&amp;flash=0&amp;fwr=0&amp;pra=3&amp;rh=200&amp;rw=870&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;uach=WyJXaW5kb3dzIiwiMTAuMCIsIng4NiIsIiIsIjkxLjAuNDQ3Mi4xMDEiLFtdXQ..&amp;dt=1623846287925&amp;bpp=1&amp;bdt=315&amp;idt=1&amp;shv=r20210610&amp;cbv=%2Fr20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3Dc42b20e6ee6efa3d-221193c456c90083%3AT%3D1623293344%3ART%3D1623293344%3AS%3DALNI_MbzQJ6BWGNxs0oRE7-tp-4q8E74oA&amp;prev_fmts=0x0%2C890x280%2C878x280&amp;nras=2&amp;correlator=3276852327612&amp;frm=20&amp;pv=1&amp;ga_vid=729814484.1623846288&amp;ga_sid=1623846288&amp;ga_hid=814451830&amp;ga_fc=0&amp;u_tz=480&amp;u_his=4&amp;u_java=0&amp;u_h=864&amp;u_w=1536&amp;u_ah=824&amp;u_aw=1536&amp;u_cd=24&amp;u_nplug=3&amp;u_nmime=4&amp;adx=325&amp;ady=1322&amp;biw=1519&amp;bih=722&amp;scr_x=0&amp;scr_y=0&amp;eid=31060957%2C31060972&amp;oid=3&amp;pvsid=2544871572939525&amp;pem=199&amp;ref=https%3A%2F%2Fwww.axihe.com%2Fmap%2Fjquery-focus.html&amp;eae=0&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1536%2C0%2C1536%2C824%2C1536%2C722&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;ifi=4&amp;uci=a!4&amp;btvi=2&amp;fsb=1&amp;xpc=i9NhZeBOF1&amp;p=https%3A//www.axihe.com&amp;dtd=13\" name=\"aswift_3\" width=\"870\" height=\"0\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" sandbox=\"allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation\" allowfullscreen=\"allowfullscreen\" data-google-container-id=\"a!4\" data-load-complete=\"true\" data-google-query-id=\"CNGB5-mSnPECFU9mvAodxQcLlA\"></iframe></ins></ins></ins></div>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">jQuery 的这种写法更像是一种的工厂模式，每次都会返回一个 jQuery 实例，然后继续调用各种方法。</p>","rank_id":437,"createdAt":"2021-06-16T12:25:58.041Z","updatedAt":"2021-06-16T12:25:58.041Z","__v":0},{"_id":"60c9ee467d119d797cb7b80a","title":"jQuery 的属性拷贝 (extend) 的实现原理是什么，如何实现深拷贝？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code> jQuery.extend = jQuery.fn.extend = function() {\n     // 定义默认参数和变量\n     // 对象分为扩展对象和被扩展的对象\n     //options 代表扩展的对象中的方法\n     //name 代表扩展对象的方法名\n     //i 为扩展对象参数起始值\n     //deep 默认为浅复制\n     var options, name, src, copy, copyIsArray, clone, target = arguments[0]  || {},\n     i = 1,\n     length = arguments.length,\n     deep = false;\n     // 当第一个参数为布尔类型是，次参数定义是否为深拷贝\n     // 对接下来的参数进行处理\n     if (typeof target === \"boolean\") {\n         deep = target;\n         target = arguments[1] || {};\n         // 当定义是否深拷贝时，参数往后移动一位\n         i = 2;\n     }\n     // 如果要扩展的不是对象或者函数，则定义要扩展的对象为空\n     if (typeof target !== \"object\" &amp;&amp; !jQuery.isFunction(target)) {\n         target = {};\n     }\n     // 当只含有一个参数时，被扩展的对象是 jQuery 或 jQuery.fn\n     if (length === i) {\n         target = this; --i;\n     }\n     // 对从 i 开始的多个参数进行遍历\n     for (; i &lt; length; i++) {\n         // 只处理有定义的值\n         if ((options = arguments[i]) != null) {\n             // 展开扩展对象\n             for (name in options) {\n                 src = target[name];\n                 copy = options[name];\n                 // 防止循环引用\n                 if (target === copy) {\n                     continue;\n                 }\n                 // 递归处理深拷贝\n                 if (deep &amp;&amp; copy &amp;&amp; ; (jQuery.isPlainObject(copy) \n                                          || (copyIsArray = jQuery.isArray(copy)))) {\n                     if (copyIsArray) {\n                         copyIsArray = false;\n                         clone = src &amp;&amp; jQuery.isArray(src) ? src: [];\n                     } else {\n                         clone = src &amp;&amp; jQuery.isPlainObject(src) ? src: {};\n                     }\n                     target[name] = jQuery.extend(deep, clone, copy);\n                     // 不处理未定义值\n                 } else if (copy !== undefined) {\n                     // 给 target 增加属性或方法\n                     target[name] = copy;\n                 }\n             }\n         }\n     }\n     // 返回\n     return target;\n };</code></pre>","rank_id":438,"createdAt":"2021-06-16T12:27:50.332Z","updatedAt":"2021-06-16T12:27:50.332Z","__v":0},{"_id":"60c9ee837d119d797cb7b80b","title":"在 jquery 中，选择器使用的是 sizzle，sizzle 的基本原理是”从后往前查找”","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">&nbsp;jquery 的源码，jquery 用的选择器的引擎是 sizzle，是 jquery 的作者另一开源项目，在 github 上面有，号称最快的 dom 选择器！</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">当你的 selector 里面不出现&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">nth|eq|gt|lt|first|last|even|odd</code>&nbsp;这样的字符时候， 从右向左，所谓的从右向左，比如 $(&lsquo;div img&rsquo;) 首先会把所有的 img 选出来，通过 parent 是 div 进行过滤 。 这样很高效的原因是只进行一次 dom 的查询！</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">当你 selector 出现了&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">nth|eq|gt|lt|first|last|even|odd</code>&nbsp;这样的字符的时候，从左向右！ 所谓从左向右，比如 $(&lsquo;div img:eq(1)') 先把所有的 div 选出来保存，在把 img 选出来通过 eq（1）过滤保存， 在对结果集操作，进行多次选择了</p>\n</li>\n</ul>","rank_id":439,"createdAt":"2021-06-16T12:28:51.972Z","updatedAt":"2021-06-16T12:28:51.972Z","__v":0},{"_id":"60c9eeec7d119d797cb7b80c","title":"jquery.extend 与 jquery.fn.extend 的区别？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">区别一</span></h3>\n<pre class=\"language-javascript\"><code>jquery.extend(object); 为扩展 jQuery 类本身。为类添加新的方法。\njquery.fn.extend(object); 给 jQuery 对象添加方法。\n$.extend({\n　　add:function(a,b){return a+b;}\n});\n//$.add(3,4);\n//return 7</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jQuery 添加一个为 add 的&ldquo;静态方法&rdquo;，之后便可以在引入 jQuery　的地方，使用这个方法了。</span></p>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">区别二</span></h3>\n<pre class=\"language-javascript\"><code>jQuery.fn.extend(object);</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">对&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">jQuery.prototype&nbsp;</code>进得扩展，就是为 jQuery 类添加&ldquo;成员函数&rdquo;。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">jQuery 类的实例可以使用这个&ldquo;成员函数&rdquo;。</span></p>\n<pre class=\"language-javascript\"><code>$.fn.extend({\nalertClick:function(){\n\t$(this).click(function(){\n\talert($(this).val());\n\t});\n}\n});</code></pre>\n<p><span style=\"font-size: 12pt;\"><strong style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; background-color: #ffffff;\">页面上为</strong></span></p>\n<pre class=\"language-markup\"><code>&lt;input id=\"input1\" type=\"text\"/&gt;</code></pre>\n<p><span style=\"font-size: 12pt;\"><strong style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; background-color: #ffffff;\">使用</strong></span></p>\n<pre class=\"language-javascript\"><code>// 使用\n$(\"#input1\").alertClick();</code></pre>\n<h3 id=\"区别二\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>\n<h3 id=\"区别一\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>","rank_id":440,"createdAt":"2021-06-16T12:30:36.208Z","updatedAt":"2021-06-16T12:30:36.209Z","__v":0},{"_id":"60c9ef057d119d797cb7b80d","title":"你觉得jQuery源码有哪些写的好的地⽅","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">jquery 源码封装在⼀个匿名函数的⾃执⾏环境中，有助于防⽌变量的全局污染，然后通 过传⼊ window 对象参数，可以使 window 对象作为局部变量使⽤，好处是当 jquery 中 访问 window 对象的时候，就不⽤将作⽤域链退回到顶层作⽤域了，从⽽可以更快的访问 window对象。同样，传⼊ undefined 参数，可以缩短查找 undefined 时的作⽤域链</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">jquery 将⼀些原型属性和⽅法封装在了 jquery.prototype 中，为了缩短名称，⼜赋值 给了 jquery.fn ，这是很形象的写法</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">有⼀些数组或对象的⽅法经常能使⽤到， jQuery 将其保存为局部变量以提⾼访问速度</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">jquery 实现的链式调⽤可以节约代码，所返回的都是同⼀个对象，可以提⾼代码效率</p>","rank_id":441,"createdAt":"2021-06-16T12:31:01.340Z","updatedAt":"2021-06-16T12:31:01.340Z","__v":0},{"_id":"60c9ef2c7d119d797cb7b80e","title":"jQuery 与 jQuery UI 有啥区别？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">jQuery 是一个 js 库，主要提供的功能是选择器，属性修改和事件绑定等等。</li>\n<li style=\"padding: 0px; margin: 0px;\">jQuery UI 则是在 jQuery 的基础上，利用 jQuery 的扩展性，设计的插件。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等</li>\n</ul>\n</li>\n</ul>","rank_id":442,"createdAt":"2021-06-16T12:31:40.379Z","updatedAt":"2021-06-16T12:31:40.379Z","__v":0},{"_id":"60c9ef467d119d797cb7b80f","title":"jQuery 和 Zepto 的区别？各自的使用场景？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">zepto 主要用在移动设备上，只支持较新的浏览器，好处是代码量比较小，性能也较好。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">jquery 主要是兼容性好，可以跑在各种 pc，移动上，好处是兼容各种浏览器，缺点是代码量大，同时考虑兼容，性能也不够好。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">jq 自身也注意到了这个总是，所有它的 2.x 版本是不支持 ie6 7 8 的，大致就是这些。</p>","rank_id":443,"createdAt":"2021-06-16T12:32:06.613Z","updatedAt":"2021-06-16T12:32:06.613Z","__v":0},{"_id":"60c9ef8d7d119d797cb7b810","title":"Zepto 的点透问题如何解决？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"解决方案一\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">解决方案一</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">github 上有一个叫做 fastclick 的库，它也能规避移动设备上 click 事件的；将它用 script 标签引入页面（该库支持 AMD，于是你也可以按照 AMD 规范，用诸如 require.js 的模块加载器引入），并且在 dom ready 时初始化在 body 上，</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">然后给需要&ldquo;无延迟点击&rdquo;的元素绑定 click 事件（注意不再是绑定 zepto 的 tap 事件）即可。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">当然，你也可以不在 body 上初始化它，而在某个 dom 上初始化，这样，只有这个 dom 和它的子元素才能享受&ldquo;无延迟&rdquo;的点击；</span></p>\n<h2 id=\"解决方案二\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">解决方案二：</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">自己按照上述 fastclcik 的思路再开发一套东西，需要</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">一个优先于下面的&ldquo;divClickUnder&rdquo;捕获的事件</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">并且通过这个事件阻止掉默认行为（下面的&ldquo;divClickUnder&rdquo;对 click 事件的捕获，在 ios 的 safari，click 的捕获被认为和滚屏、点击输入框弹起键盘等一样，是一种浏览器默认行为，即可以被 event.preventDefault() 阻止的行为）。</span></li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">如，将 tap 事件改为 touchend（虽然意思肯定不完全一样，而且不够优雅），这样就直接在&ldquo;divTapAbove&rdquo;被捕获，而不是在 body 上才被捕获了，满足了 1；再在内部使用 preventDefault() 解决了 2，</span></p>\n<pre class=\"language-javascript\"><code>$divTapAbove.on('touchend',function(e){ \n// 改变了事件名称，tap 是在 body 上才被触发，而 touchend 是原生的事件，在 dom 本身上就会被捕获触发\n\t$divTapAbove.hide()\n\t$output.html($output.html() + 'tap&lt;br/&gt;')\n\te.preventDefault(); // 阻止&ldquo;默认行为&rdquo;\n})</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在使用 zepto 框架的 tap 相关方法时，一定要注意，如果绑定 tap 方法的 dom 元素在 tap 方法触发后会隐藏、css3 transfer 移走、requestAnimationFrame 移走等，而&ldquo;隐藏、移走&rdquo;后，它底下同一位置正好有一个 dom 元素绑定了 click 的事件、或者有浏览器认为可以被点击有交互反应的 dom 元素（举例：如 input type=text 被点击有交互反应是获得焦点并弹起虚拟键盘），则会出现&ldquo;点透&rdquo;现象。在这种情况下，我们应当采用上述两种方法来避免&ldquo;点透&rdquo;。</span></p>\n<h3 id=\"原因分析\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">原因分析：</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">问题产生的原因分析：</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">当我们在触屏上点击某个位置时候的时候，浏览器依次响应产生了几个事件，它们分别是：touchStart、touchEnd、click 事件，且 click 具有 300 毫秒的延迟时间。注意：即使你没有监听事件，事件依然存在的，浏览器默认行为。当单击 B 元素时候，事件触发先后顺序是先 touchestart-&gt;touchend-&gt;click , 问题将在这里出现。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">当发生了单击事件后，touchstart 事件先执行 B 元素被隐藏了，接下来到 touchend 事件由于速度很快，所以 A 元素并没有响应；此时 click 事件由于延迟了 300ms 才执行，B 元素已经隐藏，click 单击发生了，由于没有了 B 元素，浏览器实现上会认为当次单击是对页面上的某个部分实行的，A 元素里相应的位置的地方（元素）响应了 click 事件。于是就出现了穿透现象；</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">注：</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">给 B 元素绑定 click 事件 （点击访问 DEMO) &mdash;&mdash; 不会穿透；</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">给 B 元素绑定 touchstart 事件 （点击访问 DEMO) &mdash;&mdash;出现穿透现象</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">给 B 元素绑定 touchend 事件 （点击访问 DEMO) &mdash;&mdash;出现穿透现象</span></li>\n</ul>\n<h2 id=\"移动端-click-事件-300-毫秒延迟\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">移动端 click 事件 300 毫秒延迟：</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">用户在 iOS Safari 里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。</span></p>","rank_id":444,"createdAt":"2021-06-16T12:33:17.250Z","updatedAt":"2021-06-16T12:33:17.250Z","__v":0},{"_id":"60c9efcb7d119d797cb7b811","title":"是否知道自定义事件。jQuery 里的 fire 函数是什么意思，什么时候用？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<h2 id=\"是否知道自定义事件jquery-里的-fire-函数是什么意思什么时候用\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">是否知道自定义事件。jQuery 里的 fire 函数是什么意思，什么时候用？</span></h2>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">事件即<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&ldquo;发布 / 订阅&rdquo;</code>模式，自定义事件即&ldquo;消息发布&rdquo;，事件的监听即&ldquo;订阅订阅&rdquo;</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><span style=\"font-size: 12pt;\">JS 原生支持自定义事件，示例：</span></span>\n<pre class=\"language-javascript\"><code>document.createEvent(type); // 创建事件\nevent.initEvent(eventType, canBubble, prevent); // 初始化事件\ntarget.addEventListener('dataavailable', handler, false); // 监听事件\ntarget.dispatchEvent(e);  // 触发事件</code></pre>\n</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">jQuery 里的 fire 函数用于调用 jQuery 自定义事件列表中的事件</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">1 种是把那个函数放到抄&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">ready</code>&nbsp;函数外面。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">第 2 种是袭在 ready 函数里面加上&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">window.deleteStu = deleteStu;</code>&nbsp;即 zd:</p>\n<pre class=\"language-javascript\"><code>$(function(){\n    function deleteStu(id){\n        alert(id);\n    }\n    window.deleteStu = deleteStu;\n}</code></pre>","rank_id":445,"createdAt":"2021-06-16T12:34:19.945Z","updatedAt":"2021-06-16T12:34:19.945Z","__v":0},{"_id":"60c9f0077d119d797cb7b812","title":"针对 jQuery 性能的优化方法？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">基于 Class 的选择性的性能相对于 Id 选择器开销很大，因为需遍历所有 DOM 元素。</li>\n<li style=\"padding: 0px; margin: 0px;\">频繁操作的 DOM，先缓存起来再操作。用 jQuery 的链式调用更好。\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">比如：<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">var str=$(\"a\").attr(\"href\");</code></li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">for 循环\n<pre class=\"language-javascript\"><code>for (var i = size; i &lt; arr.length; i++) {\n}</code></pre>\n</li>\n</ul>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">for 循环每一次循环都查找了数组 (arr) 的 length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：</span></p>\n<pre class=\"language-javascript\"><code>for (var i = size, length = arr.length; i &lt; length; i++) {\n}</code></pre>","rank_id":446,"createdAt":"2021-06-16T12:35:19.542Z","updatedAt":"2021-06-16T12:35:19.542Z","__v":0},{"_id":"60c9f01e7d119d797cb7b813","title":"jQuery 是通过哪个方法和 Sizzle 选择器结合的？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ol class=\"linenums\" style=\"padding: 0px 0px 0px 10px; margin: 0px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace; font-size: 14px; color: #495666; white-space: pre;\">\n<li class=\"L0\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pln\" style=\"color: #000000;\">jQuery</span><span class=\"pun\" style=\"color: #666600;\">.</span><span class=\"pln\" style=\"color: #000000;\">fn</span><span class=\"pun\" style=\"color: #666600;\">.</span><span class=\"pln\" style=\"color: #000000;\">find</span><span class=\"pun\" style=\"color: #666600;\">()进入</span><span class=\"typ\" style=\"color: #660066;\">Sizzle</span></code></li>\n</ol>","rank_id":447,"createdAt":"2021-06-16T12:35:42.764Z","updatedAt":"2021-06-16T12:35:42.764Z","__v":0},{"_id":"60c9f05f7d119d797cb7b814","title":"在 Vue.js 中使⽤插件的步骤","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">采⽤ ES6 的 import &hellip; from &hellip; 语法或 CommonJS 的 require() ⽅法引⼊插件</li>\n<li style=\"padding: 0px; margin: 0px;\">使⽤全局⽅法 Vue.use( plugin ) 使⽤插件,可以传⼊⼀个选项对象 Vue.use(MyPlugin, { someOption: true })</li>\n</ul>","rank_id":448,"createdAt":"2021-06-16T12:36:47.478Z","updatedAt":"2021-06-16T12:36:47.478Z","__v":0},{"_id":"60c9f0cf7d119d797cb7b815","title":"Vue.js 的优点是什么？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">低耦合。视图（ View ）可以独⽴于 Model 变化和修改，⼀个 ViewModel 可以绑定到不同的 &ldquo;View&rdquo; 上，当View变化的时候Model可以不变，当 Model 变化的时候 View 也可以不变</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">可重⽤性。你可以把⼀些视图逻辑放在⼀个 ViewModel ⾥⾯，让很多 view 重⽤这段视图逻辑</p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">可测试。界⾯素来是⽐较难于测试的，⽽现在测试可以针对 ViewModel 来写</p>\n</li>\n</ul>","rank_id":449,"createdAt":"2021-06-16T12:38:39.006Z","updatedAt":"2021-06-16T12:38:39.006Z","__v":0},{"_id":"60c9f12b7d119d797cb7b816","title":"Vue.js 路由之间跳转？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">声明式（标签跳转）</span></p>\n<pre class=\"language-markup\"><code>&lt;router-link :to=\"index\"&gt;</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">编程式（ js跳转）</span></p>\n<pre class=\"language-javascript\"><code>router.push('index')</code></pre>","rank_id":450,"createdAt":"2021-06-16T12:40:11.254Z","updatedAt":"2021-06-16T12:40:11.254Z","__v":0},{"_id":"60c9f16e7d119d797cb7b817","title":"Vue.js computed 实现","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">建⽴与其他属性（如： data 、 Store ）的联系；</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">属性改变后，通知计算属性重新计算</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">实现时，主要如下</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">初始化 data ， 使⽤ Object.defineProperty 把这些属性全部转为getter/setter 。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">初始化 computed , 遍历 computed ⾥的每个属性，每个 computed 属性都是⼀个watch 实例。每个属性提供的函数作为属性的 getter ，使⽤Object.defineProperty 转化。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Object.defineProperty getter 依赖收集。⽤于依赖发⽣变化时，触发属性重新计 算。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进⾏其他的依赖收 集</p>","rank_id":451,"createdAt":"2021-06-16T12:41:18.262Z","updatedAt":"2021-06-16T12:41:18.262Z","__v":0},{"_id":"60c9f1a17d119d797cb7b818","title":"Vue.js complier 实现","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">模板解析这种事，本质是将数据转化为⼀段 html ，最开始出现在后端，经过各种处理吐 给前端。随着各种 mv* 的兴起，模板解析交由前端处理。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">总的来说， Vue complier 是将 template 转化成⼀个 render 字符串。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">可以简单理解成以下步骤：</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">parse 过程，将 template 利⽤正则转化成 AST 抽象语法树。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">generate 过程，⽣成 render 字符串</p>","rank_id":452,"createdAt":"2021-06-16T12:42:09.051Z","updatedAt":"2021-06-16T12:42:09.051Z","__v":0},{"_id":"60c9f1cc7d119d797cb7b819","title":"Vue.js 组件中 data 什么时候可以使⽤对象","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">组件复⽤时所有组件实例都会共享 data ，如果 data 是对象的话，就会造成⼀个组件 修改 data 以后会影响到其他所有组件，所以需要将 data 写成函数，每次⽤到就调⽤ ⼀次函数获得新的数据。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当我们使⽤ new Vue() 的⽅式的时候，⽆论我们将 data 设置为对象还是函数都是可 以的，因为 new Vue() 的⽅式是⽣成⼀个根组件，该组件不会复⽤，也就不存在共享 data 的情况了</p>","rank_id":453,"createdAt":"2021-06-16T12:42:52.276Z","updatedAt":"2021-06-16T12:42:52.276Z","__v":0},{"_id":"60c9f1f37d119d797cb7b81a","title":"Vue.js ajax 请求放在哪个生命周期中","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">在created的时候，视图中的<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">dom</code>并没有渲染出来，所以此时如果直接去操<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">dom</code>节点，无法找到相关的元素</li>\n<li style=\"padding: 0px; margin: 0px;\">在mounted中，由于此时<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">dom</code>已经渲染出来了，所以可以直接操作<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">dom</code>节点</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一般情况下都放到<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">mounted</code>中,保证逻辑的统一性,因为生命周期是同步执行的，<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">ajax</code>是异步执行的</p>\n<blockquote style=\"padding: 0px 0px 8px; margin: 10px 0px; color: #828201; border-width: 1px 1px 1px 5px; border-style: solid; border-color: #e2e2e2 #e2e2e2 #e2e2e2 #fff000; border-image: initial; background-color: #ffffc0; overflow: hidden; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">服务端渲染不支持mounted方法，所以在服务端渲染的情况下统一放到created中</p>\n</blockquote>","rank_id":454,"createdAt":"2021-06-16T12:43:31.758Z","updatedAt":"2021-06-16T12:43:31.758Z","__v":0},{"_id":"60c9f5b27d119d797cb7b81b","title":"Vue.js 中相同逻辑如何抽离？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Vue.mixin</code>用法 给组件每个生命周期，函数等都混入一些公共逻辑\n<pre class=\"language-javascript\"><code>Vue.mixin = function (mixin: Object) {\n    this.options = mergeOptions(this.options, mixin); // 将当前定义的属性合并到每个组件中\n    return this\n}\nexport function mergeOptions (\n  parent: Object,\n  child: Object,\n  vm?: Component\n): Object {\n  if (!child._base) {\n    if (child.extends) { // 递归合并extends\n      parent = mergeOptions(parent, child.extends, vm)\n    }\n    if (child.mixins) { // 递归合并mixin\n      for (let i = 0, l = child.mixins.length; i &lt; l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm)\n      }\n    }\n  }\n  const options = {} // 属性及生命周期的合并\n  let key\n  for (key in parent) {\n    mergeField(key)\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key)\n    }\n  }\n  function mergeField (key) {\n    const strat = strats[key] || defaultStrat\n    // 调用不同属性合并策略进行合并\n    options[key] = strat(parent[key], child[key], vm, key)\n  }\n  return options\n}</code></pre>\n</li>\n</ul>","rank_id":455,"createdAt":"2021-06-16T12:59:30.541Z","updatedAt":"2021-06-16T12:59:30.541Z","__v":0},{"_id":"60c9f5d57d119d797cb7b81c","title":"Vue.js 中常见性能优化","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<h3 id=\"1编码优化\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">1.编码优化:</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">1.不要将所有的数据都放在data中，data中的数据都会增加getter和setter，会收集对应的watcher</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">2.<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">vue</code>&nbsp;在 v-for 时给每项元素绑定事件需要用事件代理</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">3.<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">SPA</code>页面采用keep-alive缓存组件</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">4.拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染 )</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">5.<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">v-if</code>&nbsp;当值为false时内部指令不会执行,具有阻断功能，很多情况下使用v-if替代v-show</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">6.<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">key</code>保证唯一性 ( 默认<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">vue</code>会采用就地复用策略 )</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">7.<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Object.freeze</code>&nbsp;冻结数据</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">8.合理使用路由懒加载、异步组件</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">9.尽量采用runtime运行时版本</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">10.数据持久化的问题 （防抖、节流）</span></p>\n</li>\n</ul>\n<h3 id=\"2vue加载性能优化\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">2.<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Vue</code>加载性能优化:</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">第三方模块按需导入 (<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">babel-plugin-component</code>)</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">滚动到可视区域动态加载 (&nbsp;<a style=\"text-decoration-line: none; color: #900b09;\" href=\"https://tangbc.github.io/vue-virtual-scroll-list\">https://tangbc.github.io/vue-virtual-scroll-list</a>&nbsp;)</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">图片懒加载 (<a style=\"text-decoration-line: none; color: #900b09;\" href=\"https://github.com/hilongjw/vue-lazyload.git\">https://github.com/hilongjw/vue-lazyload.git</a>)</span></p>\n</li>\n</ul>\n<h3 id=\"3用户体验\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">3.用户体验:</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">app-skeleton</code>骨架屏</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">app-shell</code>app壳</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">pwa</code></span></li>\n</ul>\n<h3 id=\"4seo优化\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">4.<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">SEO</code>优化：</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">预渲染插件&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">prerender-spa-plugin</code></span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">服务端渲染<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">ssr</code></span></li>\n</ul>\n<h3 id=\"5打包优化\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">5.打包优化:</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">使用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">cdn</code>的方式加载第三方模块</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">多线程打包&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">happypack</code></span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">splitChunks</code>&nbsp;抽离公共文件</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">sourceMap</code>生成</span></li>\n</ul>\n<h3 id=\"6缓存压缩\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">6.缓存，压缩</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">客户端缓存、服务端缓存</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">服务端<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">gzip</code>压缩</span></li>\n</ul>","rank_id":456,"createdAt":"2021-06-16T13:00:05.464Z","updatedAt":"2021-06-16T13:00:05.464Z","__v":0},{"_id":"60c9f6037d119d797cb7b81d","title":"Vue3.0 你知道有哪些改进?","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul>\n<li style=\"line-height: 28px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Vue3</code>采用了TS来编写</span></li>\n<li style=\"line-height: 28px;\"><span style=\"font-size: 12pt;\">支持&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Composition API</code></span></li>\n<li style=\"line-height: 28px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">Vue3</code>中响应式数据原理改成<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">proxy</code></span></li>\n<li style=\"line-height: 28px;\"><span style=\"font-size: 12pt;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">vdom</code>的对比算法更新，只更新<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">vdom</code>的绑定了动态数据的部分</span></li>\n</ul>","rank_id":457,"createdAt":"2021-06-16T13:00:51.926Z","updatedAt":"2021-06-16T13:00:51.926Z","__v":0},{"_id":"60c9f6567d119d797cb7b81e","title":"Vue.js 的 nextTick的实现原理?","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">理解:(<strong>宏任务</strong>和<strong>微任务</strong>) 异步方法</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">nextTick</code>方法主要是使用了<strong>宏任务</strong>和<strong>微任务</strong>,定义了一个异步方法.多次调用<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">nextTick</code>&nbsp;会将方法存入队列中，通过这个异步方法清空当前队列。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">所以这个<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">nextTick</code>方法就是异步方法</p>\n<pre class=\"language-javascript\"><code>let timerFunc  // 会定义一个异步方法\nif (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) {  // promise\n  const p = Promise.resolve()\n  timerFunc = () =&gt; {\n    p.then(flushCallbacks)\n    if (isIOS) setTimeout(noop)\n  }\n  isUsingMicroTask = true\n} else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( // MutationObserver\n  isNative(MutationObserver) ||\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () =&gt; {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n  isUsingMicroTask = true\n} else if (typeof setImmediate !== 'undefined' ) { // setImmediate\n  timerFunc = () =&gt; {\n    setImmediate(flushCallbacks)\n  }\n} else {\n  timerFunc = () =&gt; {   // setTimeout\n    setTimeout(flushCallbacks, 0)\n  }\n}\n// nextTick实现\nexport function nextTick (cb?: Function, ctx?: Object) {\n  let _resolve\n  callbacks.push(() =&gt; {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    timerFunc()\n  }\n}\n</code></pre>","rank_id":458,"createdAt":"2021-06-16T13:02:14.459Z","updatedAt":"2021-06-16T13:02:14.459Z","__v":0},{"_id":"60c9f6b17d119d797cb7b81f","title":"Vue.js 中模板编译原理","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">将<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">template</code>转化成<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">render</code>函数\n<pre class=\"language-javascript\"><code>function baseCompile (\n  template: string,\n  options: CompilerOptions\n) {\n  const ast = parse(template.trim(), options) // 1.将模板转化成ast语法树\n  if (options.optimize !== false) {           // 2.优化树\n    optimize(ast, options)\n  }\n  const code = generate(ast, options)         // 3.生成树\n  return {\n    ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n})</code></pre>\n</li>\n</ul>\n<pre class=\"language-javascript\"><code>const ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; \nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\nconst startTagOpen = new RegExp(`^&lt;${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名\nconst endTag = new RegExp(`^&lt;\\\\/${qnameCapture}[^&gt;]*&gt;`); // 匹配标签结尾的  &lt;/div&gt;\nconst attribute = /^\\s*([^\\s\"'&lt;&gt;\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=&lt;&gt;`]+)))?/; \n// 匹配属性的\nconst startTagClose = /^\\s*(\\/?)&gt;/; // 匹配标签结束的  &gt;\nlet root;\nlet currentParent;\nlet stack = []\nfunction createASTElement(tagName,attrs){\n    return {\n        tag:tagName,\n        type:1,\n        children:[],\n        attrs,\n        parent:null\n    }\n}\nfunction start(tagName,attrs){\n    let element = createASTElement(tagName,attrs);\n    if(!root){\n        root = element;\n    }\n    currentParent = element;\n    stack.push(element);\n}\nfunction chars(text){\n    currentParent.children.push({\n        type:3,\n        text\n    })\n}\nfunction end(tagName){\n    const element = stack[stack.length-1];\n    stack.length --; \n    currentParent = stack[stack.length-1];\n    if(currentParent){\n        element.parent = currentParent;\n        currentParent.children.push(element)\n    }\n}\nfunction parseHTML(html){\n    while(html){\n        let textEnd = html.indexOf('&lt;');\n        if(textEnd == 0){\n            const startTagMatch = parseStartTag();\n            if(startTagMatch){\n                start(startTagMatch.tagName,startTagMatch.attrs);\n                continue;\n            }\n            const endTagMatch = html.match(endTag);\n            if(endTagMatch){\n                advance(endTagMatch[0].length);\n                end(endTagMatch[1])\n            }\n        }\n        let text;\n        if(textEnd &gt;=0 ){\n            text = html.substring(0,textEnd)\n        }\n        if(text){\n            advance(text.length);\n            chars(text);\n        }\n    }\n    function advance(n) {\n        html = html.substring(n);\n    }\n    function parseStartTag(){\n        const start = html.match(startTagOpen);\n        if(start){\n            const match = {\n                tagName:start[1],\n                attrs:[]\n            }\n            advance(start[0].length);\n            let attr,end\n            while(!(end = html.match(startTagClose)) &amp;&amp; (attr=html.match(attribute))){\n                advance(attr[0].length);\n                match.attrs.push({name:attr[1],value:attr[3]})\n            }\n            if(end){\n                advance(end[0].length);\n                return match\n            }\n        }\n    }\n}\n// 生成语法树\nparseHTML(`&lt;div id=\"container\"&gt;&lt;p&gt;hello&lt;span&gt;zf&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;`);\nfunction gen(node){\n    if(node.type == 1){\n        return generate(node);\n    }else{\n        return `_v(${JSON.stringify(node.text)})`\n    }\n}\nfunction genChildren(el){\n    const children = el.children;\n    if(el.children){\n        return `[${children.map(c=&gt;gen(c)).join(',')}]`\n    }else{\n        return false;\n    }\n}\nfunction genProps(attrs){\n    let str = '';\n    for(let i = 0; i &lt; attrs.length;i++){\n        let attr = attrs[i];\n        str+= `${attr.name}:${attr.value},`;\n    }\n    return `{attrs:{${str.slice(0,-1)}}}`\n}\nfunction generate(el){\n    let children = genChildren(el);\n    let code = `_c('${el.tag}'${\n        el.attrs.length? `,${genProps(el.attrs)}`:''\n    }${\n        children? `,${children}`:''\n    })`;\n    return code;\n}\n// 根据语法树生成新的代码\nlet code = generate(root);\nlet render = `with(this){return ${code}}`;\n// 包装成函数\nlet renderFn = new Function(render);\nconsole.log(renderFn.toString());</code></pre>","rank_id":459,"createdAt":"2021-06-16T13:03:45.952Z","updatedAt":"2021-06-16T13:03:45.952Z","__v":0},{"_id":"60c9f7427d119d797cb7b820","title":"简述 Vue.js 中 diff 算法原理","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">1.先同级比较，在比较子节点</li>\n<li style=\"padding: 0px; margin: 0px;\">2.先判断一方有儿子一方没儿子的情况</li>\n<li style=\"padding: 0px; margin: 0px;\">3.比较都有儿子的情况</li>\n<li style=\"padding: 0px; margin: 0px;\">4.递归比较子节点\n<pre class=\"language-javascript\"><code>const oldCh = oldVnode.children // 老的儿子 \nconst ch = vnode.children  // 新的儿子\nif (isUndef(vnode.text)) {\n    if (isDef(oldCh) &amp;&amp; isDef(ch)) {\n        // 比较孩子\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n    } else if (isDef(ch)) { // 新的儿子有 老的没有\n        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n    } else if (isDef(oldCh)) { // 如果老的有新的没有 就删除\n        removeVnodes(oldCh, 0, oldCh.length - 1)\n    } else if (isDef(oldVnode.text)) {  // 老的有文本 新的没文本\n        nodeOps.setTextContent(elm, '') // 将老的清空\n    }\n} else if (oldVnode.text !== vnode.text) { // 文本不相同替换\n    nodeOps.setTextContent(elm, vnode.text)\n}</code></pre>\n</li>\n</ul>\n<pre class=\"language-javascript\"><code>function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    let oldStartIdx = 0\n    let newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\n    let oldStartVnode = oldCh[0]\n    let oldEndVnode = oldCh[oldEndIdx]\n    let newEndIdx = newCh.length - 1\n    let newStartVnode = newCh[0]\n    let newEndVnode = newCh[newEndIdx]\n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n    // removeOnly is a special flag used only by &lt;transition-group&gt;\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    const canMove = !removeOnly\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh)\n    }\n    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        } else {\n          vnodeToMove = oldCh[idxInOld]\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n            oldCh[idxInOld] = undefined\n            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n          }\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n    if (oldStartIdx &gt; oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } else if (newStartIdx &gt; newEndIdx) {\n      removeVnodes(oldCh, oldStartIdx, oldEndIdx)\n    }\n  }</code></pre>","rank_id":460,"createdAt":"2021-06-16T13:06:10.673Z","updatedAt":"2021-06-16T13:06:10.673Z","__v":0},{"_id":"60cabdbf10f3487f688ade56","title":"HTTP 协议","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<h2 id=\"应用层\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">应用层</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、 有哪些字段等等。</span></p>\n<h2 id=\"概况\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">概况</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传 输层协议，保证了数据传输的可靠性。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护 一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持 同时建立 6 个持久连接。</span></p>\n<h2 id=\"http-请求报文\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP 请求报文</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP 报文有两种，一种是请求报文，一种是响应报文。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP 请求报文的格式如下：</span></p>\n<pre class=\"language-javascript\"><code>HTTP 请求报文的格式如下：\n\nGET / HTTP/1.1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)\nAccept: */*\n</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这 个空行不能省略，它用来划分首部与实体。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">方法字段可以取几种不同的值，一般有 GET、POST、HEAD、PUT 和 DELETE。一般 GET 方法只被用于向服务器获取数据。 POST 方法用于将实体提交到指定的资源，通常会造成服务器资源的修改。HEAD 方法与 GET 方法类似，但是在返回的响应 中，不包含请求对象。PUT 方法用于上传文件到服务器，DELETE 方法用于删除服务器上的对象。虽然请求的方法很多，但 更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。更多的方法可以参 看<a style=\"text-decoration-line: none; color: #900b09;\" href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods\">文档</a>。</span></p>\n<h2 id=\"http-响应报文\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP 响应报文</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP 报文有两种，一种是请求报文，一种是响应报文。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP 响应报文的格式如下：</span></p>\n<pre class=\"language-markup\"><code>HTTP/1.0 200 OK\nContent-Type: text/plain\nContent-Length: 137582\nExpires: Thu, 05 Dec 1997 16:00:00 GMT\nLast-Modified: Wed, 5 August 1996 15:55:28 GMT\nServer: Apache 0.84\n&lt;html&gt;\n  &lt;body&gt;Hello World&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">实体部分是报文的主要部分，它包含了所请求的对象。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">常见的状态有</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理 301-永久移动、302-临时移动、304-所请求的资源未修改、 400-客户端请求的语法错误、404-请求的资源不存在 500-服务器内部错误。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">更多关于状态码的可以查看：</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><a style=\"text-decoration-line: none; color: #900b09;\" href=\"http://www.runoob.com/http/http-status-codes.html\">《HTTP 状态码》</a></span></p>\n<h2 id=\"首部行\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">首部行</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设 置，区别在于请求首部和响应首部。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修 改时间。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">更多关于首部的资料可以查看：</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><a style=\"text-decoration-line: none; color: #900b09;\" href=\"https://www.cnblogs.com/jycboy/p/http_head.html\">《HTTP 首部字段详细介绍》</a></span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><a style=\"text-decoration-line: none; color: #900b09;\" href=\"https://blog.csdn.net/qq_34289537/article/details/52971516\">《图解 HTTP》</a></span></p>\n<h2 id=\"http11-协议缺点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP/1.1 协议缺点</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP/1.1 默认使用了持久连接，多个请求可以复用同一个 TCP 连接，但是在同一个 TCP 连接里面，数据请求的通信次序 是固定的。服务器只有处理完一个请求的响应后，才会进行下一个请求的处理，如果前面请求的响应特别慢的话，就会造成许 多请求排队等待的情况，这种情况被称为&ldquo;队头堵塞&rdquo;。队头阻塞会导致持久连接在达到最大数量时，剩余的资源需要等待其他 资源请求完成后才能发起请求。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">为了避免这个问题，一个是减少请求数，一个是同时打开多个持久连接。这就是我们对网站优化时，使用雪碧图、合并脚本的 原因。</span></p>","rank_id":461,"createdAt":"2021-06-17T03:13:03.307Z","updatedAt":"2021-06-17T03:13:03.307Z","__v":0},{"_id":"60cabdf310f3487f688ade57","title":"HTTP/2 协议","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。这个协议在 Chrome 浏览器上证明 可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。2015 年，HTTP/2 发布。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP/2 主要有以下新的特性：</span></p>\n<h2 id=\"二进制协议\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">二进制协议</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是 二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为\"帧\"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</span></p>\n<h2 id=\"多路复用\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">多路复用</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回 应，而且不用按照顺序一一发送，这样就避免了\"队头堵塞\"的问题。</span></p>\n<h2 id=\"数据流\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">数据流</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的 请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每 个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。</span></p>\n<h2 id=\"头信息压缩\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">头信息压缩</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是 重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面， 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引 号，这样就能提高速度了。</span></p>\n<h2 id=\"服务器推送\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">服务器推送</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源 ，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">详细的资料可以参考：&nbsp;<a style=\"text-decoration-line: none; color: #900b09;\" href=\"http://www.ruanyifeng.com/blog/2016/08/http.html\">《HTTP 协议入门》</a>&nbsp;<a style=\"text-decoration-line: none; color: #900b09;\" href=\"http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html\">《HTTP/2 服务器推送（Server Push）教程》</a></span></p>\n<h2 id=\"http2-协议缺点\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP/2 协议缺点</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">因为 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。由于多个数据流使用同一个 TCP 连接，遵 守同一个流量状态控制和拥塞控制。只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都 会被阻塞。HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题，与它本身的实现其实并没有多大关系。</span></p>\n<h2 id=\"http3-协议\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">HTTP/3 协议</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">由于 TCP 本身存在的一些限制，Google 就开发了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC 协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">详细资料可以参考：&nbsp;<a style=\"text-decoration-line: none; color: #900b09;\" href=\"https://www.zhihu.com/question/302412059\">《如何看待 HTTP/3 ？》</a></span></p>","rank_id":462,"createdAt":"2021-06-17T03:13:55.496Z","updatedAt":"2021-06-17T03:13:55.496Z","__v":0},{"_id":"60cabe5610f3487f688ade58","title":"HTTPS 协议","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<h2 id=\"http-存在的问题\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">HTTP 存在的问题</h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">HTTP 报文使用明文方式发送，可能被第三方窃听。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">HTTP 报文可能被第三方截取后修改通信内容，接收方没有办法发现报文内容的修改。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">HTTP 还存在认证的问题，第三方可以冒充他人参与通信。</p>\n</li>\n</ol>\n<h2 id=\"https-简介\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">HTTPS 简介</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/ SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立 刻发现。它还配备了身份证书，防止身份被冒充的情况出现。</p>\n<h2 id=\"tls-握手过程\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">TLS 握手过程</h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥 来加密信息。</p>\n</li>\n</ol>\n<h2 id=\"实现原理\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">实现原理</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">TLS 的握手过程主要用到了三个方法来保证传输的安全。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只 有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以 非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存 在的问题。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合 在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证 处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改 了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有 这样我们才能保证数据的安全。</p>","rank_id":463,"createdAt":"2021-06-17T03:15:34.428Z","updatedAt":"2021-06-17T03:15:34.428Z","__v":0},{"_id":"60cabe9010f3487f688ade59","title":"DNS 协议","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<h2 id=\"概况\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">概况</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分 布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号 端口。</span></p>\n<h2 id=\"域名的层级结构\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">域名的层级结构</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">域名的层级结构可以如下</span></p>\n<pre class=\"language-markup\"><code>主机名.次级域名.顶级域名.根域名\n# 即\nhost.sld.tld.root</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">根据域名的层级结构，管理不同层级域名的服务器，可以分为根域名服务器、顶级域名服务器和权威域名服务器。</span></p>\n<h2 id=\"查询过程\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">查询过程</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">DNS 的查询过程一般为，我们首先将 DNS 请求发送到本地 DNS 服务器，由本地 DNS 服务器来代为请求。</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">从\"根域名服务器\"查到\"顶级域名服务器\"的 NS 记录和 A 记录（ IP 地址）。</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">从\"顶级域名服务器\"查到\"次级域名服务器\"的 NS 记录和 A 记录（ IP 地址）。</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">从\"次级域名服务器\"查出\"主机名\"的 IP 地址。</span></li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">比如我们如果想要查询&nbsp;<a style=\"text-decoration-line: none; color: #900b09;\" href=\"http://www.baidu.com/\">www.baidu.com</a>&nbsp;的 IP 地址，我们首先会将请求发送到本地的 DNS 服务器中，本地 DNS 服务 器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名 服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服 务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</span></p>\n<h2 id=\"dns-记录和报文\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">DNS 记录和报文</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">（Name，Value，Type，TTL）</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</span></p>\n</li>\n</ol>\n<h2 id=\"递归查询和迭代查询\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">递归查询和迭代查询</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</span></p>\n<div class=\"google-auto-placed ap_container\" style=\"padding: 0px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff; width: 870px; height: auto; clear: both; text-align: center;\"><span style=\"font-size: 12pt;\"><ins class=\"adsbygoogle adsbygoogle-noablate\" style=\"display: block; margin: auto; background-color: transparent; height: 0px;\" data-ad-format=\"auto\" data-ad-client=\"ca-pub-3504340093271389\" data-adsbygoogle-status=\"done\" data-ad-status=\"unfilled\"><ins id=\"aswift_3_expand\" style=\"display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent;\" tabindex=\"0\" title=\"Advertisement\" aria-label=\"Advertisement\"><ins id=\"aswift_3_anchor\" style=\"display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent; overflow: hidden; opacity: 0;\"><iframe id=\"aswift_3\" style=\"left: 0px; position: absolute; top: 0px; border-width: 0px; border-style: initial; width: 870px; height: 0px;\" src=\"https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3504340093271389&amp;output=html&amp;h=280&amp;adk=109321987&amp;adf=3163410877&amp;pi=t.aa~a.2817947589~i.36~rp.4&amp;w=870&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1622810675&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9523024247&amp;psa=1&amp;ad_type=text_image&amp;format=870x280&amp;url=https%3A%2F%2Fwww.axihe.com%2Ffocus%2Fajax%2Fapplication%2F04.html&amp;flash=0&amp;fwr=0&amp;pra=3&amp;rh=200&amp;rw=870&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;uach=WyJXaW5kb3dzIiwiMTAuMCIsIng4NiIsIiIsIjkxLjAuNDQ3Mi4xMDYiLFtdXQ..&amp;dt=1623899742018&amp;bpp=1&amp;bdt=345&amp;idt=1&amp;shv=r20210615&amp;cbv=%2Fr20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3Dc42b20e6ee6efa3d-221193c456c90083%3AT%3D1623293344%3ART%3D1623293344%3AS%3DALNI_MbzQJ6BWGNxs0oRE7-tp-4q8E74oA&amp;prev_fmts=0x0%2C890x280&amp;nras=2&amp;correlator=2560220716797&amp;frm=20&amp;pv=1&amp;ga_vid=1258582464.1623899742&amp;ga_sid=1623899742&amp;ga_hid=464608695&amp;ga_fc=0&amp;u_tz=480&amp;u_his=4&amp;u_java=0&amp;u_h=864&amp;u_w=1536&amp;u_ah=824&amp;u_aw=1536&amp;u_cd=24&amp;u_nplug=3&amp;u_nmime=4&amp;adx=325&amp;ady=1982&amp;biw=1519&amp;bih=722&amp;scr_x=0&amp;scr_y=0&amp;eid=31060974%2C31061335&amp;oid=3&amp;pvsid=3089140789275478&amp;pem=199&amp;ref=https%3A%2F%2Fwww.axihe.com%2Fmap%2Fajax-focus.html&amp;eae=0&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1536%2C0%2C1536%2C824%2C1536%2C722&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;ifi=4&amp;uci=a!4&amp;btvi=1&amp;fsb=1&amp;xpc=71lcIV6f1O&amp;p=https%3A//www.axihe.com&amp;dtd=14\" name=\"aswift_3\" width=\"870\" height=\"0\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" sandbox=\"allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation\" allowfullscreen=\"allowfullscreen\" data-google-container-id=\"a!4\" data-load-complete=\"true\" data-google-query-id=\"CNKfnvrZnfECFYG5vAodS4AOpg\"></iframe></ins></ins></ins></span></div>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</span></p>\n<h2 id=\"dns-缓存\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">DNS 缓存</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本 地存储器中。返回的资源记录中的 TTL 代表了该条记录的缓存的时间。</span></p>\n<h2 id=\"dns-实现负载平衡\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">DNS 实现负载平衡</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应 多个服务器地址。当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在 每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不 同的服务器上，这样来实现负载均衡。</span></p>","rank_id":464,"createdAt":"2021-06-17T03:16:32.433Z","updatedAt":"2021-06-17T03:16:32.433Z","__v":0},{"_id":"60cabecf10f3487f688ade5a","title":"HTTP request报⽂结构是怎样的","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">⾸⾏是Request-Line包括：请求⽅法，请求URI，协议版本，CRLF</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">⾸⾏之后是若⼲⾏请求头，包括general-header，request-header或者entity-header， 每个⼀⾏以CRLF结束</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">请求头和消息实体之间有⼀个CRLF分隔</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">根据实际请求需要可能包含⼀个消息实体 ⼀个请求报⽂例⼦如下：\n<pre class=\"language-javascript\"><code>GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1\nHost: www.w3.org\nConnection: keep-alive\nCache-Control: max-age=0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/\nUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML,\nReferer: https://www.google.com.hk/\nAccept-Encoding: gzip,deflate,sdch\nAccept-Language: zh-CN,zh;q=0.8,en;q=0.6\nCookie: authorstyle=yes\nIf-None-Match: \"2cc8-3e3073913b100\"\nIf-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT\nname=qiu&amp;age=25</code></pre>\n</li>\n</ol>","rank_id":465,"createdAt":"2021-06-17T03:17:35.370Z","updatedAt":"2021-06-17T03:17:35.370Z","__v":0},{"_id":"60cabef210f3487f688ade5b","title":"HTTP response报⽂结构是怎样的","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">⾸⾏是状态⾏包括：HTTP版本，状态码，状态描述，后⾯跟⼀个CRLF ⾸⾏之后是若⼲⾏响应头，包括：通⽤头部，响应头部，实体头部 响应头部和响应实体之间⽤⼀个CRLF空⾏分隔 最后是⼀个可能的消息实体 响应报⽂例⼦如下：</span></p>\n<pre class=\"language-javascript\"><code>HTTP/1.1 200 OK\nDate: Tue, 08 Jul 2014 05:28:43 GMT\nServer: Apache/2\nLast-Modified: Wed, 01 Sep 2004 13:24:52 GMT\nETag: \"40d7-3e3073913b100\"\nAccept-Ranges: bytes\nContent-Length: 16599\nCache-Control: max-age=21600\nExpires: Tue, 08 Jul 2014 11:28:43 GMT\nP3P: policyref=\"http://www.w3.org/2001/05/P3P/p3p.xml\"\nContent-Type: text/html; charset=iso-8859-1\n{\"name\": \"qiu\", \"age\": 25}</code></pre>","rank_id":466,"createdAt":"2021-06-17T03:18:10.022Z","updatedAt":"2021-06-17T03:18:10.022Z","__v":0},{"_id":"60cabf2310f3487f688ade5c","title":"谈一下 WebSocket","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">由于 http 存在⼀个明显的弊端（消息只能有客户端推送到服务器端，⽽服 务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只 能使⽤轮询，⽽轮询效率过低，并不适合。于是 WebSocket 被发明出来</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">相⽐与 http 具有以下有点</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">⽀持双向通信，实时性更强；</li>\n<li style=\"padding: 0px; margin: 0px;\">可以发送⽂本，也可以⼆进制⽂件；</li>\n<li style=\"padding: 0px; margin: 0px;\">协议标识符是 ws ，加密后是 wss ；</li>\n<li style=\"padding: 0px; margin: 0px;\">较少的控制开销。连接创建后， ws 客户端、服务端进⾏数据交换时，协议控制的数据包头部较⼩。在不包含头部的情况下，服务端到客户端的包头只有 2~10 字节（取决于数据包⻓度），客户端到服务端的的话，需要加上额外的4字节的掩码。⽽ HTTP 协议每次通信都需要携带完整的头部；</li>\n<li style=\"padding: 0px; margin: 0px;\">⽀持扩展。ws协议定义了扩展，⽤户可以扩展协议，或者实现⾃定义的⼦协议。（⽐如⽀</li>\n<li style=\"padding: 0px; margin: 0px;\">持⾃定义压缩算法等）</li>\n<li style=\"padding: 0px; margin: 0px;\">⽆跨域问题。</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">实现⽐较简单，服务端库如 socket.io 、 ws ，可以很好的帮助我们⼊⻔。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">⽽客户端也只需要参照 api 实现即可</p>","rank_id":467,"createdAt":"2021-06-17T03:18:59.266Z","updatedAt":"2021-06-17T03:18:59.266Z","__v":0},{"_id":"60cabf8b10f3487f688ade5d","title":"ajax、axios、fetch区别","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">jQuery ajax</h3>\n<pre class=\"language-javascript\"><code>$.ajax({\n    type: 'POST',\n    url: url,\n    data: data,\n    dataType: dataType,\n    success: function () {},\n    error: function () {}\n});</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">优缺点：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">本身是针对 MVC 的编程,不符合现在前端 MVVM 的浪潮</li>\n<li style=\"padding: 0px; margin: 0px;\">基于原⽣的 XHR 开发， XHR 本身的架构不清晰，已经有了 fetch 的替代⽅案</li>\n<li style=\"padding: 0px; margin: 0px;\">JQuery 整个项⽬太⼤，单纯使⽤ ajax 却要引⼊整个 JQuery ⾮常的不合理（采取个性化打包的⽅案⼜不能享受CDN服务</li>\n</ul>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">axios</h3>\n<pre class=\"language-javascript\"><code>axios({\n    method: 'post',\n    url: '/user/12345',\n    data: {\n        firstName: 'Fred',\n        lastName: 'Flintstone'\n    }\n})\n.then(function (response) {\n    console.log(response);\n})\n.catch(function (error) {\n    console.log(error);\n});</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">优缺点：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">从浏览器中创建 XMLHttpRequest</li>\n<li style=\"padding: 0px; margin: 0px;\">从 node.js 发出 http 请求</li>\n<li style=\"padding: 0px; margin: 0px;\">⽀持 Promise API</li>\n<li style=\"padding: 0px; margin: 0px;\">拦截请求和响应</li>\n<li style=\"padding: 0px; margin: 0px;\">转换请求和响应数据</li>\n<li style=\"padding: 0px; margin: 0px;\">取消请求</li>\n<li style=\"padding: 0px; margin: 0px;\">⾃动转换 JSON 数据</li>\n<li style=\"padding: 0px; margin: 0px;\">客户端⽀持防⽌ CSRF/XSRF</li>\n</ul>\n<h3 style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">fetch</h3>\n<pre class=\"language-javascript\"><code>try {\n    let response = await fetch(url);\n    let data = response.json();\n    console.log(data);\n} catch(e) {\n    console.log(\"Oops, error\", e);\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">优缺点：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">fetcht 只对⽹络请求报错，对 400 ， 500 都当做成功的请求，需要封装去处理</li>\n<li style=\"padding: 0px; margin: 0px;\">fetch 默认不会带 cookie ，需要添加配置项</li>\n<li style=\"padding: 0px; margin: 0px;\">fetch 不⽀持 abort ，不⽀持超时控制，使⽤ setTimeout 及 Promise.reject 的实现的超时控制并不能阻⽌请求过程继续在后台运⾏，造成了量的浪费</li>\n<li style=\"padding: 0px; margin: 0px;\">fetch 没有办法原⽣监测请求的进度，⽽XHR可以</li>\n</ul>\n<h3 id=\"fetch\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>\n<h3 id=\"axios\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>\n<h3 id=\"jquery-ajax\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"></h3>","rank_id":468,"createdAt":"2021-06-17T03:20:43.998Z","updatedAt":"2021-06-17T03:20:43.998Z","__v":0},{"_id":"60cac08410f3487f688ade5e","title":"多路复用与多路分解","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只工作在端系统中。</span></p>\n<h2 id=\"多路复用与多路分解\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">多路复用与多路分解</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">将传输层报文段中的数据交付到正确的套接字的工作被称为多路分解。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在源主机上从不同的套接字中收集数据，封装头信息生成报文段后，将报文段传递到网络层，这个过程被称为多路复用。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">无连接的多路复用和多路分解指的是 UDP 套接字的分配过程，一个 UDP 套接字由一个二元组来标识，这个二元组包含了一 个目的地址和一个目的端口号。因此不同源地址和端口号的 UDP 报文段到达主机后，如果它们拥有相同的目的地址和目的端 口号，那么不同的报文段将会转交到同一个 UDP 套接字中。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">面向连接的多路复用和多路分解指的是 TCP 套接字的分配过程，一个 TCP 套接字由一个四元组来标识，这个四元组包含了 源 IP 地址、源端口号、目的地址和目的端口号。因此，一个 TCP 报文段从网络中到达一台主机上时，该主机使用全部 4 个 值来将报文段定向到相应的套接字。</span></p>","rank_id":469,"createdAt":"2021-06-17T03:24:52.208Z","updatedAt":"2021-06-17T03:24:52.208Z","__v":0},{"_id":"60cac10a10f3487f688ade5f","title":"UDP 协议","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<h2 id=\"udp-协议\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">UDP 协议</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">UDP 是一种无连接的，不可靠的传输层协议。它只提供了传输层需要实现的最低限度的功能，除了复用/分解功能和少量的差 错检测外，它几乎没有对 IP 增加其他的东西。UDP 协议适用于对实时性要求高的应用场景。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">特点：</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">使用 UDP 时，在发送报文段之前，通信双方没有握手的过程，因此 UDP 被称为是无连接的传输层协议。因为没有握手 过程，相对于 TCP 来说，没有建立连接的时延。因为没有连接，所以不需要在端系统中保存连接的状态。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互 通信。</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">UDP 首部小，只有 8 个字节。</span></p>\n</li>\n</ol>\n<h3 id=\"udp-报文段结构\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">UDP 报文段结构</span></h3>\n<p style=\"padding-top: 0px; padding-right: 0px; padding-bottom: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口号、目的端口号、长度和检验和，每个字段的长 度为两个字节。长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。校验和是 UDP 提供的一种差错校验机制。 虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。</span></p>\n<p style=\"padding: 0px 0px 0px 440px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><img src=\"https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-16.png\" alt=\"\" width=\"220\" height=\"192\" /></span></p>","rank_id":470,"createdAt":"2021-06-17T03:27:06.763Z","updatedAt":"2021-06-17T03:27:06.763Z","__v":0},{"_id":"60cac14210f3487f688ade60","title":"网络层","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">网络层协议主要实现了不同主机间的逻辑通信功能。网络层协议一共包含两个主要的组件，一个 IP 网际协议，一个是路由选 择协议。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">IP 网际协议规定了网络层的编址和转发方式，比如说我们接入网络的主机都会被分配一个 IP 地址，常用的比如 IPV4 使用 32 位来分配地址，还有 IPv6 使用 128 位来分配地址。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">路由选择协议决定了数据报从源到目的地所流经的路径，常见的比如距离向量路由选择算法等。</p>","rank_id":471,"createdAt":"2021-06-17T03:28:02.919Z","updatedAt":"2021-06-17T03:28:02.919Z","__v":0},{"_id":"60cac16210f3487f688ade61","title":"数据链路层","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<h2 id=\"数据链路层\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">数据链路层</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">数据链路层提供的服务是如何将数据报通过单一通信链路从一个结点移动到相邻节点。每一台主机都有一个唯一的 MAC 地址， 这是由网络适配器决定的，在全世界都是独一无二的。</span></p>","rank_id":472,"createdAt":"2021-06-17T03:28:34.433Z","updatedAt":"2021-06-17T03:28:34.433Z","__v":0},{"_id":"60cac18310f3487f688ade62","title":"物理层","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<h2 id=\"物理层\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">物理层</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">物理层提供的服务是尽可能的屏蔽掉组成网络的物理设备和传输介质间的差异，使数据链路层不需要考虑网络的具体传输介质 是什么。</span></p>","rank_id":473,"createdAt":"2021-06-17T03:29:07.951Z","updatedAt":"2021-06-17T03:29:07.951Z","__v":0},{"_id":"60cac1aa10f3487f688ade63","title":"TLS/SSL 中什么一定要用三个随机数，来生成\"会话密钥\"？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">客户端和服务器都需要生成随机数，以此来保证每次生成的秘钥都不相同。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">使用三个随机数，是因为 SSL 的协议默认不信任每个主机都能产生完全随机的数，如果只使用一个伪随机的数来生成秘钥，就很容易被破解。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">通过使用三个随机数的方式，增加了自由度，一个伪随机可能被破解，但是三个伪随机就很接近于随机了，因此可以使用这种方法来保持生成秘钥的随机性和安全性。</p>","rank_id":474,"createdAt":"2021-06-17T03:29:46.224Z","updatedAt":"2021-06-17T03:29:46.224Z","__v":0},{"_id":"60cac1c210f3487f688ade64","title":"SSL 连接断开后如何恢复？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">目前所有的浏览器都支持这一种方法。</li>\n<li style=\"padding: 0px; margin: 0px;\">但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。</li>\n</ul>\n</li>\n</ul>","rank_id":475,"createdAt":"2021-06-17T03:30:10.743Z","updatedAt":"2021-06-17T03:30:10.743Z","__v":0},{"_id":"60cac1e010f3487f688ade65","title":"RSA 算法的安全性保障？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对极大整数做因数分解的难度决定了 RSA 算法的可靠性。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">现在1024位的 RSA 密钥基本安全，2048位的密钥极其安全。</p>","rank_id":476,"createdAt":"2021-06-17T03:30:40.981Z","updatedAt":"2021-06-17T03:30:40.981Z","__v":0},{"_id":"60cac20210f3487f688ade66","title":"DNS 为什么使用 UDP 协议作为传输层协议？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢，因为大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">使用 UDP 协议作为 DNS 协议会有一个问题，由于历史原因，物理链路的最小MTU = 576，所以为了限制报文长度不超过576，UDP 的报文段的长度被限制在 512 个字节以内，这样一旦 DNS 的查询或者应答报文，超过了 512 字节，那么基于 UDP 的DNS 协议就会被截断为 512 字节，那么有可能用户得到的 DNS 应答就是不完整的。这里 DNS 报文的长度一旦超过限制，并不会像 TCP 协议那样被拆分成多个报文段传输，因为 UDP 协议不会维护连接状态，所以我们没有办法确定那几个报文段属于同一个数据，UDP 只会将多余的数据给截取掉。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">为了解决这个问题，我们可以使用 TCP 协议去请求报文。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">DNS 还存在的一个问题是安全问题，就是我们没有办法确定我们得到的应答，一定是一个安全的应答，因为应答可以被他人伪造，所以现在有了 DNS over HTTPS 来解决这个问题。</p>","rank_id":477,"createdAt":"2021-06-17T03:31:14.388Z","updatedAt":"2021-06-17T03:31:14.388Z","__v":0},{"_id":"60cac23310f3487f688ade67","title":"当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法， 将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字 符，则对非法字符进行转义后再进行下一过程。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新 的请求。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果 有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域 名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地 址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用 户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源 端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给 数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地 址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果 在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该 转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应 该为网关的地址。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接 收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的 确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立 状态，此时双方的连接就建立起来了。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版 本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证 书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后 发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解 密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加 密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行 解析，开始页面的渲染过程。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端 是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建 立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页 面进行绘制。这个时候整个页面就显示出来了。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（9）最后一步是 TCP 断开连接的四次挥手过程。</p>","rank_id":478,"createdAt":"2021-06-17T03:32:03.752Z","updatedAt":"2021-06-17T03:32:03.752Z","__v":0},{"_id":"60cac24e10f3487f688ade68","title":"谈谈 CDN 服务？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资就近访问的 功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CND 服务器将请求定位到最近的含有该资源 的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。</p>","rank_id":479,"createdAt":"2021-06-17T03:32:30.210Z","updatedAt":"2021-06-17T03:32:30.210Z","__v":0},{"_id":"60cac27e10f3487f688ade69","title":"什么是正向代理和反向代理？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的 服务都被代理服务器代替来请求。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">反向代理隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，我们不知 道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。反向 代理器一般用来实现负载平衡。</p>","rank_id":480,"createdAt":"2021-06-17T03:33:18.040Z","updatedAt":"2021-06-17T03:33:18.040Z","__v":0},{"_id":"60cac29410f3487f688ade6a","title":"负载平衡的两种实现方式？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实 现集群的负载平衡。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一 个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在 每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服 务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解 析仍然返回的是那个 IP 地址，就会造成访问的问题。</p>","rank_id":481,"createdAt":"2021-06-17T03:33:40.694Z","updatedAt":"2021-06-17T03:33:40.694Z","__v":0},{"_id":"60cac2b010f3487f688ade6b","title":"http 请求方法 options 方法有什么用？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。这个方法会请求服务器返回该资源所支持的所有 HTTP 请 求方法，该方法会用'*&lsquo;来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JS 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</span></p>","rank_id":482,"createdAt":"2021-06-17T03:34:08.727Z","updatedAt":"2021-06-17T03:34:08.727Z","__v":0},{"_id":"60cac2cb10f3487f688ade6c","title":"http1.1 和 http1.0 之间有哪些区别？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">http1.1 相对于 http1.0 有这样几个区别：</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（1）连接方面的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（2）资源请求方面的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（3）缓存方面的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（4）http1.1 中还新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">（5）http1.1 相对于 http1.0 还新增了很多方法，如 PUT、HEAD、OPTIONS 等。</p>","rank_id":483,"createdAt":"2021-06-17T03:34:35.805Z","updatedAt":"2021-06-17T03:34:35.805Z","__v":0},{"_id":"60cac2f810f3487f688ade6d","title":"即时通讯的实现，短轮询、长轮询、SSE 和 WebSocket 间的区别？","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">短轮询的基本思路就是浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行 响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客 户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 ht tp 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">长轮询的基本思路是，首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将 这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。 客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的 优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">SSE 的基本思想是，服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通 方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断 地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机 制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，不 需要建立过多的 http 请求，相比之下节约了资源。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">上面三种方式本质上都是基于 http 协议的，我们还可以使用 WebSocket 协议来实现。WebSocket 是 Html5 定义的一个新协 议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置 比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能 由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</p>","rank_id":484,"createdAt":"2021-06-17T03:35:20.429Z","updatedAt":"2021-06-17T03:35:20.429Z","__v":0},{"_id":"60cac33f10f3487f688ade6e","title":"怎么实现多个网站之间共享登录状态","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在多个网站之间共享登录状态指的就是单点登录。多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我认为单点登录可以这样来实现，首先将用户信息的验证中心独立出来，作为一个单独的认证中心，该认证中心的作用是判断客户端发 送的账号密码的正确性，然后向客户端返回对应的用户信息，并且返回一个由服务器端秘钥加密的登录信息的 token 给客户端，该 token 具有一定的有效时限。当一个应用系统跳转到另一个应用系统时，通过 url 参数的方式来传递 token，然后转移到的应用站 点发送给认证中心，认证中心对 token 进行解密后验证，如果用户信息没有失效，则向客户端返回对应的用户信息，如果失效了则将 页面重定向会单点登录页面。</p>","rank_id":485,"createdAt":"2021-06-17T03:36:31.648Z","updatedAt":"2021-06-17T03:36:31.648Z","__v":0},{"_id":"60cac36e10f3487f688ade6f","title":"babel原理","code":"","type":"webpack/gulp","frequency":"low","difficulty":"easy","answers":"<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">ES6、7 代码输⼊ -&gt;</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">babylon 进⾏解析 -&gt;</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">得到 AST （抽象语法树）-&gt;</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">plugin ⽤b abel-traverse 对 AST 树进⾏遍历转译 -&gt;</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">得到新的 AST 树-&gt;</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">⽤ babel-generator 通过 AST 树⽣成 ES5 代码</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">本质就是编译器，当代码转为字符串⽣成 AST ，对 AST 进⾏转变最后再⽣成新的代码</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">分为三步：词法分析⽣成 Token ，语法分析⽣成 AST ，遍历 AST ，根据插件变换相应的节点，最后把 AST 转换为代码</p>","rank_id":486,"createdAt":"2021-06-17T03:37:18.836Z","updatedAt":"2021-06-17T03:37:18.837Z","__v":0},{"_id":"60cac39510f3487f688ade70","title":"gulp是什么","code":"","type":"webpack/gulp","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">gulp 是前端开发过程中⼀种基于流的代码构建⼯具，是⾃动化项⽬的构建利器；它不仅 能对⽹站资源进⾏优化，⽽且在开发过程中很多重复的任务能够使⽤正确的⼯具⾃动完成</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">Gulp的核⼼概念：流</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">流，简单来说就是建⽴在⾯向对象基础上的⼀种抽象的处理数据的⼯具。在流中，定义了 ⼀些处理数据的基本操作，如读取数据，写⼊数据等，程序员是对流进⾏所有操作的，⽽ 不⽤关⼼流的另⼀头数据的真正流向</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">gulp正是通过流和代码优于配置的策略来尽量简化任务编写的⼯作</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><strong>Gulp的特点</strong>：</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">易于使⽤：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">构建快速 利⽤ Node.js 流的威⼒，你可以快速构建项⽬并减少频繁的 IO 操作</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">易于学习 通过最少的 API ，掌握 gulp 毫不费⼒，构建⼯作尽在掌握：如同⼀系列流管道</span></li>\n</ul>","rank_id":487,"createdAt":"2021-06-17T03:37:57.825Z","updatedAt":"2021-06-17T03:37:57.825Z","__v":0},{"_id":"60cac3b610f3487f688ade71","title":"Node.js的应⽤场景","code":"","type":"nodejs","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">特点：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">1、它是⼀个 Javascript 运⾏环境</li>\n<li style=\"padding: 0px; margin: 0px;\">2、依赖于 Chrome V8 引擎进⾏代码解释</li>\n<li style=\"padding: 0px; margin: 0px;\">3、事件驱动</li>\n<li style=\"padding: 0px; margin: 0px;\">4、⾮阻塞 I/O</li>\n<li style=\"padding: 0px; margin: 0px;\">5、单进程，单线程</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">优点：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">⾼并发（最重要的优点）</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">缺点：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">1、只⽀持单核 CPU ，不能充分利⽤ CPU</li>\n<li style=\"padding: 0px; margin: 0px;\">2、可靠性低，⼀旦代码某个环节崩溃，整个系统都崩溃</li>\n</ul>\n</li>\n</ul>","rank_id":488,"createdAt":"2021-06-17T03:38:30.317Z","updatedAt":"2021-06-17T03:38:30.317Z","__v":0},{"_id":"60cac42310f3487f688ade72","title":"对前端⼯程师这个职位是怎么样理解的？它的前景会怎么样","code":"","type":"human resource","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">前端是最贴近⽤户的程序员，⽐后端、数据库、产品经理、运营、安全都近\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">实现界⾯交互</li>\n<li style=\"padding: 0px; margin: 0px;\">提升⽤户体验</li>\n<li style=\"padding: 0px; margin: 0px;\">基于NodeJS，可跨平台开发</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">前端是最贴近⽤户的程序员，前端的能⼒就是能让产品从 90分进化到 100 分，甚⾄更好，</li>\n<li style=\"padding: 0px; margin: 0px;\">与团队成员， UI 设计，产品经理的沟通；</li>\n<li style=\"padding: 0px; margin: 0px;\">做好的⻚⾯结构，⻚⾯重构和⽤户体验；</li>\n</ul>","rank_id":489,"createdAt":"2021-06-17T03:40:19.798Z","updatedAt":"2021-06-17T03:40:19.798Z","__v":0},{"_id":"60cac43b10f3487f688ade73","title":"你觉得前端⼯程的价值体现在哪","code":"","type":"human resource","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">简化⽤户使⽤提供技术⽀持（交互部分）</li>\n<li style=\"padding: 0px; margin: 0px;\">为多个浏览器兼容性提供⽀持</li>\n<li style=\"padding: 0px; margin: 0px;\">为提⾼⽤户浏览速度（浏览器性能）提供⽀持</li>\n<li style=\"padding: 0px; margin: 0px;\">为跨平台或者其他基于webkit或其他渲染引擎的应⽤提供⽀持</li>\n<li style=\"padding: 0px; margin: 0px;\">为展示数据提供⽀持（数据接⼝）</li>\n</ul>","rank_id":490,"createdAt":"2021-06-17T03:40:43.775Z","updatedAt":"2021-06-17T03:40:43.775Z","__v":0},{"_id":"60cac47a10f3487f688ade74","title":"平时如何管理你的项⽬","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">先期团队必须确定好全局样式（ globe.css ），编码模式( utf-8 ) 等；</li>\n<li style=\"padding: 0px; margin: 0px;\">编写习惯必须⼀致（例如都是采⽤继承式的写法，单样式都写成⼀⾏）；</li>\n<li style=\"padding: 0px; margin: 0px;\">标注样式编写⼈，各模块都及时标注（标注关键样式调⽤的地⽅）；</li>\n<li style=\"padding: 0px; margin: 0px;\">⻚⾯进⾏标注（例如 ⻚⾯ 模块 开始和结束）</li>\n<li style=\"padding: 0px; margin: 0px;\">CSS 跟 HTML 分⽂件夹并⾏存放，命名都得统⼀（例如 style.css ）；</li>\n<li style=\"padding: 0px; margin: 0px;\">JS 分⽂件夹存放 命名以该 JS 功能为准的英⽂翻译。</li>\n<li style=\"padding: 0px; margin: 0px;\">图⽚采⽤整合的 images.png png8 格式⽂件使⽤ - 尽量整合在⼀起使⽤⽅便将来的管理</li>\n</ul>","rank_id":491,"createdAt":"2021-06-17T03:41:46.765Z","updatedAt":"2021-06-17T03:41:46.765Z","__v":0},{"_id":"60cac49610f3487f688ade75","title":"谈一谈组件封装","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">分析布局</li>\n<li style=\"padding: 0px; margin: 0px;\">初步开发</li>\n<li style=\"padding: 0px; margin: 0px;\">化繁为简</li>\n<li style=\"padding: 0px; margin: 0px;\">组件抽象</li>\n</ul>","rank_id":492,"createdAt":"2021-06-17T03:42:14.973Z","updatedAt":"2021-06-17T03:42:14.973Z","__v":0},{"_id":"60cac82610f3487f688ade76","title":"简单聊下 vue、react、angular","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Vue.js ⼀个⽤于创建 web 交互界⾯的库，是⼀个精简的 MVVM 。它通过双向数据绑 定把 View 层和 Model 层连接了起来。实际的 DOM 封装和输出格式都被抽象为了 Directives 和 Filters</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">AngularJS 是⼀个⽐较完善的前端 MVVM 框架，包含模板，数据双向绑定，路由，模块 化，服务，依赖注⼊等所有功能，模板功能强⼤丰富，⾃带了丰富的 Angular 指令</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">react React 仅仅是 VIEW 层是 facebook 公司。推出的⼀个⽤于构建 UI 的⼀个 库，能够实现服务器端的渲染。⽤了 virtual dom ，所以性能很好。</p>","rank_id":493,"createdAt":"2021-06-17T03:57:26.620Z","updatedAt":"2021-06-17T03:57:26.620Z","__v":0},{"_id":"60cac85a10f3487f688ade77","title":"在css/js代码上线之后开发⼈员经常会优化性能，从⽤户刷新⽹⻚开始，⼀次js请求⼀般情况下有哪些地⽅会有缓存处理？","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">dns 缓存，</li>\n<li style=\"padding: 0px; margin: 0px;\">cdn 缓存，</li>\n<li style=\"padding: 0px; margin: 0px;\">浏览器缓存，</li>\n<li style=\"padding: 0px; margin: 0px;\">服务器缓存</li>\n</ul>","rank_id":494,"createdAt":"2021-06-17T03:58:18.565Z","updatedAt":"2021-06-17T03:58:18.565Z","__v":0},{"_id":"60cac87d10f3487f688ade78","title":"谈⼀谈let与var的区别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">let 命令不存在变量提升，如果在 let 前使⽤，会导致报错</li>\n<li style=\"padding: 0px; margin: 0px;\">如果块区中存在 let 和 const 命令，就会形成封闭作⽤域</li>\n<li style=\"padding: 0px; margin: 0px;\">不允许重复声明，因此，不能在函数内部重新声明参数</li>\n</ul>","rank_id":495,"createdAt":"2021-06-17T03:58:53.124Z","updatedAt":"2021-06-17T03:58:53.124Z","__v":0},{"_id":"60cac89f10f3487f688ade79","title":"map与forEach的区别","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">forEach ⽅法，是最基本的⽅法，就是遍历与循环，默认有3个传参：分别是遍历的数组 内容 item 、数组索引 index 、和当前遍历数组 Array</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">map ⽅法，基本⽤法与 forEach ⼀致，但是不同的，它会返回⼀个新的数组，所以在 callback需要有 return 值，如果没有，会返回 undefined</p>","rank_id":496,"createdAt":"2021-06-17T03:59:27.315Z","updatedAt":"2021-06-17T03:59:27.315Z","__v":0},{"_id":"60cac8b410f3487f688ade7a","title":"谈⼀谈你理解的函数式编程","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">简单说，&ldquo;函数式编程\"是⼀种\"编程范式&rdquo;（programming paradigm），也就是如何编写程 序的⽅法论</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">它具有以下特性：闭包和⾼阶函数、惰性计算、递归、函数是\"第⼀等公⺠\"、只⽤\"表达式\"</p>","rank_id":497,"createdAt":"2021-06-17T03:59:48.620Z","updatedAt":"2021-06-17T03:59:48.620Z","__v":0},{"_id":"60cac8d510f3487f688ade7b","title":"谈⼀谈箭头函数与普通函数的区别？","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">函数体内的 this 对象，就是定义时所在的对象，⽽不是使⽤时所在的对象</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不可以当作构造函数，也就是说，不可以使⽤ new 命令，否则会抛出⼀个错误</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不可以使⽤ arguments 对象，该对象在函数体内不存在。如果要⽤，可以⽤ Rest 参数 代替</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">不可以使⽤ yield 命令，因此箭头函数不能⽤作 Generator 函数</p>","rank_id":498,"createdAt":"2021-06-17T04:00:21.750Z","updatedAt":"2021-06-17T04:00:21.750Z","__v":0},{"_id":"60cac90510f3487f688ade7c","title":"异步编程的实现⽅式","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">回调函数\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">优点：简单、容易理解</li>\n<li style=\"padding: 0px; margin: 0px;\">缺点：不利于维护，代码耦合⾼</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">事件监听(采⽤时间驱动模式，取决于某个事件是否发⽣)：\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li>\n<li style=\"padding: 0px; margin: 0px;\">缺点：事件驱动型，流程不够清晰</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">发布/订阅(观察者模式)\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">类似于事件监听，但是可以通过&lsquo;消息中⼼ʼ，了解现在有多少发布者，多少订阅者</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">Promise对象\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">优点：可以利⽤then⽅法，进⾏链式写法；可以书写错误时的回调函数；</li>\n<li style=\"padding: 0px; margin: 0px;\">缺点：编写和理解，相对⽐较难</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">Generator函数\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">优点：函数体内外的数据交换、错误处理机制</li>\n<li style=\"padding: 0px; margin: 0px;\">缺点：流程管理不⽅便</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">async函数\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">优点：内置执⾏器、更好的语义、更⼴的适⽤性、返回的是Promise、结构清晰。</li>\n<li style=\"padding: 0px; margin: 0px;\">缺点：错误处理机制</li>\n</ul>\n</li>\n</ul>","rank_id":499,"createdAt":"2021-06-17T04:01:09.541Z","updatedAt":"2021-06-17T04:01:09.541Z","__v":0},{"_id":"60cac91d10f3487f688ade7d","title":"对原⽣Javascript了解程度","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">数据类型、运算、对象、Function、继承、闭包、作⽤域、原型链、事件、 RegExp 、 JSON 、 Ajax 、 DOM 、 BOM 、内存泄漏、跨域、异步装载、模板引擎、前端 MVC 、 路由、模块化、 Canvas 、 ECMAScript</span></p>","rank_id":500,"createdAt":"2021-06-17T04:01:33.045Z","updatedAt":"2021-06-17T04:01:33.045Z","__v":0},{"_id":"60cac93e10f3487f688ade7e","title":"Js动画与CSS动画区别及相应实现","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">CSS3 的动画的优点</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">在性能上会稍微好⼀些，浏览器会对 CSS3 的动画做⼀些优化</li>\n<li style=\"padding: 0px; margin: 0px;\">代码相对简单</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">缺点</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">在动画控制上不够灵活</li>\n<li style=\"padding: 0px; margin: 0px;\">兼容性不好</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">JavaScript 的动画正好弥补了这两个缺点，控制能⼒很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6 ，并且功能强⼤。对于⼀些复杂控制的动画，使⽤javascript 会⽐较靠谱。⽽在实现⼀些⼩的交互动效的时候，就多考虑考虑 CSS 吧</p>\n</li>\n</ul>","rank_id":501,"createdAt":"2021-06-17T04:02:06.963Z","updatedAt":"2021-06-17T04:02:06.963Z","__v":0},{"_id":"60cac95410f3487f688ade7f","title":"JS 数组和对象的遍历⽅式，以及⼏种⽅式的⽐较","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">通常我们会⽤循环的⽅式来遍历数组。但是循环是 导致js 性能问题的原因之 ⼀。⼀般我们会采⽤下⼏种⽅式来进⾏数组的遍历</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">for in 循环</li>\n<li style=\"padding: 0px; margin: 0px;\">for 循环</li>\n<li style=\"padding: 0px; margin: 0px;\">forEach\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">这⾥的 forEach 回调中两个参数分别为 value ， index</li>\n<li style=\"padding: 0px; margin: 0px;\">forEach ⽆法遍历对象</li>\n<li style=\"padding: 0px; margin: 0px;\">IE不⽀持该⽅法； Firefox 和 chrome ⽀持</li>\n<li style=\"padding: 0px; margin: 0px;\">forEach ⽆法使⽤ break ， continue 跳出循环，且使⽤ return 是跳过本次循环</li>\n</ul>\n</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这两种⽅法应该⾮常常⻅且使⽤很频繁。但实际上，这两种⽅法都存在性能问题</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在⽅式⼀中， for-in 需要分析出 array 的每个属性，这个操作性能开销很⼤。⽤在 key 已知的数组上是⾮常不划算的。所以尽量不要⽤ for-in ，除⾮你不清楚要处理哪 些属性，例如 JSON 对象这样的情况</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在⽅式2中，循环每进⾏⼀次，就要检查⼀下数组⻓度。读取属性（数组⻓度）要⽐读局部 变量慢，尤其是当 array ⾥存放的都是 DOM 元素，因为每次读取都会扫描⼀遍⻚⾯上 的选择器相关元素，速度会⼤⼤降低</p>","rank_id":502,"createdAt":"2021-06-17T04:02:28.284Z","updatedAt":"2021-06-17T04:02:28.284Z","__v":0},{"_id":"60cac99210f3487f688ade80","title":"浏览器缓存","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流 程如下</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">先根据这个资源的⼀些 http header 判断它是否命中强缓存，如果命中，则直接从本地 获取缓存资源，不会发请求到服务器；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另⼀些 request header 验证这个资源是否命中协商缓存，称为 http 再验证，如果命中，服务器将请求返回，但 不返回资源，⽽是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资 源；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓 存不对发送请求到服务器，但协商缓存会。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">当协商缓存也没命中时，服务器就会将资源发送回客户端。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">当 ctrl+f5 强制刷新⽹⻚时，直接从服务器加载，跳过强缓存和协商缓存；</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">当 f5 刷新⽹⻚时，跳过强缓存，但是会检查协商缓存；</span></p>\n<h3 id=\"强缓存\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">强缓存</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">Expires （该字段是 http1.0 时的规范，值为⼀个绝对时间的 GMT 格式的时间字符 串，代表缓存资源的过期时间）</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">Cache-Control:max-age （该字段是 http1.1 的规范，强缓存利⽤其 max-age 值来 判断缓存资源的最⼤⽣命周期，它的值单位为秒）</span></p>\n<h3 id=\"协商缓存\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">协商缓存</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">Last-Modified （值为资源最后更新时间，随服务器response返回）</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">If-Modified-Since （通过⽐较两个时间来判断资源在两次请求期间是否有过修改，如 果没有修改，则命中协商缓存）</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">ETag （表示资源内容的唯⼀标识，随服务器 response 返回）</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">If-None-Match （服务器通过⽐较请求头部的 If-None-Match 与当前资源的 ETag 是 否⼀致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存</span></p>","rank_id":503,"createdAt":"2021-06-17T04:03:30.246Z","updatedAt":"2021-06-17T04:03:30.246Z","__v":0},{"_id":"60cac9c010f3487f688ade81","title":"现在要你完成⼀个Dialog组件，说说你设计的思路？它应该有什么功能？","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">该组件需要提供 hook 指定渲染位置，默认渲染在body下⾯。</li>\n<li style=\"padding: 0px; margin: 0px;\">然后改组件可以指定外层样式，如宽度等</li>\n<li style=\"padding: 0px; margin: 0px;\">组件外层还需要⼀层 mask 来遮住底层内容，点击 mask 可以执⾏传进来的 onCancel 函数关闭 Dialog 。</li>\n<li style=\"padding: 0px; margin: 0px;\">另外组件是可控的，需要外层传⼊ visible 表示是否可⻅。</li>\n<li style=\"padding: 0px; margin: 0px;\">然后 Dialog 可能需要⾃定义头head和底部 footer ，默认有头部和底部，底部有⼀个确认按钮和取消按钮，确认按钮会执⾏外部传进来的 onOk 事件，然后取消按钮会执⾏外部传进来的 onCancel 事件。</li>\n<li style=\"padding: 0px; margin: 0px;\">当组件的 visible 为 true 时候，设置 body 的 overflow 为 hidden ，隐藏 body 的滚动条，反之显示滚动条。</li>\n<li style=\"padding: 0px; margin: 0px;\">组件⾼度可能⼤于⻚⾯⾼度，组件内部需要滚动条。</li>\n<li style=\"padding: 0px; margin: 0px;\">只有组件的 visible 有变化且为 ture 时候，才重渲染组件内的所有内容</li>\n</ul>","rank_id":504,"createdAt":"2021-06-17T04:04:16.747Z","updatedAt":"2021-06-17T04:04:16.747Z","__v":0},{"_id":"60caca0310f3487f688ade82","title":"谈一谈　内存泄漏","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">定义：程序中⼰动态分配的堆内存由于某种原因程序未释放或⽆法释放引发的 各种问题</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><strong>js中可能出现的内存泄漏情况</strong></span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">结果：变慢，崩溃，延迟⼤等，原因：</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">全局变量</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">dom 清空时，还存在引⽤</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">ie 中使⽤闭包</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">定时器未清除</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">⼦元素存在引起的内存泄露</span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\"><strong>避免策略</strong></span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">减少不必要的全局变量，或者⽣命周期较⻓的对象，及时对⽆⽤的数据进⾏垃圾回收；</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">注意程序逻辑，避免&ldquo;死循环&rdquo;之类的 ；</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">避免创建过多的对象 原则：不⽤了的东⻄要及时归还。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">减少层级过多的引⽤</span></li>\n</ul>","rank_id":505,"createdAt":"2021-06-17T04:05:23.085Z","updatedAt":"2021-06-17T04:05:23.085Z","__v":0},{"_id":"60caca1c10f3487f688ade83","title":"前后端路由差别","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">后端每次路由请求都是重新访问服务器</li>\n<li style=\"padding: 0px; margin: 0px;\">前端路由实际上只是 JS 根据 URL 来操作 DOM 元素，根据每个⻚⾯需要的去服务端请求数据，返回数据后和模板进⾏组合</li>\n</ul>","rank_id":506,"createdAt":"2021-06-17T04:05:48.524Z","updatedAt":"2021-06-17T04:05:48.524Z","__v":0},{"_id":"60caca5010f3487f688ade84","title":"怎么判断⻚⾯是否加载完成","code":"","type":"js/jquery/es6+","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Load 事件触发代表⻚⾯中的 DOM ， CSS ， JS ，图⽚已经全部加载完毕。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待CSS ， JS ，图⽚加载</p>","rank_id":507,"createdAt":"2021-06-17T04:06:40.006Z","updatedAt":"2021-06-17T04:06:40.006Z","__v":0},{"_id":"60caca9310f3487f688ade85","title":"Service worker","code":"","type":"network protocol","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Service workers 本质上充当Web应⽤程序与浏览器之间的代理服务器，也可以在⽹络可⽤时作为浏览器和⽹络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截⽹络请求并基于⽹络是否可⽤以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">⽬前该技术通常⽤来做缓存⽂件，提⾼⾸屏速度，可以试着来实现这个功能</p>\n<pre class=\"language-javascript\"><code>// index.js\nif (navigator.serviceWorker) {\n    navigator.serviceWorker\n    .register(\"sw.js\")\n    .then(function(registration) {\n        console.log(\"service worker 注册成功\");\n    })\n    .catch(function(err) {\n        console.log(\"servcie worker 注册失败\");\n    });\n}\n// sw.js\n// 监听 `install` 事件，回调中缓存所需⽂件\nself.addEventListener(\"install\", e =&gt; {\n    e.waitUntil(\n        caches.open(\"my-cache\").then(function(cache) {\n            return cache.addAll([\"./index.html\", \"./index.js\"]);\n        })\n    );\n});\n// 拦截所有请求事件\n// 如果缓存中已经有请求的数据就直接⽤缓存，否则去请求数据\nself.addEventListener(\"fetch\", e =&gt; {\n    e.respondWith(\n        caches.match(e.request).then(function(response) {\n            if (response) {\n                return response;\n            }\n            console.log(\"fetch source\");\n        })\n    );\n});</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">打开⻚⾯，可以在开发者⼯具中的 Application 看到 Service Worker 已经启动了</span></p>","rank_id":508,"createdAt":"2021-06-17T04:07:47.686Z","updatedAt":"2021-06-17T04:07:47.686Z","__v":0},{"_id":"60cacaf410f3487f688ade86","title":"浏览器性能问题","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">重绘（Repaint）和回流（Reflow）</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">重绘和回流是渲染步骤中的⼀⼩节，但是这两个步骤对于性能影响很⼤。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">重绘是当节点需要更改外观⽽不会影响布局的，⽐如改变 color 就叫称为重绘</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">回流是布局或者⼏何属性需要改变就称为回流。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">回流必定会发⽣重绘，重绘不⼀定会引发回流。回流所需的成本⽐重绘⾼的多，改变深层</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">次的节点很可能导致⽗节点的⼀系列回流。</span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">所以以下⼏个动作可能会导致性能问题：</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">改变 window ⼤⼩</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">改变字体</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">添加或删除样式</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">⽂字改变</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">定位或者浮动</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">盒模型</span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">很多⼈不知道的是，重绘和回流其实和 Event loop 有关。</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">当 Event loop 执⾏完 Microtasks 后，会判断 document 是否需要更新。- 因为浏览器是 60Hz 的刷新率，每 16ms 才会更新⼀次。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是⾄少 16ms 才会触发⼀次，并且⾃带节流功能。</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">判断是否触发了 media query</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">更新动画并且发送事件</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">判断是否有全屏操作事件</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">执⾏ requestAnimationFrame 回调</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">执⾏ IntersectionObserver 回调，该⽅法⽤于判断元素是否可⻅，可以⽤于懒加载上，但是兼容性不好</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">更新界⾯</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">以上就是⼀帧中可能会做的事情。如果在⼀帧中有空闲时间，就会去执⾏ requestIdleCallback 回调。</span></li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">减少重绘和回流</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">使⽤ translate 替代 top</span>\n<pre class=\"language-markup\"><code>&lt;div class=\"test\"&gt;&lt;/div&gt;\n&lt;style&gt;\n.test {\n    position: absolute;\n    top: 10px;\n    width: 100px;\n    height: 100px;\n    background: red;\n}\n&lt;/style&gt;\n&lt;script&gt;\nsetTimeout(() =&gt; {\n    // 引起回流\n    document.querySelector('.test').style.top = '100px'\n}, 1000)\n&lt;/script&gt;</code></pre>\n</li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">使⽤ visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流 （改变了布局）</span>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">把 DOM 离线后修改，⽐如：先把 DOM 给 display:none (有⼀次 Reflow )，然后你修改 100 次，然后再把它显示出来</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">不要把 DOM 点的属性值放在⼀个循环⾥当成循环⾥的变量</span>\n<pre class=\"language-javascript\"><code>for(let i = 0; i &lt; 1000; i++) {\n    // 获取 offsetTop 会导致回流，因为需要去获取正确的值\n    console.log(document.querySelector('.test').style.offsetTop)\n}</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">不要使⽤ table 布局，可能很⼩的⼀个⼩改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使⽤ requestAnimationFrame</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">CSS 选择符从右往左匹配查找，避免 DOM 深度过深</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">将频繁运⾏的动画变为图层，图层能够阻⽌该节点回流影响别的元素。⽐如对于 video 标签，浏览器会⾃动将该节点变为图层。</span></li>\n</ul>\n<h3 id=\"cdn\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">CDN</span></h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">静态资源尽量使⽤ CDN 加载，由于浏览器对于单个域名有并发请求上限，可 以考虑使⽤多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要 与主站不同，否则每次请求都会带上主站的 Cookie</span></p>\n<h3 id=\"使-webpack-优化项\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">使⽤ Webpack 优化项⽬</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">对于 Webpack4 ，打包项⽬使⽤ production 模式，这样会⾃动开启代码压缩</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">使⽤ ES6 模块来开启 tree shaking ，这个技术可以移除没有使⽤的代码</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">优化图⽚，对于⼩图可以使⽤ base64 的⽅式写⼊⽂件中</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">按照路由拆分代码，实现按需加载</span></li>\n</ul>","rank_id":509,"createdAt":"2021-06-17T04:09:24.463Z","updatedAt":"2021-06-17T04:09:24.463Z","__v":0},{"_id":"60cacbc010f3487f688ade87","title":"如何保证前端页面的安全","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">跨⽹站指令码（英语： Cross-site scripting ，通常简称为： XSS ）是⼀ 种⽹站应⽤程式的安全漏洞攻击，是代码注⼊的⼀种。它允许恶意使⽤者将程 式码注⼊到⽹⻚上，其他使⽤者在观看⽹⻚时就会受到影响。这类攻击通常包 含了 HTML 以及使⽤者端脚本语⾔</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">XSS 分为三种：反射型，存储型和 DOM-based</p>\n<h3 id=\"如何攻击\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">如何攻击</h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">XSS 通过修改 HTML 节点或者执⾏ JS 代码来攻击⽹站。</li>\n<li style=\"padding: 0px; margin: 0px;\">例如通过 URL 获取某些参数\n<pre class=\"language-markup\"><code>&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;\n&lt;div&gt;{{name}}&lt;/div&gt;</code></pre>\n</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">上述 URL 输⼊可能会将 HTML 改为&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;div&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/div&gt;</code>&nbsp;，这样⻚⾯中就凭空多了⼀段可执⾏脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击</p>\n<h3 id=\"如何防御\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">如何防御</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">最普遍的做法是转义输⼊输出的内容，对于引号，尖括号，斜杠进⾏转义</p>\n<pre class=\"language-javascript\"><code>function escape(str) {\n    str = str.replace(/&amp;/g, \"&amp;amp;\");\n    str = str.replace(/&lt;/g, \"&amp;lt;\");\n    str = str.replace(/&gt;/g, \"&amp;gt;\");\n    str = str.replace(/\"/g, \"&amp;quto;\");\n    str = str.replace(/'/g, \"&amp;##39;\");\n    str = str.replace(/`/g, \"&amp;##96;\");\n    str = str.replace(/\\//g, \"&amp;##x2F;\");\n    return str\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">通过转义可以将攻击代码&nbsp;</span><code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px; color: #495666; font-size: 16px; background-color: #ffffff;\">&lt;script&gt;alert(1)&lt;/script&gt;</code><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">&nbsp;变成</span></p>\n<pre class=\"language-javascript\"><code>// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;##x2F;script&amp;gt;\nescape('&lt;script&gt;alert(1)&lt;/script&gt;')</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">对于显示富⽂本来说，不能通过上⾯的办法来转义所有字符，因为这样会把需 要的格式也过滤掉。这种情况通常采⽤⽩名单过滤的办法，当然也可以通过⿊ 名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使⽤⽩ 名单的⽅式</span></p>\n<pre class=\"language-javascript\"><code>var xss = require(\"xss\");\nvar html = xss('&lt;h1 id=\"title\"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(\"xss\");&lt;/script&gt;'\n// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(\"xss\");&amp;lt;/script&amp;gt;\nconsole.log(html);</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">以上示例使⽤了 js-xss 来实现。可以看到在输出中保留了 h1 标签且过滤 了 script 标签</p>\n<h2 id=\"2-csrf\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">2 CSRF</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">跨站请求伪造（英语： Cross-site request forgery ），也被称为 one- click attack 或者 session riding ，通常缩写为 CSRF 或者 XSRF ，</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">是⼀种挟制⽤户在当前已登录的 Web 应⽤程序上执⾏⾮本意的操作的攻击⽅ 法</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">CSRF 就是利⽤⽤户的登录态发起恶意请求</p>\n<h3 id=\"如何攻击-1\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">如何攻击</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">假设⽹站中有⼀个通过 Get 请求提交⽤户评论的接⼝，那么攻击者就可以在钓 ⻥⽹站中加⼊⼀个图⽚，图⽚的地址就是评论接⼝</p>\n<pre class=\"language-markup\"><code>&lt;img src=\"http://www.domain.com/xxx?comment='attack'\"/&gt;</code></pre>\n<h3 id=\"如何防御-1\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">如何防御</h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">Get 请求不对数据进⾏修改</li>\n<li style=\"padding: 0px; margin: 0px;\">不让第三⽅⽹站访问到⽤户 Cookie</li>\n<li style=\"padding: 0px; margin: 0px;\">阻⽌第三⽅⽹站请求接⼝</li>\n<li style=\"padding: 0px; margin: 0px;\">请求时附带验证信息，⽐如验证码或者 token</li>\n</ul>\n<h2 id=\"3-密码安全\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">3 密码安全</h2>\n<h3 id=\"加盐\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">加盐</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于密码存储来说，必然是不能明⽂存储在数据库中的，否则⼀旦数据库泄 露，会对⽤户造成很⼤的损失。并且不建议只对密码单纯通过加密算法加密， 因为存在彩虹表的关系</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">通常需要对密码加盐，然后进⾏⼏次不同加密算法的加密</p>\n<pre class=\"language-javascript\"><code>// 加盐也就是给原密码添加字符串，增加原密码⻓度\nsha256(sha1(md5(salt + password + salt)))</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">但是加盐并不能阻⽌别⼈盗取账号，只能确保即使数据库泄露，也不会暴露⽤ 户的真实密码。⼀旦攻击者得到了⽤户的账号，可以通过暴⼒破解的⽅式破解 密码。对于这种情况，通常使⽤验证码增加延时或者限制尝试次数的⽅式。并 且⼀旦⽤户输⼊了错误的密码，也不能直接提示⽤户输错密码，⽽应该提示账 号或密码错误</p>\n<h3 id=\"前端加密\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">前端加密</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">虽然前端加密对于安全防护来说意义不⼤，但是在遇到中间⼈攻击的情况下， 可以避免明⽂密码被第三⽅获取</p>","rank_id":510,"createdAt":"2021-06-17T04:12:48.183Z","updatedAt":"2021-06-17T04:12:48.183Z","__v":0},{"_id":"60cacd2710f3487f688ade88","title":"谈一谈框架的 Virtual Dom","code":"","type":"vue/react","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">为什么需要 Virtual Dom</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">众所周知，操作 DOM 是很耗费性能的⼀件事情，既然如此，我们可以考虑通 过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象⽐操作 DOM 省时的多</p>\n<pre class=\"language-javascript\"><code>// 假设这⾥模拟⼀个 ul，其中包含了 5 个 li\n[1, 2, 3, 4, 5]\n// 这⾥替换上⾯的 li\n[1, 2, 5, 4]</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">从上述例⼦中，我们⼀眼就可以看出先前的 ul 中的第三个 li 被移除了， 四五替换了位置。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果以上操作对应到 DOM 中，那么就是以下代码</p>\n<pre class=\"language-javascript\"><code>// 删除第三个 li\nul.childNodes[2].remove()\n// 将第四个 li 和第五个交换位置\nlet fromNode = ul.childNodes[4]\nlet toNode = node.childNodes[3]\nlet cloneFromNode = fromNode.cloneNode(true)\nlet cloenToNode = toNode.cloneNode(true)\nul.replaceChild(cloneFromNode, toNode)\nul.replaceChild(cloenToNode, fromNode)</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当然在实际操作中，我们还需要给每个节点⼀个标识，作为判断是同⼀个节点 的依据。所以这也是 Vue 和 React 中官⽅推荐列表⾥的节点使⽤唯⼀的 key 来保证性能。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应 的 DOM</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">以下是⼀个 JS 对象模拟 DOM 对象的简单实现</p>\n<pre class=\"language-javascript\"><code>export default class Element {\n    /**\n    * @param {String} tag 'div'\n    * @param {Object} props { class: 'item' }\n    * @param {Array} children [ Element1, 'text']\n    * @param {String} key option\n    */\n    constructor(tag, props, children, key) {\n        this.tag = tag\n        this.props = props\n        if (Array.isArray(children)) {\n            \n            this.children = children\n        } else if (isString(children)) {\n            this.key = children\n            this.children = null\n        }\n        if (key) this.key = key\n    }\n    // 渲染\n    render() {\n        let root = this._createElement(\n            this.tag,\n            this.props,\n            this.children,\n            this.key\n        )\n        document.body.appendChild(root)\n        return root\n    }\n    create() {\n        return this._createElement(this.tag, this.props, this.children, this.ke\n    }\n    // 创建节点\n    _createElement(tag, props, child, key) {\n        // 通过 tag 创建节点\n        let el = document.createElement(tag)\n        // 设置节点属性\n        for (const key in props) {\n            if (props.hasOwnProperty(key)) {\n                const value = props[key]\n                el.setAttribute(key, value)\n            }\n        }\n        if (key) {\n            el.setAttribute('key', key)\n        }\n        // 递归添加⼦节点\n        if (child) {\n            child.forEach(element =&gt; {\n                let child\n                if (element instanceof Element) {\n                    child = this._createElement(\n                        element.tag,\n                        element.props,\n                        element.children,\n                        element.key\n                    )\n                } else {\n                    child = document.createTextNode(element)\n                }\n                el.appendChild(child)\n            })\n        }\n        return el\n    }\n}</code></pre>\n<h3 id=\"virtual-dom-算法简述\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">Virtual Dom 算法简述</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">既然我们已经通过 JS 来模拟实现了 DOM ，那么接下来的难点就在于如何判断旧的对象 和新的对象之间的差异。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">DOM 是多叉树的结构，如果需要完整的对⽐两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3) ，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对⽐差异。</p>\n<div class=\"google-auto-placed ap_container\" style=\"padding: 0px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff; width: 870px; height: auto; clear: both; text-align: center;\"><ins class=\"adsbygoogle adsbygoogle-noablate\" style=\"display: block; margin: auto; background-color: transparent; height: 0px;\" data-ad-format=\"auto\" data-ad-client=\"ca-pub-3504340093271389\" data-adsbygoogle-status=\"done\" data-ad-status=\"unfilled\"><ins id=\"aswift_3_expand\" style=\"display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent;\" tabindex=\"0\" title=\"Advertisement\" aria-label=\"Advertisement\"><ins id=\"aswift_3_anchor\" style=\"display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent; overflow: hidden; opacity: 0;\"><iframe id=\"aswift_3\" style=\"left: 0px; position: absolute; top: 0px; border-width: 0px; border-style: initial; width: 870px; height: 0px;\" src=\"https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3504340093271389&amp;output=html&amp;h=280&amp;adk=109321987&amp;adf=3163410877&amp;pi=t.aa~a.2817947589~i.28~rp.4&amp;w=870&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1622810656&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9523024247&amp;psa=1&amp;ad_type=text_image&amp;format=870x280&amp;url=https%3A%2F%2Fwww.axihe.com%2Ffocus%2Fweb%2F042.html&amp;flash=0&amp;fwr=0&amp;pra=3&amp;rh=200&amp;rw=870&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;uach=WyJXaW5kb3dzIiwiMTAuMCIsIng4NiIsIiIsIjkxLjAuNDQ3Mi4xMDYiLFtdXQ..&amp;dt=1623903205752&amp;bpp=1&amp;bdt=416&amp;idt=1&amp;shv=r20210615&amp;cbv=%2Fr20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3Dc42b20e6ee6efa3d-221193c456c90083%3AT%3D1623293344%3ART%3D1623293344%3AS%3DALNI_MbzQJ6BWGNxs0oRE7-tp-4q8E74oA&amp;prev_fmts=0x0%2C890x280&amp;nras=2&amp;correlator=6644945557548&amp;frm=20&amp;pv=1&amp;ga_vid=1424451971.1623903206&amp;ga_sid=1623903206&amp;ga_hid=1434507560&amp;ga_fc=0&amp;u_tz=480&amp;u_his=4&amp;u_java=0&amp;u_h=864&amp;u_w=1536&amp;u_ah=824&amp;u_aw=1536&amp;u_cd=24&amp;u_nplug=3&amp;u_nmime=4&amp;adx=325&amp;ady=2830&amp;biw=1519&amp;bih=722&amp;scr_x=0&amp;scr_y=0&amp;oid=3&amp;pvsid=2720676875084374&amp;pem=199&amp;ref=https%3A%2F%2Fwww.axihe.com%2Fmap%2Fweb-focus.html&amp;eae=0&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1536%2C0%2C1536%2C824%2C1536%2C722&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;ifi=4&amp;uci=a!4&amp;btvi=1&amp;fsb=1&amp;xpc=ECJaLwmqEj&amp;p=https%3A//www.axihe.com&amp;dtd=23\" name=\"aswift_3\" width=\"870\" height=\"0\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" sandbox=\"allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation\" allowfullscreen=\"allowfullscreen\" data-google-container-id=\"a!4\" data-load-complete=\"true\" data-google-query-id=\"CIDg8O3mnfECFUrAlgodSqkFqw\"></iframe></ins></ins></ins></div>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">实现 O(n) 复杂度的关键就是只对⽐同层的节点，⽽不是跨层对⽐，这也是考虑到在实际 业务中很少会去跨层的移动 DOM 元素</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">所以判断差异的算法就分为了两步</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">⾸先从上⾄下，从左往右遍历对象，也就是树的深度遍历，这⼀步中会给每个节点添加索 引，便于最后渲染差异</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">⼀旦节点有⼦元素，就去判断⼦元素是否有不同</p>\n<h3 id=\"virtual-dom-算法实现\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">Virtual Dom 算法实现</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">树的递归</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">⾸先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对⽐会有⼏种情况</li>\n<li style=\"padding: 0px; margin: 0px;\">新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的⼦元素了，因为整个旧节点都被删掉了</li>\n<li style=\"padding: 0px; margin: 0px;\">新的节点的 tagName 和 key （可能都没有）和旧的相同，开始遍历⼦树</li>\n<li style=\"padding: 0px; margin: 0px;\">没有新的节点，那么什么都不⽤做</li>\n</ul>\n<pre class=\"language-javascript\"><code>import { StateEnums, isString, move } from './util'\nimport Element from './element'\nexport default function diff(oldDomTree, newDomTree) {\n    // ⽤于记录差异\n    let pathchs = {}\n    // ⼀开始的索引为 0\n    dfs(oldDomTree, newDomTree, 0, pathchs)\n    return pathchs\n}\nfunction dfs(oldNode, newNode, index, patches) {\n    // ⽤于保存⼦树的更改\n    let curPatches = []\n    // 需要判断三种情况\n    // 1.没有新的节点，那么什么都不⽤做\n    // 2.新的节点的 tagName 和 `key` 和旧的不同，就替换\n    // 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历⼦树\n    if (!newNode) {\n        \n    } else if (newNode.tag === oldNode.tag &amp;&amp; newNode.key === oldNode.key) {\n        // 判断属性是否变更\n        let props = diffProps(oldNode.props, newNode.props)\n        if (props.length) curPatches.push({ type: StateEnums.ChangeProps, props\n            // 遍历⼦树\n            diffChildren(oldNode.children, newNode.children, index, patches)\n        } else {\n            // 节点不同，需要替换\n            curPatches.push({ type: StateEnums.Replace, node: newNode })\n        }\n        if (curPatches.length) {\n            if (patches[index]) {\n                patches[index] = patches[index].concat(curPatches)\n            } else {\n                patches[index] = curPatches\n            }\n        }\n    }\n}</code></pre>\n<h3 id=\"判断属性的更改\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">判断属性的更改</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">判断属性的更改也分三个步骤</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中 遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化 在第⼆步中同时查看是否有属性不存在与旧的属性列列表中</p>\n<pre class=\"language-javascript\"><code>function diffProps(oldProps, newProps) {\n    // 判断 Props 分以下三步骤\n    // 先遍历 oldProps 查看是否存在删除的属性\n    // 然后遍历 newProps 查看是否有属性值被修改\n    // 最后查看是否有属性新增\n    let change = []\n    for (const key in oldProps) {\n        if (oldProps.hasOwnProperty(key) &amp;&amp; !newProps[key]) {\n            change.push({\n                prop: key\n            })\n        }\n    }\n    for (const key in newProps) {\n        if (newProps.hasOwnProperty(key)) {\n            const prop = newProps[key]\n            if (oldProps[key] &amp;&amp; oldProps[key] !== newProps[key]) {\n                change.push({\n                    prop: key,\n                    value: newProps[key]\n                })\n            } else if (!oldProps[key]) {\n                change.push({\n                    prop: key,\n                    value: newProps[key]\n                })\n            }\n        }\n    }\n    return change\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">判断列表差异算法实现</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这个算法是整个 Virtual Dom 中最核⼼的算法，且让我⼀⼀为你道来。 这 ⾥的主要步骤其实和判断属性差异是类似的，也是分为三步</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中</li>\n<li style=\"padding: 0px; margin: 0px;\">遍历新的节点列表，判断是否有新的节点</li>\n<li style=\"padding: 0px; margin: 0px;\">在第⼆步中同时判断节点是否有移动</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">PS：该算法只对有 key 的节点做处理</p>\n<pre class=\"language-javascript\"><code>function listDiff(oldList, newList, index, patches) {\n    // 为了遍历⽅便，先取出两个 list 的所有 keys\n    let oldKeys = getKeys(oldList)\n    let newKeys = getKeys(newList)\n    let changes = []\n    // ⽤于保存变更后的节点数据\n    // 使⽤该数组保存有以下好处\n    // 1.可以正确获得被删除节点索引\n    // 2.交换节点位置只需要操作⼀遍 DOM\n    // 3.⽤于 `diffChildren` 函数中的判断，只需要遍历\n    // 两个树中都存在的节点，⽽对于新增或者删除的节点来说，完全没必要\n    // 再去判断⼀遍\n    let list = []\n    oldList &amp;&amp;\n    oldList.forEach(item =&gt; {\n        let key = item.key\n        if (isString(item)) {\n            key = item\n        }\n        // 寻找新的 children 中是否含有当前节点\n        // 没有的话需要删除\n        let index = newKeys.indexOf(key)\n        if (index === -1) {\n            list.push(null)\n        } else list.push(key)\n    })\n    // 遍历变更后的数组\n    let length = list.length\n    // 因为删除数组元素是会更改索引的\n    // 所有从后往前删可以保证索引不变\n    for (let i = length - 1; i &gt;= 0; i--) {\n        // 判断当前元素是否为空，为空表示需要删除\n        if (!list[i]) {\n            list.splice(i, 1)\n            changes.push({\n                type: StateEnums.Remove,\n                index: i\n            })\n        }\n    }\n    // 遍历新的 list，判断是否有节点新增或移动\n    // 同时也对 `list` 做节点新增和移动节点的操作\n    newList &amp;&amp;\n    newList.forEach((item, i) =&gt; {\n        let key = item.key\n        if (isString(item)) {\n            key = item\n        }\n        // 寻找旧的 children 中是否含有当前节点\n        let index = list.indexOf(key)\n        // 没找到代表新节点，需要插⼊\n        if (index === -1 || key == null) {\n            changes.push({\n                type: StateEnums.Insert,\n                node: item,\n                index: i\n            })\n            list.splice(i, 0, key)\n        } else {\n            // 找到了，需要判断是否需要移动\n            if (index !== i) {\n                changes.push({\n                    type: StateEnums.Move,\n                    from: index,\n                    to: i\n                })\n                move(list, index, i)\n            }\n        }\n    })\n    return { changes, list }\n}\nfunction getKeys(list) {\n    let keys = []\n    let text\n    list &amp;&amp;\n    list.forEach(item =&gt; {\n        let key\n        if (isString(item)) {\n            key = [item]\n        } else if (item instanceof Element) {\n            key = item.key\n        }\n        keys.push(key)\n    })\n    return keys\n}</code></pre>\n<h3 id=\"遍历元素打标识\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">遍历⼦元素打标识</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于这个函数来说，主要功能就两个</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">判断两个列表差异</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">给节点打上标记</li>\n<li style=\"padding: 0px; margin: 0px;\">总体来说，该函数实现的功能很简单\n<pre class=\"language-javascript\"><code>function diffChildren(oldChild, newChild, index, patches) {\n    let { changes, list } = listDiff(oldChild, newChild, index, patches)\n    if (changes.length) {\n        if (patches[index]) {\n            patches[index] = patches[index].concat(changes)\n        } else {\n            patches[index] = changes\n        }\n    }\n    // 记录上⼀个遍历过的节点\n    let last = null\n    oldChild &amp;&amp;\n    oldChild.forEach((item, i) =&gt; {\n        let child = item &amp;&amp; item.children\n        if (child) {\n            index = last &amp;&amp; last.children ? index + last.children.length + 1 : index\n            let keyIndex = list.indexOf(item.key)\n            let node = newChild[keyIndex]\n            // 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历\n            if (node) {\n                dfs(item, node, index, patches)\n            }\n        } else index += 1\n        last = item\n    })\n}</code></pre>\n</li>\n</ul>\n<h3 id=\"渲染差异\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; color: #666666; letter-spacing: 3px;\">渲染差异</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需 要局部去更新 DOM 了，下⾯就让我们来看看 Virtual Dom 算法的最后⼀ 步骤</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">这个函数主要两个功能</p>\n<ul>\n<li style=\"list-style-type: none;\">\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">深度遍历树，将需要做变更操作的取出来</li>\n<li style=\"padding: 0px; margin: 0px;\">局部更新 DOM</li>\n</ul>\n</li>\n</ul>\n<pre class=\"language-javascript\"><code>let index = 0\nexport default function patch(node, patchs) {\n    let changes = patchs[index]\n    let childNodes = node &amp;&amp; node.childNodes\n    // 这⾥的深度遍历和 diff 中是⼀样的\n    if (!childNodes) index += 1\n    if (changes &amp;&amp; changes.length &amp;&amp; patchs[index]) {\n        changeDom(node, changes)\n    }\n    let last = null\n    if (childNodes &amp;&amp; childNodes.length) {\n        childNodes.forEach((item, i) =&gt; {\n            index = last &amp;&amp; last.children ? index + last.children.length + 1 : index +\n            patch(item, patchs)\n            last = item\n        })\n    }\n}\nfunction changeDom(node, changes, noChild) {\n    changes &amp;&amp;\n    changes.forEach(change =&gt; {\n        let { type } = change\n        switch (type) {\n            case StateEnums.ChangeProps:\n                let { props } = change\n                props.forEach(item =&gt; {\n                    if (item.value) {\n                        node.setAttribute(item.prop, item.value)\n                    } else {\n                        node.removeAttribute(item.prop)\n                    }\n                })\n                break\n            case StateEnums.Remove:\n                node.childNodes[change.index].remove()\n                break\n            case StateEnums.Insert:\n                let dom\n                if (isString(change.node)) {\n                    dom = document.createTextNode(change.node)\n                } else if (change.node instanceof Element) {\n                    dom = change.node.create()\n                }\n                node.insertBefore(dom, node.childNodes[change.index])\n                break\n            case StateEnums.Replace:\n                node.parentNode.replaceChild(change.node.create(), node)\n                break\n            case StateEnums.Move:\n                let fromNode = node.childNodes[change.from]\n                let toNode = node.childNodes[change.to]\n                let cloneFromNode = fromNode.cloneNode(true)\n                let cloenToNode = toNode.cloneNode(true)\n                node.replaceChild(cloneFromNode, toNode)\n                node.replaceChild(cloenToNode, fromNode)\n                break\n            default:\n                break\n        }\n    })\n}</code></pre>\n<h3 id=\"virtual-dom-算法的实现也就是以下三步\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">Virtual Dom 算法的实现也就是以下三步</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">通过 JS 来模拟创建 DOM 对象 判断两个对象的差异 渲染差异</p>\n<pre class=\"language-javascript\"><code>let test4 = new Element('div', { class: 'my-div' }, ['test4'])\nlet test5 = new Element('ul', { class: 'my-div' }, ['test5'])\nlet test1 = new Element('div', { class: 'my-div' }, [test4])\nlet test2 = new Element('div', { id: '11' }, [test5, test4])\nlet root = test1.render()\nlet pathchs = diff(test1, test2)\nconsole.log(pathchs)\nsetTimeout(() =&gt; {\nconsole.log('开始更新')\npatch(root, pathchs)\nconsole.log('结束更新')\n}, 1000)</code></pre>","rank_id":511,"createdAt":"2021-06-17T04:18:47.409Z","updatedAt":"2021-06-17T04:18:47.409Z","__v":0},{"_id":"60cacdb510f3487f688ade89","title":"浏览器渲染原理","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<h3 id=\"1-浏览器接收到-html-件并转换为-dom-树\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">1. 浏览器接收到 HTML ⽂件并转换为 DOM 树</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当我们打开⼀个⽹⻚时，浏览器都会去请求对应的 HTML ⽂件。虽然平时我 们写代码时都会分为 JS 、 CSS 、 HTML ⽂件，也就是字符串，但是计算机 硬件是不理解这些字符串的，所以在⽹络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为 字符串，也就是我们写的代码。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记 （ token ），这⼀过程在词法分析中叫做标记化（ tokenization ）</p>\n<div class=\"google-auto-placed ap_container\" style=\"padding: 0px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff; width: 870px; height: auto; clear: both; text-align: center;\"><ins class=\"adsbygoogle adsbygoogle-noablate\" style=\"display: block; margin: auto; background-color: transparent; height: 0px;\" data-ad-format=\"auto\" data-ad-client=\"ca-pub-3504340093271389\" data-adsbygoogle-status=\"done\" data-ad-status=\"unfilled\"><ins id=\"aswift_3_expand\" style=\"display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent;\" tabindex=\"0\" title=\"Advertisement\" aria-label=\"Advertisement\"><ins id=\"aswift_3_anchor\" style=\"display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent; overflow: hidden; opacity: 0;\"><iframe id=\"aswift_3\" style=\"left: 0px; position: absolute; top: 0px; border-width: 0px; border-style: initial; width: 870px; height: 0px;\" src=\"https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3504340093271389&amp;output=html&amp;h=280&amp;adk=109321987&amp;adf=3163410877&amp;pi=t.aa~a.2817947589~i.11~rp.4&amp;w=870&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1622810656&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9523024247&amp;psa=1&amp;ad_type=text_image&amp;format=870x280&amp;url=https%3A%2F%2Fwww.axihe.com%2Ffocus%2Fweb%2F043.html&amp;flash=0&amp;fwr=0&amp;pra=3&amp;rh=200&amp;rw=870&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;uach=WyJXaW5kb3dzIiwiMTAuMCIsIng4NiIsIiIsIjkxLjAuNDQ3Mi4xMDYiLFtdXQ..&amp;dt=1623903549810&amp;bpp=1&amp;bdt=312&amp;idt=-M&amp;shv=r20210615&amp;cbv=%2Fr20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3Dc42b20e6ee6efa3d-221193c456c90083%3AT%3D1623293344%3ART%3D1623293344%3AS%3DALNI_MbzQJ6BWGNxs0oRE7-tp-4q8E74oA&amp;prev_fmts=0x0%2C890x280&amp;nras=2&amp;correlator=5457700904577&amp;frm=20&amp;pv=1&amp;ga_vid=441757143.1623903550&amp;ga_sid=1623903550&amp;ga_hid=1022266843&amp;ga_fc=0&amp;u_tz=480&amp;u_his=4&amp;u_java=0&amp;u_h=864&amp;u_w=1536&amp;u_ah=824&amp;u_aw=1536&amp;u_cd=24&amp;u_nplug=3&amp;u_nmime=4&amp;adx=325&amp;ady=829&amp;biw=1519&amp;bih=722&amp;scr_x=0&amp;scr_y=0&amp;oid=3&amp;pvsid=3405520130224873&amp;pem=199&amp;ref=https%3A%2F%2Fwww.axihe.com%2Fmap%2Fweb-focus.html&amp;eae=0&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1536%2C0%2C1536%2C824%2C1536%2C722&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;ifi=4&amp;uci=a!4&amp;btvi=1&amp;fsb=1&amp;xpc=mdwSwhPzQV&amp;p=https%3A//www.axihe.com&amp;dtd=16\" name=\"aswift_3\" width=\"870\" height=\"0\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" sandbox=\"allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation\" allowfullscreen=\"allowfullscreen\" data-google-container-id=\"a!4\" data-load-complete=\"true\" data-google-query-id=\"CPf-95HonfECFU6_vQodkW8B0A\"></iframe></ins></ins></ins></div>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">那么什么是标记呢？这其实属于编译原理这⼀块的内容了。简单来说，标记还 是字符串，是构成代码的最⼩单位。这⼀过程会将代码分拆成⼀块块，并给这 些内容打上标记，便于理解这些最⼩单位的代码是什么意思</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当结束标记化后，这些标记会紧接着转换为 Node ，最后这些 Node 会根据 不同 Node 之前的联系构建为⼀颗 DOM 树</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">以上就是浏览器从⽹络中接收到 HTML ⽂件然后⼀系列的转换过程 当然，在解析 HTML ⽂件的时候，浏览器还会遇到 CSS 和 JS ⽂件，这时 候浏览器也会去下载并解析这些⽂件，接下来就让我们先来学习浏览器如何解 析 CSS ⽂件</p>\n<h3 id=\"2-将-css-件转换为-cssom-树\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">2. 将 CSS ⽂件转换为 CSSOM 树</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">其实转换 CSS 到 CSSOM 树的过程和上⼀⼩节的过程是极其类似的</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在这⼀过程中，浏览器会确定下每⼀个节点的样式到底是什么，并且这⼀过程其实是很消 耗资源的。因为样式你可以⾃⾏设置给某个节点，也可以通过继承获得。在这⼀过程中， 浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果你有点不理解为什么会消耗资源的话，我这⾥举个例⼦</p>\n<pre class=\"language-markup\"><code>&lt;div&gt;\n    &lt;a&gt; &lt;span&gt;&lt;/span&gt; &lt;/a&gt;\n&lt;/div&gt;\n&lt;style&gt;\n    span {\n    color: red;\n    }\n    div &gt; a &gt; span {\n    color: red;\n    }\n&lt;/style&gt;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于第⼀种设置样式的⽅式来说，浏览器只需要找到⻚⾯中所有的 span 标 签然后设置颜⾊，但是对于第⼆种设置样式的⽅式来说，浏览器⾸先需要找到 所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜⾊，这样的递归过程 就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加⽆意义标签，保证层级扁平</p>\n<h3 id=\"3-成渲染树\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">3. ⽣成渲染树</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当我们⽣成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在这⼀过程中，不是简单的将两者合并就⾏了。渲染树只会包括需要显示的节点和这些节 点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当浏览器⽣成渲染树以后，就会根据渲染树来进⾏布局（也可以叫做回流），然后调⽤ GPU 绘制，合成图层，显示在屏幕上。对于这⼀部分的内容因为过于底层，还涉及到了硬 件相关的知识，这⾥就不再继续展开内容了。</p>\n<h2 id=\"212-为什么操作-dom-慢\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">&nbsp;为什么操作 DOM 慢</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">想必⼤家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">因为 DOM 是属于渲染引擎中的东⻄，⽽ JS ⼜是 JS 引擎中的东⻄。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来⼀些性 能上的损耗。操作 DOM 次数⼀多，也就等同于⼀直在进⾏线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">经典⾯试题：插⼊⼏万个 DOM，如何实现⻚⾯不卡顿？</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于这道题⽬来说，⾸先我们肯定不能⼀次性把⼏万个 DOM 全部插⼊，这样肯定会造成 卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM 。⼤部分⼈应该可以想到通 过 requestAnimationFrame 的⽅式去循环的插⼊ DOM ，其实还有种⽅式去解决这个问 题：虚拟滚动（ virtualized scroller ）。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这种技术的原理就是只渲染可视区域内的内容，⾮可⻅区域的那就完全不渲染了，当⽤户 在滚动的时候就实时去替换渲染的内容</p>\n<div class=\"google-auto-placed ap_container\" style=\"padding: 0px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff; width: 870px; height: auto; clear: both; text-align: center;\"><ins class=\"adsbygoogle adsbygoogle-noablate\" style=\"display: block; margin: auto; background-color: transparent; height: 0px;\" data-ad-format=\"auto\" data-ad-client=\"ca-pub-3504340093271389\" data-adsbygoogle-status=\"done\" data-ad-status=\"unfilled\"><ins id=\"aswift_4_expand\" style=\"display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent;\" tabindex=\"0\" title=\"Advertisement\" aria-label=\"Advertisement\"><ins id=\"aswift_4_anchor\" style=\"display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent; overflow: hidden; opacity: 0;\"><iframe id=\"aswift_4\" style=\"left: 0px; position: absolute; top: 0px; border-width: 0px; border-style: initial; width: 870px; height: 0px;\" src=\"https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3504340093271389&amp;output=html&amp;h=280&amp;adk=109321987&amp;adf=970835177&amp;pi=t.aa~a.2817947589~i.48~rp.4&amp;w=870&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1622810656&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9523024247&amp;psa=1&amp;ad_type=text_image&amp;format=870x280&amp;url=https%3A%2F%2Fwww.axihe.com%2Ffocus%2Fweb%2F043.html&amp;flash=0&amp;fwr=0&amp;pra=3&amp;rh=200&amp;rw=870&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;uach=WyJXaW5kb3dzIiwiMTAuMCIsIng4NiIsIiIsIjkxLjAuNDQ3Mi4xMDYiLFtdXQ..&amp;dt=1623903549810&amp;bpp=1&amp;bdt=312&amp;idt=1&amp;shv=r20210615&amp;cbv=%2Fr20190131&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3Dc42b20e6ee6efa3d-221193c456c90083%3AT%3D1623293344%3ART%3D1623293344%3AS%3DALNI_MbzQJ6BWGNxs0oRE7-tp-4q8E74oA&amp;prev_fmts=0x0%2C890x280%2C870x280&amp;nras=3&amp;correlator=5457700904577&amp;frm=20&amp;pv=1&amp;ga_vid=441757143.1623903550&amp;ga_sid=1623903550&amp;ga_hid=1022266843&amp;ga_fc=0&amp;u_tz=480&amp;u_his=4&amp;u_java=0&amp;u_h=864&amp;u_w=1536&amp;u_ah=824&amp;u_aw=1536&amp;u_cd=24&amp;u_nplug=3&amp;u_nmime=4&amp;adx=325&amp;ady=2567&amp;biw=1519&amp;bih=722&amp;scr_x=0&amp;scr_y=0&amp;oid=3&amp;pvsid=3405520130224873&amp;pem=199&amp;ref=https%3A%2F%2Fwww.axihe.com%2Fmap%2Fweb-focus.html&amp;eae=0&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1536%2C0%2C1536%2C824%2C1536%2C722&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;ifi=5&amp;uci=a!5&amp;btvi=2&amp;fsb=1&amp;xpc=kKy8qh03Gr&amp;p=https%3A//www.axihe.com&amp;dtd=19\" name=\"aswift_4\" width=\"870\" height=\"0\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" sandbox=\"allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation\" allowfullscreen=\"allowfullscreen\" data-google-container-id=\"a!5\" data-load-complete=\"true\" data-google-query-id=\"CI6L-JHonfECFccmvQodOdoBIQ\"></iframe></ins></ins></ins></div>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">从上图中我们可以发现，即使列表很⻓，但是渲染的 DOM 元素永远只有那么 ⼏个，当我们滚动⻚⾯的时候就会实时去更新 DOM ，这个技术就能顺利解决 这道经典⾯试题</p>\n<h2 id=\"213-什么情况阻塞渲染\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">&nbsp;什么情况阻塞渲染</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">⾸先渲染的前提是⽣成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越 快，你越应该降低⼀开始需要渲染的⽂件⼤⼩，并且扁平层级，优化选择器。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">然后当浏览器在解析到 script 标签时，会暂停构建 DOM ，完成后才会从暂停的地⽅重 新开始。也就是说，如果你想⾸屏渲染的越快，就越不应该在⾸屏就加载 JS ⽂件，这也 是都建议将 script 标签放在 body 标签底部的原因。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当 script 标签加上 defer 属性以后，表示该 JS ⽂件会并⾏下载，但是会放到 HTML 解析完成后顺序执⾏，所以对于这种情况你可以把 script 标签放在任意位置。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于没有任何依赖的 JS ⽂件可以加上 async 属性，表示 JS ⽂件下载和解析不会阻 塞渲染。</p>\n<h2 id=\"214-重绘repaint和回流reflow\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">&nbsp;重绘（Repaint）和回流（Reflow）</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">重绘和回流会在我们设置节点样式时频繁出现，同时也会很⼤程度上影响性 能。</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">重绘是当节点需要更改外观⽽不会影响布局的，⽐如改变 color 就叫称为重绘</li>\n<li style=\"padding: 0px; margin: 0px;\">回流是布局或者⼏何属性需要改变就称为回流。</li>\n<li style=\"padding: 0px; margin: 0px;\">回流必定会发⽣重绘，重绘不⼀定会引发回流。回流所需的成本⽐重绘⾼的多，改变⽗节点⾥的⼦节点很可能会导致⽗节点的⼀系列回流。</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">以下⼏个动作可能会导致性能问题：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">改变 window ⼤⼩</li>\n<li style=\"padding: 0px; margin: 0px;\">改变字体</li>\n<li style=\"padding: 0px; margin: 0px;\">添加或删除样式</li>\n<li style=\"padding: 0px; margin: 0px;\">⽂字改变</li>\n<li style=\"padding: 0px; margin: 0px;\">定位或者浮动</li>\n<li style=\"padding: 0px; margin: 0px;\">盒模型</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">并且很多⼈不知道的是，重绘和回流其实也和 Eventloop 有关。</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">当 Eventloop 执⾏完 Microtasks 后，会判断 document 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新⼀次。</li>\n<li style=\"padding: 0px; margin: 0px;\">然后判断是否有 resize 或者 scroll 事件，有的话会去触发事件，所以 resize 和scroll 事件也是⾄少 16ms 才会触发⼀次，并且⾃带节流功能。</li>\n<li style=\"padding: 0px; margin: 0px;\">判断是否触发了 media query</li>\n<li style=\"padding: 0px; margin: 0px;\">更新动画并且发送事件</li>\n<li style=\"padding: 0px; margin: 0px;\">判断是否有全屏操作事件</li>\n<li style=\"padding: 0px; margin: 0px;\">执⾏ requestAnimationFrame 回调</li>\n<li style=\"padding: 0px; margin: 0px;\">执⾏ IntersectionObserver 回调，该⽅法⽤于判断元素是否可⻅，可以⽤于懒加载上，但是兼容性不好 更新界⾯</li>\n<li style=\"padding: 0px; margin: 0px;\">以上就是⼀帧中可能会做的事情。如果在⼀帧中有空闲时间，就会去执⾏requestIdleCallback 回调</li>\n</ul>\n<h2 id=\"215-减少重绘和回流\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">&nbsp;减少重绘和回流</h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">使⽤ transform 替代 top\n<pre class=\"language-javascript\"><code>&lt;div class=\"test\"&gt;&lt;/div&gt;\n&lt;style&gt;\n    .test {\n        position: absolute;\n        top: 10px;\n        width: 100px;\n        height: 100px;\n        background: red;\n    }\n&lt;/style&gt;\n&lt;script&gt;\n    setTimeout(() =&gt; {\n    // 引起回流\n    document.querySelector('.test').style.top = '100px'\n    }, 1000)\n&lt;/script&gt;</code></pre>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">使⽤ visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流 （改变了布局）</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">不要把节点的属性值放在⼀个循环⾥当成循环⾥的变量</p>\n<pre class=\"language-javascript\"><code>for(let i = 0; i &lt; 1000; i++) {\n    // 获取 offsetTop 会导致回流，因为需要去获取正确的值\n    console.log(document.querySelector('.test').style.offsetTop)\n}</code></pre>\n</li>\n</ol>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\" start=\"4\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">不要使⽤ table 布局，可能很⼩的⼀个⼩改动会造成整个 table 的重新布局</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使⽤requestAnimationFrame</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">CSS 选择符从右往左匹配查找，避免节点层级过多</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">将频繁重绘或者回流的节点设置为图层，图层能够阻⽌该节点的渲染⾏为影响别的节点。⽐如对于 video 标签来说，浏览器会⾃动将该节点变为图层。</p>\n</li>\n</ol>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">设置节点为图层的⽅式有很多，我们可以通过以下⼏个常⽤属性可以⽣成新图层</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">will-change</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">video 、 iframe 标签</p>","rank_id":512,"createdAt":"2021-06-17T04:21:09.943Z","updatedAt":"2021-06-17T04:21:09.943Z","__v":0},{"_id":"60cace3610f3487f688ade8a","title":"从 V8 中看 JS 性能优化","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<h2 id=\"1-测试性能具\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">1 测试性能⼯具</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Chrome 已经提供了⼀个⼤⽽全的性能测试⼯具 Audits</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">点我们点击 Audits 后，可以看到如下的界⾯</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在这个界⾯中，我们可以选择想测试的功能然后点击 Run audits ，⼯具就 会⾃动运⾏帮助我们测试问题并且给出⼀个完整的报告</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">上图是给掘⾦⾸⻚测试性能后给出的⼀个报告，可以看到报告中分别为性能、 体验、SEO 都给出了打分，并且每⼀个指标都有详细的评估</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">评估结束后，⼯具还提供了⼀些建议便于我们提⾼这个指标的分数</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我们只需要⼀条条根据建议去优化性能即可。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">除了 Audits ⼯具之外，还有⼀个 Performance ⼯具也可以供我们使⽤。 在这张图中，我们可以详细的看到每个时间段中浏览器在处理什么事情，哪个 过程最消耗时间，便于我们更加详细的了解性能瓶颈</p>\n<h2 id=\"2-js-性能优化\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">2 JS 性能优化</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">JS 是编译型还是解释型语⾔其实并不固定。⾸先 JS 需要有引擎才能运⾏ 起来，⽆论是浏览器还是在 Node 中，这是解释型语⾔的特性。但是在 V8 引擎下，⼜引⼊了 TurboFan 编译器，他会在特定的情况下进⾏优化，将代 码编译成执⾏效率更⾼的 Machine Code ，当然这个编译器并不是 JS 必须 需要的，只是为了提⾼代码执⾏性能，所以总的来说 JS 更偏向于解释型语 ⾔。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">那么这⼀⼩节的内容主要会针对于 Chrome 的 V8 引擎来讲解。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在这⼀过程中， JS 代码⾸先会解析为抽象语法树（ AST ），然后会通过解 释器或者编译器转化为 Bytecode 或者 Machine Code</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">从上图中我们可以发现， JS 会⾸先被解析为 AST ，解析的过程其实是略慢 的。代码越多，解析的过程也就耗费越⻓，这也是我们需要压缩代码的原因之 ⼀。另外⼀种减少解析时间的⽅式是预解析，会作⽤于未执⾏的函数，这个我 们下⾯再谈</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这⾥需要注意⼀点，对于函数来说，应该尽可能避免声明嵌套函数（类也是函数），因为这样 会造成函数的重复解析</p>\n<pre class=\"language-javascript\"><code>function test1() {\n    // 会被重复解析\n    function test2() {}\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">然后 Ignition 负责将 AST 转化为 Bytecode ， TurboFan 负责编译出 优化后的 Machine Code ，并且 Machine Code 在执⾏效率上优于 Bytecode</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">那么我们就产⽣了⼀个疑问，什么情况下代码会编译为 Machine Code ？</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">JS 是⼀⻔动态类型的语⾔，并且还有⼀⼤堆的规则。简单的加法运算代码， 内部就需要考虑好⼏种规则，⽐如数字相加、字符串相加、对象和字符串相加 等等。这样的情况也就势必导致了内部要增加很多判断逻辑，降低运⾏效率。</p>\n<pre class=\"language-javascript\"><code>function test1() {\n// 会被重复解析\nfunction test2() {}\n}\nfunction test(x) {\n    return x + x\n}\ntest(3)\ntest(4)\ntest(1)\ntest(2)</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于以上代码来说，如果⼀个函数被多次调⽤并且参数⼀直传⼊ number 类型，那么 V8 就会认为该段代码可以编译为 Machine Code ，因为你固定了类型，不需要再执⾏ 很多判断逻辑了。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">但是如果⼀旦我们传⼊的参数类型改变，那么 Machine Code 就会被 DeOptimized 为 Bytecode ，这样就有性能上的⼀个损耗了。所以如果我们希望代码能多的编译为 Machine Code 并且 DeOptimized 的次数减少，就应该尽可能保证传⼊的类型⼀致。 那么你可能会有⼀个疑问，到底优化前后有多少的提升呢，接下来我们就来实践测试⼀下 到底有多少的提升</p>\n<pre class=\"language-javascript\"><code>const { performance, PerformanceObserver } = require('perf_hooks')\nfunction test(x) {\n    return x + x\n}\n// node 10 中才有 PerformanceObserver\n// 在这之前的 node 版本可以直接使⽤ performance 中的 API\nconst obs = new PerformanceObserver((list, observer) =&gt; {\n    console.log(list.getEntries())\n    observer.disconnect()\n})\nobs.observe({ entryTypes: ['measure'], buffered: true })\nperformance.mark('start')\nlet number = 10000000\n// 不优化代码\n%NeverOptimizeFunction(test)\nwhile (number--) {\n    test(1)\n}\nperformance.mark('end')\nperformance.measure('test', 'start', 'end')</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">以上代码中我们使⽤了 performance API ，这个 API 在性能测试上⼗分好 ⽤。不仅可以⽤来测量代码的执⾏时间，还能⽤来测量各种⽹络连接中的时间 消耗等等，并且这个 API 也可以在浏览器中使</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">从上图中我们可以发现，优化过的代码执⾏时间只需要 9ms ，但是不优化过 的代码执⾏时间却是前者的⼆⼗倍，已经接近 200ms 了。在这个案例中，我 相信⼤家已经看到了 V8 的性能优化到底有多强，只需要我们符合⼀定的规 则书写代码，引擎底层就能帮助我们⾃动优化代码。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">另外，编译器还有个骚操作 Lazy-Compile ，当函数没有被执⾏的时候，会 对函数进⾏⼀次预解析，直到代码被执⾏以后才会被解析编译。对于上述代码 来说， test 函数需要被预解析⼀次，然后在调⽤的时候再被解析编译。但是 对于这种函数⻢上就被调⽤的情况来说，预解析这个过程其实是多余的，那么 有什么办法能够让代码不被预解析呢？</p>\n<pre class=\"language-javascript\"><code>(function test(obj) {\n    return x + x\n})</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">但是不可能我们为了性能优化，给所有的函数都去套上括号，并且也不是所有 函数都需要这样做。我们可以通过 optimize-js 实现这个功能，这个库会分 析⼀些函数的使⽤情况，然后给需要的函数添加括号，当然这个库很久没⼈维 护了，如果需要使⽤的话，还是需要测试过相关内容的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">其实很简单，我们只需要给函数套上括号就可以了</p>","rank_id":513,"createdAt":"2021-06-17T04:23:18.545Z","updatedAt":"2021-06-17T04:23:18.545Z","__v":0},{"_id":"60cacee610f3487f688ade8b","title":"WEB前端有哪些性能优化","code":"","type":"optimization","frequency":"low","difficulty":"easy","answers":"<h2 id=\"1-图优化\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">1 图⽚优化</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">计算图⽚⼤⼩</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">对于⼀张 100 * 100 像素的图⽚来说，图像上有 10000 个像素点，如果 每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每 个通道 1 个字节（ 8 位 = 1 个字节），所以该图⽚⼤⼩⼤概为 39KB （ 10000 * 1 * 4 / 1024 ）。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">但是在实际项⽬中，⼀张图⽚可能并不需要使⽤那么多颜⾊去显示，我们可以通过减少每 个像素的调⾊板来相应缩⼩图⽚的⼤⼩。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">了解了如何计算图⽚⼤⼩的知识，那么对于如何优化图⽚，想必⼤家已经有 2 个思路了：</span></p>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">减少像素点</span></li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\"><span style=\"font-size: 12pt;\">减少每个像素点能够显示的颜⾊</span></li>\n</ol>\n<h2 id=\"2-图加载优化\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">2 图⽚加载优化</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">不⽤图⽚。很多时候会使⽤到很多修饰类图⽚，其实这类修饰图⽚完全可以⽤ CSS 去代 替。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。⼀般图⽚都⽤ CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图⽚。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">⼩图使⽤ base64 格式</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">将多个图标⽂件整合到⼀张图⽚中（雪碧图）</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">选择正确的图⽚格式：</span></p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">对于能够显示 WebP 格式的浏览器尽量使⽤ WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更⼩的图⽚体积，⽽且拥有⾁眼识别⽆差异的图像质量，缺点就是兼容性并不好</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">⼩图使⽤ PNG ，其实对于⼤部分图标这类图⽚，完全可以使⽤ SVG 代替</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">照⽚使⽤ JPEG</span></p>\n</li>\n</ul>\n<h2 id=\"3-dns-预解析\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">3 DNS 预解析</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">DNS 解析也是需要时间的，可以通过预解析的⽅式来预先获得域名所对应的 IP 。</span></p>\n<pre class=\"language-markup\"><code>&lt;link rel=\"dns-prefetch\" href=\"//blog.poetries.top\"&gt;</code></pre>\n<h2 id=\"4-节流\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">4 节流</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">考虑⼀个场景，滚动事件中会发起⽹络请求，但是我们并不希望⽤户在滚动过 程中⼀直发起请求，⽽是隔⼀段时间发起⼀次，对于这种情况我们就可以使⽤ 节流。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">理解了节流的⽤途，我们就来实现下这个函数</span></p>\n<pre class=\"language-javascript\"><code>// func是⽤户传⼊需要防抖的函数\n// wait是等待时间\nconst throttle = (func, wait = 50) =&gt; {\n    // 上⼀次执⾏该函数的时间\n    let lastTime = 0\n    return function(...args) {\n        // 当前时间\n        let now = +new Date()\n        // 将当前时间和上⼀次执⾏函数时间对⽐\n        // 如果差值⼤于设置的等待时间就执⾏函数\n        if (now - lastTime &gt; wait) {\n            lastTime = now\n            func.apply(this, args)\n        }\n    }\n}\nsetInterval(\n    throttle(() =&gt; {\n        console.log(1)\n    }, 500),\n    1\n)</code></pre>\n<h2 id=\"5-防抖\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">5 防抖</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">考虑⼀个场景，有⼀个按钮点击会触发⽹络请求，但是我们并不希望每次点击 都发起⽹络请求，⽽是当⽤户点击按钮⼀段时间后没有再次点击的情况才去发 起⽹络请求，对于这种情况我们就可以使⽤防抖。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">理解了防抖的⽤途，我们就来实现下这个函数</span></p>\n<pre class=\"language-javascript\"><code>// func是⽤户传⼊需要防抖的函数\n// wait是等待时间\nconst debounce = (func, wait = 50) =&gt; {\n    // 缓存⼀个定时器id\n    let timer = 0\n    // 这⾥返回的函数是每次⽤户实际调⽤的防抖函数\n    // 如果已经设定过定时器了就清空上⼀次的定时器\n    // 开始⼀个新的定时器，延迟执⾏⽤户传⼊的⽅法\n    return function(...args) {\n        if (timer) clearTimeout(timer)\n        timer = setTimeout(() =&gt; {\n            func.apply(this, args)\n        }, wait)\n    }\n}</code></pre>\n<h2 id=\"6-预加载\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">6 预加载</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">在开发中，可能会遇到这样的情况。有些资源不需要⻢上⽤到，但是希望尽早获取，这时 候就可以使⽤预加载。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件， 可以使⽤以下代码开启预加载</span></p>\n<pre class=\"language-markup\"><code>&lt;link rel=\"preload\" href=\"http://blog.poetries.top\"&gt;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">预加载可以⼀定程度上降低⾸屏的加载时间，因为可以将⼀些不影响⾸屏但重 要的⽂件延后加载，唯⼀缺点就是兼容性不好。</span></p>\n<h2 id=\"7-预渲染\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">7 预渲染</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">可以通过预渲染将下载的⽂件预先在后台渲染，可以使⽤以下代码开启预渲染</span></p>\n<pre class=\"language-markup\"><code>&lt;link rel=\"prerender\" href=\"http://blog.poetries.top\"&gt;</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯⼤概率会被⽤户在之后打开，否则就是⽩⽩浪费资源去渲染。</span></p>\n<h2 id=\"8-懒执\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">8 懒执⾏</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">懒执⾏就是将某些逻辑延迟到使⽤时再计算。该技术可以⽤于⾸屏优化，对于 某些耗时逻辑并不需要在⾸屏就使⽤的，就可以使⽤懒执⾏。懒执⾏需要唤 醒，⼀般可以通过定时器或者事件的调⽤来唤醒。</span></p>\n<h2 id=\"9-懒加载\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">9 懒加载</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">懒加载就是将不关键的资源延后加载。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">懒加载的原理就是只加载⾃定义区域（通常是可视区域，但也可以是即将进⼊可视区域） 内需要加载的东⻄。对于图⽚来说，先设置图⽚标签的 src 属性为⼀张占位图，将真实 的图⽚资源放⼊⼀个⾃定义属性中，当进⼊⾃定义区域时，就将⾃定义属性替换为 src 属性，这样图⽚就会去下载资源，实现了图⽚懒加载。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">懒加载不仅可以⽤于图⽚，也可以使⽤在别的资源上。⽐如进⼊可视区域才开始播放视频 等等。</span></p>\n<h2 id=\"10-cdn\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">10 CDN</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">CDN 的原理是尽可能的在各个地⽅分布机房缓存数据，这样即使我们的根服 务器远在国外，在国内的⽤户也可以通过国内的机房迅速加载资源。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">因此，我们可以将静态资源尽量使⽤ CDN 加载，由于浏览器对于单个域名有 并发请求上限，可以考虑使⽤多个 CDN 域名。并且对于 CDN 加载静态资源 需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie ，平⽩消耗流量</span></p>","rank_id":514,"createdAt":"2021-06-17T04:26:14.791Z","updatedAt":"2021-06-17T04:26:14.791Z","__v":0},{"_id":"60cacf2f10f3487f688ade8c","title":"谈谈你对webpack的看法","code":"","type":"webpack/gulp","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">WebPack 是⼀个模块打包⼯具，你可以使⽤ WebPack 管理你的模块依赖，并编绎输出模 块们所需的静态⽂件。它能够很好地管理、打包 Web 开发中所⽤到的 HTML 、 Javascript 、 CSS 以及各种静态⽂件（图⽚、字体等），让开发过程更加⾼效。对于 不同类型的资源， webpack 有对应的模块加载器。 webpack 模块打包器会分析模块间的 依赖关系，最后 ⽣成了优化且合并后的静态资源</span></p>","rank_id":515,"createdAt":"2021-06-17T04:27:27.718Z","updatedAt":"2021-06-17T04:27:27.718Z","__v":0},{"_id":"60cacf4210f3487f688ade8d","title":"webpack 打包体积 优化思路","code":"","type":"webpack/gulp","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">提取第三⽅库或通过引⽤外部⽂件的⽅式引⼊第三⽅库</li>\n<li style=\"padding: 0px; margin: 0px;\">代码压缩插件 UglifyJsPlugin</li>\n<li style=\"padding: 0px; margin: 0px;\">服务器启⽤gzip压缩</li>\n<li style=\"padding: 0px; margin: 0px;\">按需加载资源⽂件 require.ensure</li>\n<li style=\"padding: 0px; margin: 0px;\">优化 devtool 中的 source-map</li>\n<li style=\"padding: 0px; margin: 0px;\">剥离 css ⽂件，单独打包</li>\n<li style=\"padding: 0px; margin: 0px;\">去除不必要插件，通常就是开发环境与⽣产环境⽤同⼀套配置⽂件导致</li>\n</ul>","rank_id":516,"createdAt":"2021-06-17T04:27:46.388Z","updatedAt":"2021-06-17T04:27:46.388Z","__v":0},{"_id":"60cacf5510f3487f688ade8e","title":"webpack 打包效率","code":"","type":"webpack/gulp","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">开发环境采⽤增量构建，启⽤热更新</li>\n<li style=\"padding: 0px; margin: 0px;\">开发环境不做⽆意义的⼯作如提取 css 计算⽂件hash等</li>\n<li style=\"padding: 0px; margin: 0px;\">配置 devtool</li>\n<li style=\"padding: 0px; margin: 0px;\">选择合适的 loader</li>\n<li style=\"padding: 0px; margin: 0px;\">个别 loader 开启 cache 如 babel-loader</li>\n<li style=\"padding: 0px; margin: 0px;\">第三⽅库采⽤引⼊⽅式</li>\n<li style=\"padding: 0px; margin: 0px;\">提取公共代码</li>\n<li style=\"padding: 0px; margin: 0px;\">优化构建时的搜索路径 指明需要构建⽬录及不需要构建⽬录</li>\n<li style=\"padding: 0px; margin: 0px;\">模块化引⼊需要的部分</li>\n</ul>","rank_id":517,"createdAt":"2021-06-17T04:28:05.300Z","updatedAt":"2021-06-17T04:28:05.300Z","__v":0},{"_id":"60cacf7410f3487f688ade8f","title":"webpack 编写⼀个loader","code":"","type":"webpack/gulp","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">loader 就是⼀个 node 模块，它输出了⼀个函数。当某种资源需要⽤这个 loader 转换时，这个函数会被调⽤。并且，这个函数可以通过提供给它的 this 上下⽂访问 Loader API 。 reverse-txt-loader</span></p>\n<pre class=\"language-javascript\"><code>// 定义\nmodule.exports = function(src) {\n    //src是原⽂件内容（abcde），下⾯对内容进⾏处理，这⾥是反转\n    var result = src.split('').reverse().join('');\n    //返回JavaScript源码，必须是String或者Buffer\n    return `module.exports = '${result}'`;\n}\n//使⽤\n{\n    test: /\\.txt$/,\n    use: [\n        {\n            './path/reverse-txt-loader'\n        }\n    ]\n},</code></pre>","rank_id":518,"createdAt":"2021-06-17T04:28:36.271Z","updatedAt":"2021-06-17T04:28:36.271Z","__v":0},{"_id":"60cacf8e10f3487f688ade90","title":"说⼀下webpack的⼀些plugin，怎么使⽤webpack对项⽬进⾏优化","code":"","type":"webpack/gulp","frequency":"low","difficulty":"easy","answers":"<h3 id=\"构建优化\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">构建优化</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">减少编译体积 ContextReplacementPugin 、 IgnorePlugin 、 babel-plugin-</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">import 、 babel-plugin-transform-runtime</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">并⾏编译 happypack 、 thread-loader 、 uglifyjsWebpackPlugin 开启并⾏</span></p>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\"><span style=\"font-size: 12pt;\">缓存 cache-loader 、 hard-source-webpack-plugin 、 uglifyjsWebpackPlugin 开启缓存、 babel-loader 开启缓存预编译 dllWebpackPlugin &amp;&amp; DllReferencePlugin 、 auto-dll-webapck-plugin</span></p>\n</li>\n</ul>\n<h3 id=\"性能优化\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">性能优化</span></h3>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">减少编译体积 Tree-shaking 、 Scope Hositing</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">hash 缓存 webpack-md5-plugin</span></li>\n<li style=\"padding: 0px; margin: 0px;\"><span style=\"font-size: 12pt;\">拆包 splitChunksPlugin 、 import() 、 require.ensure</span></li>\n</ul>","rank_id":519,"createdAt":"2021-06-17T04:29:02.764Z","updatedAt":"2021-06-17T04:29:02.764Z","__v":0},{"_id":"60cacfab10f3487f688ade91","title":"webpack 优化打包速度","code":"","type":"webpack/gulp","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">减少⽂件搜索范围\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px;\">\n<li style=\"padding: 0px; margin: 0px;\">⽐如通过别名</li>\n<li style=\"padding: 0px; margin: 0px;\">loader 的 test ， include &amp; exclude</li>\n</ul>\n</li>\n<li style=\"padding: 0px; margin: 0px;\">Webpack4 默认压缩并⾏</li>\n<li style=\"padding: 0px; margin: 0px;\">Happypack 并发调⽤</li>\n<li style=\"padding: 0px; margin: 0px;\">babel 也可以缓存编译</li>\n</ul>","rank_id":520,"createdAt":"2021-06-17T04:29:31.146Z","updatedAt":"2021-06-17T04:29:31.146Z","__v":0},{"_id":"60cacfc910f3487f688ade92","title":"webpack 如何实现⼀个插件","code":"","type":"webpack/gulp","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">调⽤插件 apply 函数传⼊ compiler 对象</li>\n<li style=\"padding: 0px; margin: 0px;\">通过 compiler 对象监听事件</li>\n</ul>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">⽐如你想实现⼀个编译结束退出命令的插件</p>\n<pre class=\"language-javascript\"><code>apply (compiler) {\n    const afterEmit = (compilation, cb) =&gt; {\n        cb()\n        setTimeout(function () {\n            process.exit(0)\n        }, 1000)\n    }\n    compiler.plugin('after-emit', afterEmit)\n}\n}\nmodule.exports = BuildEndPlugin</code></pre>","rank_id":521,"createdAt":"2021-06-17T04:30:01.157Z","updatedAt":"2021-06-17T04:30:01.157Z","__v":0},{"_id":"60cad0ba10f3487f688ade93","title":"Webpack 性能优化","code":"","type":"webpack/gulp","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">这部分的内容中，我们会聚焦于以下两个知识点，并且每⼀个知识点都属于⾼频考点：</p>\n<ul style=\"padding: 0px 0px 0px 34px; margin: 10px 0px 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px;\">有哪些⽅式可以减少 Webpack 的打包时间</li>\n<li style=\"padding: 0px; margin: 0px;\">有哪些⽅式可以让 Webpack 打出来的包更⼩</li>\n</ul>\n<h2 id=\"1-减少-webpack-打包时间\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">1 减少 Webpack 打包时间</h2>\n<h3 id=\"1-优化-loader\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">1. 优化 Loader</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于 Loader 来说，影响打包效率⾸当其冲必属 Babel 了。因为 Babel 会将代码转为字符串⽣成 AST ，然后对 AST 继续进⾏转变最后再⽣成新的 代码，项⽬越⼤，转换代码越多，效率就越低。当然了，我们是有办法优化的</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">⾸先我们可以优化 Loader 的⽂件搜索范围</p>\n<pre class=\"language-javascript\"><code>module.exports = {\n    module: {\n        rules: [\n            {\n                // js ⽂件才使⽤ babel\n                test: /\\.js$/,\n                loader: 'babel-loader',\n                // 只在 src ⽂件夹下查找\n                include: [resolve('src')],\n                // 不会去查找的路径\n                exclude: /node_modules/\n            }\n        ]\n    }\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于 Babel 来说，我们肯定是希望只作⽤在 JS 代码上的，然后 node_modules 中使⽤的代码都是编译过的，所以我们也完全没有必要再去 处理⼀遍</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当然这样做还不够，我们还可以将 Babel 编译过的⽂件缓存起来，下次只需要编译更改 过的代码⽂件即可，这样可以⼤幅度加快打包时间</p>\n<pre class=\"language-javascript\"><code>loader: 'babel-loader?cacheDirectory=true'</code></pre>\n<h3 id=\"2-happypack\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">2. HappyPack</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">受限于 Node 是单线程运⾏的，所以 Webpack 在打包的过程中也是单线程 的，特别是在执⾏ Loader 的时候，⻓时间编译的任务很多，这样就会导致 等待的情况。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">HappyPack 可以将 Loader 的同步执⾏转换为并⾏的，这样就能充分利⽤ 系统资源来加快打包效率了</p>\n<pre class=\"language-javascript\"><code>module: {\n    loaders: [\n        {\n            test: /\\.js$/,\n            include: [resolve('src')],\n            exclude: /node_modules/,\n            // id 后⾯的内容对应下⾯\n            loader: 'happypack/loader?id=happybabel'\n        }\n    ]\n    },\n    plugins: [\n        new HappyPack({\n            id: 'happybabel',\n            loaders: ['babel-loader?cacheDirectory'],\n            // 开启 4 个线程\n            threads: 4\n        })\n    ]</code></pre>\n<h3 id=\"3-dllplugin\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">3. DllPlugin</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">DllPlugin 可以将特定的类库提前打包然后引⼊。这种⽅式可以极⼤的减少 打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公 共代码抽离成单独⽂件的优化⽅案。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">接下来我们就来学习如何使⽤ DllPlugin</p>\n<pre class=\"language-javascript\"><code>// 单独配置在⼀个⽂件中\n// webpack.dll.conf.js\nconst path = require('path')\nconst webpack = require('webpack')\nmodule.exports = {\n    entry: {\n        // 想统⼀打包的类库\n        vendor: ['react']\n    },\n    output: {\n        path: path.join(__dirname, 'dist'),\n        filename: '[name].dll.js',\n        library: '[name]-[hash]'\n    },\n    plugins: [\n        new webpack.DllPlugin({\n        // name 必须和 output.library ⼀致\n        name: '[name]-[hash]',\n        // 该属性需要与 DllReferencePlugin 中⼀致\n        context: __dirname,\n        path: path.join(__dirname, 'dist', '[name]-manifest.json')\n        })\n    ]\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">然后我们需要执⾏这个配置⽂件⽣成依赖⽂件，接下来我们需要使⽤ DllReferencePlugin 将依赖⽂件引⼊项⽬中</span></p>\n<pre class=\"language-javascript\"><code>// webpack.conf.js\nmodule.exports = {\n    // ...省略其他配置\n    plugins: [\n        new webpack.DllReferencePlugin({\n            context: __dirname,\n            // manifest 就是之前打包出来的 json ⽂件\n            manifest: require('./dist/vendor-manifest.json'),\n        })\n    ]\n}</code></pre>\n<h3 id=\"4-代码压缩\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">4. 代码压缩</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在 Webpack3 中，我们⼀般使⽤ UglifyJS 来压缩代码，但是这个是单线 程运⾏的，为了加快效率，我们可以使⽤ webpack-parallel-uglify- plugin 来并⾏运⾏ UglifyJS ，从⽽提⾼效率。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化 ⽅案，当然我们不⽌可以压缩 JS 代码，还可以压缩 HTML 、 CSS 代码， 并且在压缩 JS 代码的过程中，我们还可以通过配置实现⽐如删除 console.log 这类代码的功能。</p>\n<h3 id=\"5-些的优化点\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">5. ⼀些⼩的优化点</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我们还可以通过⼀些⼩的优化点来加快打包速度</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">resolve.extensions ：⽤来表明⽂件后缀列表，默认查找顺序是&nbsp;<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">['.js','.json']</code>&nbsp;，如果你的导⼊⽂件没有添加后缀就会按照这个顺序查找⽂件。我们应该尽可能减少后缀列表⻓度，然后将出现频率⾼的后缀排在前⾯</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">resolve.alias ：可以通过别名的⽅式来映射⼀个路径，能让 Webpack 更快找到路径</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">module.noParse ：如果你确定⼀个⽂件下没有其他依赖，就可以使⽤该属性让Webpack 不扫描该⽂件，这种⽅式对于⼤型的类库很有帮助</p>\n<h2 id=\"2-减少-webpack-打包后的件体积\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">2 减少 Webpack 打包后的⽂件体积</h2>\n<h3 id=\"1-按需加载\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">1. 按需加载</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">想必⼤家在开发 SPA 项⽬的时候，项⽬中都会存在⼗⼏甚⾄更多的路由⻚ ⾯。如果我们将这些⻚⾯全部打包进⼀个 JS ⽂件的话，虽然将多个请求合并 了，但是同样也加载了很多并不需要的代码，耗费了更⻓的时间。那么为了⾸ ⻚能更快地呈现给⽤户，我们肯定是希望⾸⻚能加载的⽂件体积越⼩越好，这 时候我们就可以使⽤按需加载，将每个路由⻚⾯单独打包为⼀个⽂件。当然不 仅仅路由可以按需加载，对于 loadash 这种⼤型类库同样可以使⽤这个功 能。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">按需加载的代码实现这⾥就不详细展开了，因为鉴于⽤的框架不同，实现起来 都是不⼀样的。当然了，虽然他们的⽤法可能不同，但是底层的机制都是⼀样 的。都是当使⽤的时候再去下载对应⽂件，返回⼀个 Promise ，当 Promise 成功以后去执⾏回调。</p>\n<h3 id=\"2-scope-hoisting\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">2. Scope Hoisting</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模 块合并到⼀个函数中去。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">⽐如我们希望打包两个⽂件</p>\n<pre class=\"language-javascript\"><code>// test.js\nexport const a = 1\n// index.js\nimport { a } from './test.js'</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">对于这种情况，我们打包出来的代码会类似这样</span></p>\n<pre class=\"language-javascript\"><code>[\n    /* 0 */\n    function (module, exports, require) {\n        //...\n    },\n    /* 1 */\n    function (module, exports, require) {\n        //...\n    }\n]</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">但是如果我们使⽤ Scope Hoisting 的话，代码就会尽可能的合并到⼀个函 数中去，也就变成了这样的类似代码</span></p>\n<pre class=\"language-javascript\"><code>[\n    /* 0 */\n    function (module, exports, require) {\n    //...\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">这样的打包⽅式⽣成的代码明显⽐之前的少多了。如果在 Webpack4 中你希 望开启这个功能，只需要启⽤ optimization.concatenateModules 就可以 了。</span></p>\n<pre class=\"language-javascript\"><code>module.exports = {\n    optimization: {\n        concatenateModules: true\n    }</code></pre>\n<h3 id=\"3-tree-shaking\" style=\"padding: 0px; margin: 20px 0px 7px 8px; font-size: 20px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; color: #666666; letter-spacing: 3px; background-color: #ffffff;\">3. Tree Shaking</h3>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">Tree Shaking 可以实现删除项⽬中未被引⽤的代码，⽐如</p>\n<pre class=\"language-javascript\"><code>// test.js\nexport const a = 1\nexport const b = 2\n// index.js\nimport { a } from './test.js'</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于以上情况， test ⽂件中的变量 b 如果没有在项⽬中使⽤到的话，就不会被打包到 ⽂件中。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">如果你使⽤ Webpack 4 的话，开启⽣产环境就会⾃动启动这个优化功能。</p>","rank_id":522,"createdAt":"2021-06-17T04:34:02.941Z","updatedAt":"2021-06-17T04:34:02.941Z","__v":0},{"_id":"60caff6e10f3487f688ade94","title":"JavaScript 实现一个函数，完成超过范围的两个大整数相加功能","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>主要思路是通过将数字转换为字符串，然后每个字符串在按位相加。\nfunction bigNumberAdd(number1, number2) {\n    let result = \"\", // 保存最后结果\n    carry = false; // 保留进位结果\n    // 将字符串转换为数组\n    number1 = number1.split(\"\");\n    number2 = number2.split(\"\");\n    // 当数组的长度都变为0，并且最终不再进位时，结束循环\n    while (number1.length || number2.length || carry) {\n    // 每次将最后的数字进行相加，使用~~的好处是，即使返回值为 undefined 也能转换为 0\n    carry += ~~number1.pop() + ~~number2.pop();\n    // 取加法结果的个位加入最终结果\n    result = carry % 10 + result;\n    // 判断是否需要进位，true 和 false 的值在加法中会被转换为 1 和 0\n    carry = carry &gt; 9;\n    }\n    // 返回最终结果\n    return result;\n}</code></pre>","rank_id":523,"createdAt":"2021-06-17T07:53:18.692Z","updatedAt":"2021-06-17T07:53:18.692Z","__v":0},{"_id":"60cafffb10f3487f688ade95","title":"JavaScript 如何实现数组扁平化？","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>// 这一种方法通过递归来实现，当元素为数组时递归调用，兼容性好\nfunction flattenArray(array) {\n  if (!Array.isArray(array)) return;\n  let result = [];\n  result = array.reduce(function (pre, item) {\n    // 判断元素是否为数组，如果为数组则递归调用，如果不是则加入结果数组中\n    return pre.concat(Array.isArray(item) ? flattenArray(item) : item);\n  }, []);\n  return result;\n}\n// 这一种方法是利用了 toString 方法，\n//它的一个缺点是改变了元素的类型，只适合于数组中元素都是整数的情况\nfunction flattenArray(array) {\n  return array.toString().split(\",\").map(function (item) {\n    return +item;\n  })\n}</code></pre>","rank_id":524,"createdAt":"2021-06-17T07:55:39.185Z","updatedAt":"2021-06-17T07:55:39.185Z","__v":0},{"_id":"60cb002710f3487f688ade96","title":"JavaScript 如何实现数组去重？","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function unique(array) {\n  if (!Array.isArray(array) || array.length &lt;= 1) return;\n  var result = [];\n  array.forEach(function (item) {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  })\n  return result;\n}\nfunction unique(array) {\n  if (!Array.isArray(array) || array.length &lt;= 1) return;\n  return [...new Set(array)];\n}</code></pre>","rank_id":525,"createdAt":"2021-06-17T07:56:23.604Z","updatedAt":"2021-06-17T07:56:23.604Z","__v":0},{"_id":"60cb005110f3487f688ade97","title":"JavaScript 如何求数组的最大值和最小值？","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>var arr = [6, 4, 1, 8, 2, 11, 23];\nconsole.log(Math.max.apply(null, arr))</code></pre>","rank_id":526,"createdAt":"2021-06-17T07:57:05.473Z","updatedAt":"2021-06-17T07:57:05.473Z","__v":0},{"_id":"60cb00a410f3487f688ade98","title":"JavaScript 如何求两个数的最大公约数？","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">基本思想是采用辗转相除的方法，用大的数去除以小的那个数，然后再用小的数去除以的得到的余数，一直这样递归下去， 直到余数为0时，最后的被除数就是两个数的最大公约数。</span></p>\n<pre class=\"language-javascript\"><code>function getMaxCommonDivisor(a, b) {\n  if (b === 0) return a;\n  return getMaxCommonDivisor(b, a % b);\n}</code></pre>","rank_id":527,"createdAt":"2021-06-17T07:58:28.209Z","updatedAt":"2021-06-17T07:58:28.209Z","__v":0},{"_id":"60cb00e710f3487f688ade99","title":"JavaScript 如何求两个数的最小公倍数？","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>基本思想是采用将两个数相乘，然后除以它们的最大公约数\nfunction getMinCommonMultiple(a, b){\n  return a * b / getMaxCommonDivisor(a, b);\n}</code></pre>","rank_id":528,"createdAt":"2021-06-17T07:59:35.626Z","updatedAt":"2021-06-17T07:59:35.626Z","__v":0},{"_id":"60cb012710f3487f688ade9a","title":"JavaScript 实现 IndexOf 方法？","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function indexFun(array, val) {\n  if (!Array.isArray(array)) return;\n  let length = array.length;\n  for (let i = 0; i &lt; length; i++) {\n    if (array[i] === val) {\n      return i;\n    }\n  }\n  return -1;\n}  </code></pre>","rank_id":529,"createdAt":"2021-06-17T08:00:39.944Z","updatedAt":"2021-06-17T08:00:39.944Z","__v":0},{"_id":"60cb020f10f3487f688ade9b","title":"JavaScript 判断一个字符串是否为回文字符串？","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function isPalindrome(str) {\n  let reg = /[\\W_]/g, // 匹配所有非单词的字符以及下划线\n    newStr = str.replace(reg, \"\").toLowerCase(), // 替换为空字符并将大写字母转换为小写\n    reverseStr = newStr.split(\"\").reverse().join(\"\"); // 将字符串反转\n  return reverseStr === newStr;\n}</code></pre>","rank_id":530,"createdAt":"2021-06-17T08:04:31.045Z","updatedAt":"2021-06-17T08:04:31.045Z","__v":0},{"_id":"60cb023410f3487f688ade9c","title":"JavaScript 实现一个累加函数的功能比如 sum(1,2,3)(2).valueOf()","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function sum(...args) {\n  let result = 0;\n  result = args.reduce(function (pre, item) {\n    return pre + item;\n  }, 0);\n  let add = function (...args) {\n    result = args.reduce(function (pre, item) {\n      return pre + item;\n    }, result);\n    return add;\n  };\n  add.valueOf = function () {\n    console.log(result);\n  }\n  return add;\n}</code></pre>","rank_id":531,"createdAt":"2021-06-17T08:05:08.524Z","updatedAt":"2021-06-17T08:05:08.524Z","__v":0},{"_id":"60cb026410f3487f688ade9d","title":"JavaScript 使用 reduce 方法实现 forEach、map、filter","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>// forEach\nfunction forEachUseReduce(array, handler) {\n  array.reduce(function (pre, item, index) {\n    handler(item, index);\n  });\n}\n// map\nfunction mapUseReduce(array, handler) {\n  let result = [];\n  array.reduce(function (pre, item, index) {\n    let mapItem = handler(item, index);\n    result.push(mapItem);\n  });\n  return result;\n}\n// filter\nfunction filterUseReduce(array, handler) {\n  let result = [];\n  array.reduce(function (pre, item, index) {\n    if (handler(item, index)) {\n      result.push(item);\n    }\n  });\n  return result;\n}</code></pre>","rank_id":532,"createdAt":"2021-06-17T08:05:56.073Z","updatedAt":"2021-06-17T08:05:56.073Z","__v":0},{"_id":"60cb028810f3487f688ade9e","title":"JavaScript 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 \"1\", \"2\", \"3\"","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>class Queue {\n  constructor() {\n    this.queue = [];\n    this.time = 0;\n  }\n  addTask(task, t) {\n    this.time += t;\n    this.queue.push([task, this.time]);\n    return this;\n  }\n  start() {\n    this.queue.forEach(item =&gt; {\n      setTimeout(() =&gt; {\n        item[0]();\n      }, item[1]);\n    })\n  }\n}</code></pre>","rank_id":533,"createdAt":"2021-06-17T08:06:32.129Z","updatedAt":"2021-06-17T08:06:32.129Z","__v":0},{"_id":"60cb02bd10f3487f688ade9f","title":"JavaScript 如何查找一篇英文文章中出现频率最高的单词？","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<pre class=\"language-javascript\"><code>function findMostWord(article) {\n// 合法性判断\nif (!article) return;\n// 参数处理\narticle = article.trim().toLowerCase();\nlet wordList = article.match(/[a-z]+/g),\n  visited = [],\n  maxNum = 0,\n  maxWord = \"\";\narticle = \" \" + wordList.join(\"  \") + \" \";\n// 遍历判断单词出现次数\nwordList.forEach(function (item) {\n  if (visited.indexOf(item) &lt; 0) {\n    let word = new RegExp(\" \" + item + \" \", \"g\"),\n      num = article.match(word).length;\n    if (num &gt; maxNum) {\n      maxNum = num;\n      maxWord = item;\n    }\n  }\n});\nreturn maxWord + \"  \" + maxNum;\n}</code></pre>","rank_id":534,"createdAt":"2021-06-17T08:07:25.306Z","updatedAt":"2021-06-17T08:07:25.306Z","__v":0},{"_id":"60cb02e710f3487f688adea0","title":"JavaScript 明星问题","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ol class=\"linenums\" style=\"padding: 0px 0px 0px 10px; margin: 0px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace; font-size: 14px; color: #495666; white-space: pre;\">\n<li class=\"L0\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">题目：</span></code></li>\n<li class=\"L1\" style=\"padding: 0px; margin: 0px; background-image: initial; background-position: 0px 0px; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"></code></li>\n<li class=\"L2\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">有</span><span class=\"pln\" style=\"color: #000000;\"> n </span><span class=\"pun\" style=\"color: #666600;\">个人，其中一个明星和</span><span class=\"pln\" style=\"color: #000000;\"> n</span><span class=\"pun\" style=\"color: #666600;\">-</span><span class=\"lit\" style=\"color: #006666;\">1</span><span class=\"pln\" style=\"color: #000000;\"> </span><span class=\"pun\" style=\"color: #666600;\">个群众，群众都认识明星，明星不认识任何群众，群众和群众之间的认识关系不知道，现有一个</span></code></li>\n<li class=\"L3\" style=\"padding: 0px; margin: 0px; background-image: initial; background-position: 0px 0px; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">函数</span><span class=\"pln\" style=\"color: #000000;\"> foo</span><span class=\"pun\" style=\"color: #666600;\">(</span><span class=\"pln\" style=\"color: #000000;\">A</span><span class=\"pun\" style=\"color: #666600;\">,</span><span class=\"pln\" style=\"color: #000000;\"> B</span><span class=\"pun\" style=\"color: #666600;\">)，若</span><span class=\"pln\" style=\"color: #000000;\"> A </span><span class=\"pun\" style=\"color: #666600;\">认识</span><span class=\"pln\" style=\"color: #000000;\"> B </span><span class=\"pun\" style=\"color: #666600;\">返回</span><span class=\"pln\" style=\"color: #000000;\"> </span><span class=\"kwd\" style=\"color: #000088;\">true</span><span class=\"pun\" style=\"color: #666600;\">，若</span><span class=\"pln\" style=\"color: #000000;\"> A </span><span class=\"pun\" style=\"color: #666600;\">不认识</span><span class=\"pln\" style=\"color: #000000;\"> B </span><span class=\"pun\" style=\"color: #666600;\">返回</span><span class=\"pln\" style=\"color: #000000;\"> </span><span class=\"kwd\" style=\"color: #000088;\">false</span><span class=\"pun\" style=\"color: #666600;\">，试设计一种算法找出明星，并给出时间复杂度。</span></code></li>\n<li class=\"L4\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"></code></li>\n<li class=\"L5\" style=\"padding: 0px; margin: 0px; background-image: initial; background-position: 0px 0px; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"></code></li>\n<li class=\"L6\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">思路：</span></code></li>\n<li class=\"L7\" style=\"padding: 0px; margin: 0px; background-image: initial; background-position: 0px 0px; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"></code></li>\n<li class=\"L8\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">（</span><span class=\"lit\" style=\"color: #006666;\">1</span><span class=\"pun\" style=\"color: #666600;\">）第一种方法我们可以直接使用双层循环遍历的方式，每一个人都和其他人进行判断，如果一个人谁都不认识，那么他就是明星。</span></code></li>\n<li class=\"L9\" style=\"padding: 0px; margin: 0px; background-image: initial; background-position: 0px 0px; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pln\" style=\"color: #000000;\">    </span><span class=\"pun\" style=\"color: #666600;\">这一种方法的时间复杂度为</span><span class=\"pln\" style=\"color: #000000;\"> O</span><span class=\"pun\" style=\"color: #666600;\">(</span><span class=\"pln\" style=\"color: #000000;\">n</span><span class=\"pun\" style=\"color: #666600;\">^</span><span class=\"lit\" style=\"color: #006666;\">2</span><span class=\"pun\" style=\"color: #666600;\">)。</span></code></li>\n<li class=\"L0\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"></code></li>\n<li class=\"L1\" style=\"padding: 0px; margin: 0px; background-image: initial; background-position: 0px 0px; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pun\" style=\"color: #666600;\">（</span><span class=\"lit\" style=\"color: #006666;\">2</span><span class=\"pun\" style=\"color: #666600;\">）上一种方法没有充分利用题目所给的条件，其实我们每一次比较，都可以排除一个人的可能。比如如果</span><span class=\"pln\" style=\"color: #000000;\"> A </span><span class=\"pun\" style=\"color: #666600;\">认识</span><span class=\"pln\" style=\"color: #000000;\"> B</span><span class=\"pun\" style=\"color: #666600;\">，那么说明</span></code></li>\n<li class=\"L2\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pln\" style=\"color: #000000;\">    A </span><span class=\"pun\" style=\"color: #666600;\">就不会是明星，因此</span><span class=\"pln\" style=\"color: #000000;\"> A </span><span class=\"pun\" style=\"color: #666600;\">就可以从数组中移除。如果</span><span class=\"pln\" style=\"color: #000000;\"> A </span><span class=\"pun\" style=\"color: #666600;\">不认识</span><span class=\"pln\" style=\"color: #000000;\"> B</span><span class=\"pun\" style=\"color: #666600;\">，那么说明</span><span class=\"pln\" style=\"color: #000000;\"> B </span><span class=\"pun\" style=\"color: #666600;\">不可能是明星，因此</span><span class=\"pln\" style=\"color: #000000;\"> B </span><span class=\"pun\" style=\"color: #666600;\">就可以从数组中移</span></code></li>\n<li class=\"L3\" style=\"padding: 0px; margin: 0px; background-image: initial; background-position: 0px 0px; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pln\" style=\"color: #000000;\">    </span><span class=\"pun\" style=\"color: #666600;\">除。因此每一次判断都能够减少一个可能性，我们只需要从数组从前往后进行遍历，每次移除一个不可能的人，直到数组中只剩</span></code></li>\n<li class=\"L4\" style=\"padding: 0px; margin: 0px; color: #b4b4b4; line-height: 20px; list-style: none; overflow-wrap: break-word;\"><code style=\"border-radius: 3px; padding: 2px 5px; border: 0px transparent; margin: 0px 2px; font-family: 'Droid Sans Mono', 'CPMono_v07 Bold', 'Droid Sans', Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace, monospace;\"><span class=\"pln\" style=\"color: #000000;\">    </span><span class=\"pun\" style=\"color: #666600;\">一人为止，那么这个人就是明星。这一种方法的时间复杂度为</span><span class=\"pln\" style=\"color: #000000;\"> O</span><span class=\"pun\" style=\"color: #666600;\">(</span><span class=\"pln\" style=\"color: #000000;\">n</span><span class=\"pun\" style=\"color: #666600;\">)。</span></code></li>\n</ol>","rank_id":535,"createdAt":"2021-06-17T08:08:07.923Z","updatedAt":"2021-06-17T08:08:07.923Z","__v":0},{"_id":"60cb030810f3487f688adea1","title":"JavaScript 正负数组求和","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<h2 id=\"正负数组求和\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">正负数组求和</span></h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">题目：</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">有两个数组，一个数组里存放的是正整数，另一个数组里存放的是负整数，都是无序的，现在从两个数组里各拿一个，使得它们的和 最接近零。</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">思路：</span></p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">（1）首先我们可以对两个数组分别进行排序，正数数组按从小到大排序，负数数组按从大到小排序。排序完成后我们使用两个指针分 别指向两个数组的首部，判断两个指针的和。如果和大于0，则负数指针往后移动一个位置，如果和小于0，则正数指针往后移动 一个位置，每一次记录和的值，和当前保存下来的最小值进行比较。</span></p>","rank_id":536,"createdAt":"2021-06-17T08:08:40.386Z","updatedAt":"2021-06-17T08:08:40.386Z","__v":0},{"_id":"60cb033e10f3487f688adea2","title":"JavaScript 冒泡排序","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素&ldquo;浮&rdquo;到顶端，最终达到完全有序。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">代码实现：</p>\n<pre class=\"language-javascript\"><code>function bubbleSort(arr) {\n    if (!Array.isArray(arr) || arr.length &lt;= 1) return;\n    let lastIndex = arr.length - 1;\n    while (lastIndex &gt; 0) { // 当最后一个交换的元素为第一个时，说明后面全部排序完毕\n        let flag = true, k = lastIndex;\n        for (let j = 0; j &lt; k; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                flag = false;\n              \tlastIndex = j; // 设置最后一次交换元素的位置\n                [arr[j], arr[j+1]] = [arr[j+1], arr[j]];\n            }\n        }\n      \tif (flag) break;\n    }\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">冒泡排序有两种优化方式。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一种是外层循环的优化，我们可以记录当前循环中是否发生了交换，如果没有发生交换，则说明该序列已经为有序序列了。 因此我们不需要再执行之后的外层循环，此时可以直接结束。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">一种是内层循环的优化，我们可以记录当前循环中最后一次元素交换的位置，该位置以后的序列都是已排好的序列，因此下 一轮循环中无需再去比较。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">优化后的冒泡排序，当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">冒泡排序的平均时间复杂度为 O(n&sup2;) ，最坏时间复杂度为 O(n&sup2;) ，空间复杂度为 O(1) ，是稳定排序。</p>","rank_id":537,"createdAt":"2021-06-17T08:09:34.811Z","updatedAt":"2021-06-17T08:09:34.811Z","__v":0},{"_id":"60cb037810f3487f688adea3","title":"JavaScript 选择排序","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">选择排序的基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在算法实现时，每一趟确定最小元素的时候会通过不断地比较交换来使得首位置为当前最小，交换是个比较耗时的操作。其实 我们很容易发现，在还未完全确定当前最小元素之前，这些交换都是无意义的。我们可以通过设置一个变量 min，每一次比较 仅存储较小元素的数组下标，当轮循环结束之后，那这个变量存储的就是当前最小元素的下标，此时再执行交换操作即可。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">代码实现：</p>\n<pre class=\"language-javascript\"><code>function selectSort(array) {\n  let length = array.length;\n  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 \n  if (!Array.isArray(array) || length &lt;= 1) return;\n  for (let i = 0; i &lt; length - 1; i++) {\n    let minIndex = i; // 设置当前循环最小元素索引\n    for (let j = i + 1; j &lt; length; j++) {\n      // 如果当前元素比最小元素索引，则更新最小元素索引\n      if (array[minIndex] &gt; array[j]) {\n        minIndex = j;\n      }\n    }\n    // 交换最小元素到当前位置\n    // [array[i], array[minIndex]] = [array[minIndex], array[i]];\n    swap(array, i, minIndex);\n  }\n  return array;\n}\n// 交换数组中两个元素的位置\nfunction swap(array, left, right) {\n  var temp = array[left];\n  array[left] = array[right];\n  array[right] = temp;\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">选择排序不管初始序列是否有序，时间复杂度都为 O(n&sup2;)。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">选择排序的平均时间复杂度为 O(n&sup2;) ，最坏时间复杂度为 O(n&sup2;) ，空间复杂度为 O(1) ，不是稳定排序。</p>","rank_id":538,"createdAt":"2021-06-17T08:10:32.112Z","updatedAt":"2021-06-17T08:10:32.112Z","__v":0},{"_id":"60cb03ad10f3487f688adea4","title":"JavaScript 插入排序","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的有序序列中去，直到插完所有元素为止。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">插入排序核心&ndash;扑克牌思想： 就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边， 继续接，可能是中间数，就插在中间&hellip;.依次</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">代码实现：</p>\n<pre class=\"language-javascript\"><code>function insertSort(array) {\n  let length = array.length;\n  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 \n  if (!Array.isArray(array) || length &lt;= 1) return;\n  // 循环从 1 开始，0 位置为默认的已排序的序列\n  for (let i = 1; i &lt; length; i++) {\n    let temp = array[i]; // 保存当前需要排序的元素\n    let j = i;\n    // 在当前已排序序列中比较，如果比需要排序的元素大，就依次往后移动位置\n    while (j -1 &gt;= 0 &amp;&amp; array[j - 1] &gt; temp) {\n      array[j] = array[j - 1];\n      j--;\n    }\n    // 将找到的位置插入元素\n    array[j] = temp;\n  }\n  return array;\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">当排序序列为已排序序列时，为最好的时间复杂度 O(n)。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">插入排序的平均时间复杂度为 O(n&sup2;) ，最坏时间复杂度为 O(n&sup2;) ，空间复杂度为 O(1) ，是稳定排序。</p>","rank_id":539,"createdAt":"2021-06-17T08:11:25.450Z","updatedAt":"2021-06-17T08:11:25.450Z","__v":0},{"_id":"60cb03d810f3487f688adea5","title":"JavaScript 希尔排序","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">希尔排序的基本思想是把数组按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的元 素越来越多，当增量减至1时，整个数组恰被分成一组，算法便终止。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">代码实现：</p>\n<pre class=\"language-javascript\"><code>function hillSort(array) {\n  let length = array.length;\n  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 \n  if (!Array.isArray(array) || length &lt;= 1) return;\n  // 第一层确定增量的大小，每次增量的大小减半\n  for (let gap = parseInt(length &gt;&gt; 1); gap &gt;= 1; gap = parseInt(gap &gt;&gt; 1)) {\n    // 对每个分组使用插入排序，相当于将插入排序的1换成了 n\n    for (let i = gap; i &lt; length; i++) {\n      let temp = array[i];\n      let j = i;\n      while (j - gap &gt;= 0 &amp;&amp; array[j - gap] &gt; temp) {\n        array[j] = array[j - gap];\n        j -= gap;\n      }\n      array[j] = temp;\n    }\n  }\n  return array;\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">希尔排序是利用了插入排序对于已排序序列排序效果最好的特点，在一开始序列为无序序列时，将序列分为多个小的分组进行 基数排序，由于排序基数小，每次基数排序的效果较好，然后在逐步增大增量，将分组的大小增大，由于每一次都是基于上一 次排序后的结果，所以每一次都可以看做是一个基本排序的序列，所以能够最大化插入排序的优点。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">简单来说就是，由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序， 所以排序速度也很快。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">希尔排序的时间复杂度根据选择的增量序列不同而不同，但总的来说时间复杂度是小于 O(n^2) 的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">插入排序是一个稳定排序，但是在希尔排序中，由于相同的元素可能在不同的分组中，所以可能会造成相同元素位置的变化， 所以希尔排序是一个不稳定的排序。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">希尔排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n^s) ，空间复杂度为 O(1) ，不是稳定排序。</p>","rank_id":540,"createdAt":"2021-06-17T08:12:08.283Z","updatedAt":"2021-06-17T08:12:08.283Z","__v":0},{"_id":"60cb041e10f3487f688adea6","title":"JavaScript 归并排序","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后 将数组排序合并，最终合并为排序好的数组。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">代码实现：</p>\n<pre class=\"language-javascript\"><code>function mergeSort(array) {\n  let length = array.length;\n  // 如果不是数组或者数组长度小于等于0，直接返回，不需要排序 \n  if (!Array.isArray(array) || length === 0) return;\n  if (length === 1) {\n    return array;\n  }\n  let mid = parseInt(length &gt;&gt; 1), // 找到中间索引值\n    left = array.slice(0, mid), // 截取左半部分\n    right = array.slice(mid, length); // 截取右半部分\n  return merge(mergeSort(left), mergeSort(right)); // 递归分解后，进行排序合并\n}\nfunction merge(leftArray, rightArray) {\n  let result = [],\n    leftLength = leftArray.length,\n    rightLength = rightArray.length,\n    il = 0,\n    ir = 0;\n  // 左右两个数组的元素依次比较，将较小的元素加入结果数组中，直到其中一个数组的元素全部加入完则停止\n  while (il &lt; leftLength &amp;&amp; ir &lt; rightLength) {\n    if (leftArray[il] &lt; rightArray[ir]) {\n      result.push(leftArray[il++]);\n    } else {\n      result.push(rightArray[ir++]);\n    }\n  }\n  // 如果是左边数组还有剩余，则把剩余的元素全部加入到结果数组中。\n  while (il &lt; leftLength) {\n    result.push(leftArray[il++]);\n  }\n  // 如果是右边数组还有剩余，则把剩余的元素全部加入到结果数组中。\n  while (ir &lt; rightLength) {\n    result.push(rightArray[ir++]);\n  }\n  return result;\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">归并排序将整个排序序列看成一个二叉树进行分解，首先将树分解到每一个子节点，树的每一层都是一个归并排序的过程，每 一层归并的时间复杂度为 O(n)，因为整个树的高度为 lgn，所以归并排序的时间复杂度不管在什么情况下都为O(nlogn)。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">归并排序的空间复杂度取决于递归的深度和用于归并时的临时数组，所以递归的深度为 logn，临时数组的大小为 n，所以归 并排序的空间复杂度为 O(n)。</p>\n<div class=\"google-auto-placed ap_container\" style=\"padding: 0px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff; width: 870px; height: auto; clear: both; text-align: center;\"><ins class=\"adsbygoogle adsbygoogle-noablate\" style=\"display: block; margin: auto; background-color: transparent; height: 0px;\" data-ad-format=\"auto\" data-ad-client=\"ca-pub-3504340093271389\" data-adsbygoogle-status=\"done\" data-ad-status=\"unfilled\"><ins id=\"aswift_3_expand\" style=\"display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent;\" tabindex=\"0\" title=\"Advertisement\" aria-label=\"Advertisement\"><ins id=\"aswift_3_anchor\" style=\"display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 870px; background-color: transparent; overflow: hidden; opacity: 0;\"><iframe id=\"aswift_3\" style=\"left: 0px; position: absolute; top: 0px; border-width: 0px; border-style: initial; width: 870px; height: 0px;\" src=\"https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-3504340093271389&amp;output=html&amp;h=280&amp;adk=109321987&amp;adf=970835177&amp;pi=t.aa~a.2817947589~i.10~rp.4&amp;w=870&amp;fwrn=4&amp;fwrnh=100&amp;lmt=1622810666&amp;num_ads=1&amp;rafmt=1&amp;armr=3&amp;sem=mc&amp;pwprc=9523024247&amp;psa=1&amp;ad_type=text_image&amp;format=870x280&amp;url=https%3A%2F%2Fwww.axihe.com%2Ffocus%2Flogic%2Fsort%2F06.html&amp;flash=0&amp;fwr=0&amp;pra=3&amp;rh=200&amp;rw=870&amp;rpe=1&amp;resp_fmts=3&amp;wgl=1&amp;fa=27&amp;uach=WyJXaW5kb3dzIiwiMTAuMCIsIng4NiIsIiIsIjkxLjAuNDQ3Mi4xMDYiLFtdXQ..&amp;dt=1623917533324&amp;bpp=1&amp;bdt=263&amp;idt=1&amp;shv=r20210615&amp;cbv=%2Fr20110914&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;cookie=ID%3Dc42b20e6ee6efa3d-221193c456c90083%3AT%3D1623293344%3ART%3D1623293344%3AS%3DALNI_MbzQJ6BWGNxs0oRE7-tp-4q8E74oA&amp;prev_fmts=0x0%2C878x280%2C890x280&amp;nras=2&amp;correlator=2078635789068&amp;frm=20&amp;pv=1&amp;ga_vid=959155095.1623917533&amp;ga_sid=1623917533&amp;ga_hid=1713718176&amp;ga_fc=0&amp;u_tz=480&amp;u_his=4&amp;u_java=0&amp;u_h=864&amp;u_w=1536&amp;u_ah=824&amp;u_aw=1536&amp;u_cd=24&amp;u_nplug=3&amp;u_nmime=4&amp;adx=325&amp;ady=1787&amp;biw=1519&amp;bih=722&amp;scr_x=0&amp;scr_y=0&amp;eid=31060615%2C31060975&amp;oid=3&amp;pvsid=3217542017464996&amp;pem=199&amp;ref=https%3A%2F%2Fwww.axihe.com%2Fmap%2Flogic-focus.html&amp;eae=0&amp;fc=1408&amp;brdim=0%2C0%2C0%2C0%2C1536%2C0%2C1536%2C824%2C1536%2C722&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=128&amp;bc=31&amp;ifi=4&amp;uci=a!4&amp;btvi=2&amp;fsb=1&amp;xpc=erAK3D6Zzk&amp;p=https%3A//www.axihe.com&amp;dtd=15\" name=\"aswift_3\" width=\"870\" height=\"0\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" sandbox=\"allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation\" allowfullscreen=\"allowfullscreen\" data-google-container-id=\"a!4\" data-load-complete=\"true\" data-google-query-id=\"CKnx-Z2cnvECFa3BFgUdQDsHrQ\"></iframe></ins></ins></ins></div>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">归并排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(n) ，是稳定排序。</p>","rank_id":541,"createdAt":"2021-06-17T08:13:18.921Z","updatedAt":"2021-06-17T08:13:18.921Z","__v":0},{"_id":"60cb046010f3487f688adea7","title":"JavaScript 堆排序","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行 交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行， 便能得到一个有序序列了。</span></p>\n<pre class=\"language-javascript\"><code>function heapSort(array) {\n  let length = array.length;\n  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 \n  if (!Array.isArray(array) || length &lt;= 1) return;\n  buildMaxHeap(array); // 将传入的数组建立为大顶堆\n  // 每次循环，将最大的元素与末尾元素交换，然后剩下的元素重新构建为大顶堆\n  for (let i = length - 1; i &gt; 0; i--) {\n    swap(array, 0, i);\n    adjustMaxHeap(array, 0, i); // 将剩下的元素重新构建为大顶堆\n  }\n  return array;\n}\nfunction adjustMaxHeap(array, index, heapSize) {\n  let iMax,\n    iLeft,\n    iRight;\n  while (true) {\n    iMax = index; // 保存最大值的索引\n    iLeft = 2 * index + 1; // 获取左子元素的索引\n    iRight = 2 * index + 2; // 获取右子元素的索引\n    // 如果左子元素存在，且左子元素大于最大值，则更新最大值索引\n    if (iLeft &lt; heapSize &amp;&amp; array[iMax] &lt; array[iLeft]) {\n      iMax = iLeft;\n    }\n    // 如果右子元素存在，且右子元素大于最大值，则更新最大值索引\n    if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) {\n      iMax = iRight;\n    }\n    // 如果最大元素被更新了，则交换位置，使父节点大于它的子节点，\n//同时将索引值跟新为被替换的值，继续检查它的子树\n    if (iMax !== index) {\n      swap(array, index, iMax);\n      index = iMax;\n    } else {\n      // 如果未被更新，说明该子树满足大顶堆的要求，退出循环\n      break;\n    }\n  }\n}\n// 构建大顶堆\nfunction buildMaxHeap(array) {\n  let length = array.length,\n    iParent = parseInt(length &gt;&gt; 1) - 1; // 获取最后一个非叶子点的元素\n  for (let i = iParent; i &gt;= 0; i--) {\n    adjustMaxHeap(array, i, length); // 循环调整每一个子树，使其满足大顶堆的要求\n  }\n}\n// 交换数组中两个元素的位置\nfunction swap(array, i, j) {\n  let temp = array[i];\n  array[i] = array[j];\n  array[j] = temp;\n}</code></pre>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">建立堆的时间复杂度为 O(n)，排序循环的次数为 n-1，每次调整堆的时间复杂度为 O(logn)，因此堆排序的时间复杂度在 不管什么情况下都是 O(nlogn)。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">堆排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复杂度为 O(1) ，不是稳定排序。</p>","rank_id":542,"createdAt":"2021-06-17T08:14:24.583Z","updatedAt":"2021-06-17T08:14:24.583Z","__v":0},{"_id":"60cb048610f3487f688adea8","title":"JavaScript 基数排序","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程：将 所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样 从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">代码实现：</p>\n<pre class=\"language-javascript\"><code>function radixSort(array) {\n  let length = array.length;\n  // 如果不是数组或者数组长度小于等于1，直接返回，不需要排序 \n  if (!Array.isArray(array) || length &lt;= 1) return;\n  let bucket = [],\n    max = array[0],\n    loop;\n  // 确定排序数组中的最大值\n  for (let i = 1; i &lt; length; i++) {\n    if (array[i] &gt; max) {\n      max = array[i];\n    }\n  }\n  // 确定最大值的位数\n  loop = (max + '').length;\n  // 初始化桶\n  for (let i = 0; i &lt; 10; i++) {\n    bucket[i] = [];\n  }\n  for (let i = 0; i &lt; loop; i++) {\n    for (let j = 0; j &lt; length; j++) {\n      let str = array[j] + '';\n      if (str.length &gt;= i + 1) {\n        let k = parseInt(str[str.length - 1 - i]); // 获取当前位的值，作为插入的索引\n        bucket[k].push(array[j]);\n      } else {\n        // 处理位数不够的情况，高位默认为 0\n        bucket[0].push(array[j]);\n      }\n    }\n    array.splice(0, length); // 清空旧的数组\n    // 使用桶重新初始化数组\n    for (let i = 0; i &lt; 10; i++) {\n      let t = bucket[i].length;\n      for (let j = 0; j &lt; t; j++) {\n        array.push(bucket[i][j]);\n      }\n      bucket[i] = [];\n    }\n  }\n  return array;\n}</code></pre>\n<p><span style=\"color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">基数排序的平均时间复杂度为 O(nk)，k 为最大元素的长度，最坏时间复杂度为 O(nk)，空间复杂度为 O(n) ，是稳定 排序。</span></p>","rank_id":543,"createdAt":"2021-06-17T08:15:02.064Z","updatedAt":"2021-06-17T08:15:02.064Z","__v":0},{"_id":"60cb04ab10f3487f688adea9","title":"JavaScript 快速排序相对于其他排序效率更高的原因","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">在实际使用中，应用最广泛的是快速排序。快速排序相对于其他排序算法的优势在于在相同 数据量的情况下，它的运算效率最高，并且它额外所需空间最小。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">我们首先从时间复杂度来判断，由于前面几种方法的时间复杂度平均情况下基本趋向于 O(n&sup2;)，因此只从时间复杂度上来看 的话，显然归并排序、堆排序和快速排序的时间复杂度最小。但是既然这几种方法的时间复杂度基本一致，并且快速排序在最 坏情况下时间的复杂度还会变为 O(n&sup2;)，那么为什么它的效率反而更高呢？</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">首先在对大数据量排序的时候，由于归并排序的空间复杂度为 O(n)，因此归并排序在这种情况下会需要过多的额外内存，因 此归并排序首先就被排除掉了。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">接下来就剩下了堆排序和快速排序的比较。我认为堆排序相对于快速排序的效率不高的原因有两个方面。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">第一个方面是对于比较操作的有效性来说。对于快速排序来说，每一次元素的比较都会确定该元素在数组中的位置，也就是在 枢纽值的左边或者右边，快速排序的每一次比较操作都是有意义的结果。而对于堆排序来说，在每一次重新调整堆的时候，我 们在迭代时，已经知道上层的节点值一定比下层的节点值大，因此当我们每次为了打乱堆结构而将最后一个元素与堆顶元素互 换时，互换后的元素一定是比下层元素小的，因此我们知道比较结果却还要在堆结构调整时去进行再一次的比较，这样的比较 是没有意义的，以此在堆排序中会产生大量的没有意义的比较操作。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">第二个方面是对于缓存局部性原理的利用上来考虑的，我认为这应该是造成堆排序的效率不如快速排序的主要原因。在计算机 中利用了多级缓存的机制，来解决 cpu 计算速度与存储器数据读取速度间差距过大的问题。缓存的原理主要是基于局部性原 理，局部性原理简单来说就是，当前被访问过的数据，很有可能在一段时间内被再次访问，这被称为时间局部性。还有就是当 前访问的数据，那么它相邻的数据，也有可能在一段时间内被访问到，这被称为空间局部性。计算机缓存利用了局部性的原理 来对数据进行缓存，来尽可能少的减少磁盘的 I/O 次数，以此来提高执行效率。对于堆排序来说，它最大的问题就是它对于 空间局部性的违背，它在进行比较时，比较的并不是相邻的元素，而是与自己相隔很远的元素，这对于利用空间局部性来进行 数据缓存的计算机来说，它的很多缓存都是无效的。并且对于大数据量的排序来说，缓存的命中率就会变得很低，因此会明显 提高磁盘的 I/O 次数，并且由于堆排序的大量的无效比较，因此这样就造成了堆排序执行效率的低下。而相对来快速排序来 说，它的排序每一次都是在相邻范围内的比较，并且比较的范围越来越小，它很好的利用了局部性原理，因此它的执行效率更 高。简单来说就是在堆排序中获取一个元素的值所花费的时间比在快速排序获取一个元素的值所花费的时间要大。因此我们可 以看出，时间复杂度类似的算法，在计算机中实际执行可能会有很大的差别，因为决定算法执行效率的还有内存读取这样的其 他的因素。</p>","rank_id":544,"createdAt":"2021-06-17T08:15:39.040Z","updatedAt":"2021-06-17T08:15:39.040Z","__v":0},{"_id":"60cb04c110f3487f688adeaa","title":"JavaScript 排序面试题目总结","code":"","type":"algorithm","frequency":"low","difficulty":"easy","answers":"<h2 id=\"系统自带排序实现\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">系统自带排序实现</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">每个语言的排序内部实现都是不同的。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据 量很小的情况下和 O(N * logN) 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p>\n<h2 id=\"稳定性\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">稳定性</h2>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">稳定性的意思就是对于相同值来说，相对顺序不能改变。通俗的讲有两个相同的数 A 和 B，在排序之前 A 在 B 的前面， 而经过排序之后，B 跑到了 A 的前面，对于这种情况的发生，我们管他叫做排序的不稳定性。</p>\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; line-height: 28px; color: #495666; font-size: 16px; background-color: #ffffff;\">稳定性有什么意义？个人理解对于前端来说，比如我们熟知框架中的虚拟 DOM 的比较，我们对一个<code style=\"border-radius: 3px; padding: 2px 5px; border: 1px solid var(--border); margin: 0px 2px;\">&lt;ul&gt;</code>列表进行渲染， 当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。</p>\n<h2 id=\"排序面试题目总结\" style=\"padding: 0px; margin: 24px 0px 8px; font-size: 26px; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; letter-spacing: 2px; color: #495666; background-color: #ffffff;\">排序面试题目总结</h2>\n<ol style=\"padding: 0px 0px 0px 34px; margin: 0px; color: #495666; font-family: fell, Georgia, Cambria, 'Times New Roman', Times, serif; font-size: 16px; background-color: #ffffff;\">\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">快速排序在完全无序的情况下效果最好，时间复杂度为O(nlogn)，在有序情况下效果最差，时间复杂度为O(n^2)。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">初始数据集的排列顺序对算法的性能无影响的有堆排序，直接选择排序，归并排序，基数排序。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">合并 m 个长度为 n 的已排序数组的时间复杂度为 O(nmlogm)。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">外部排序常用的算法是归并排序。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">数组元素基本有序的情况下，插入排序效果最好，因为这样只需要比较大小，不需要移动，时间复杂度趋近于O(n)。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列，用堆排序方法最快。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">插入排序和优化后的冒泡在最优情况（有序）都只用比较 n-1 次。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">对长度为 n 的线性表作快速排序，在最坏情况下，比较次数为 n(n-1)/2。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">下标从1开始，在含有 n 个关键字的小根堆（堆顶元素最小）中，关键字最大的记录有可能存储在 [n/2]+2 位置上。 因为小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于 [n/2]。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">拓扑排序的算法，每次都选择入度为0的结点从图中删去，并从图中删除该顶点和所有以它为起点的有向边。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">任何一个基于\"比较\"的内部排序的算法，若对 n 个元素进行排序，则在最坏情况下所需的比较次数 k 满足 2^k &gt; n!， 时间下界为 O(nlogn)</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">m 个元素 k 路归并的归并趟数 s=logk(m)，代入数据：logk(100)≦3</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">对 n 个记录的线性表进行快速排序为减少算法的递归深度，每次分区后，先处理较短的部分。</p>\n</li>\n<li style=\"padding: 0px; margin: 0px 0px 6px;\">\n<p style=\"padding: 0px; margin: 14px 0px 0px 13px; line-height: 28px;\">在用邻接表表示图时，拓扑排序算法时间复杂度为 O(n+e)</p>\n</li>\n</ol>","rank_id":545,"createdAt":"2021-06-17T08:16:01.146Z","updatedAt":"2021-06-17T08:16:01.146Z","__v":0},{"_id":"60d5bf40e976f19e5c71c11e","title":"1 请谈谈微信小程序主要目录和文件的作用？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><span style=\"font-size: 12pt;\">project.config.json 项目配置文件，用得最多的就是配置是否开启https校验；</span></li>\n<li><span style=\"font-size: 12pt;\">App.js 设置一些全局的基础数据等；</span></li>\n<li><span style=\"font-size: 12pt;\">App.json 底部tab, 标题栏和路由等设置；</span></li>\n<li><span style=\"font-size: 12pt;\">App.wxss 公共样式，引入iconfont等；</span></li>\n<li><span style=\"font-size: 12pt;\">pages 里面包含一个个具体的页面；</span></li>\n<li><span style=\"font-size: 12pt;\">index.json (配置当前页面标题和引入组件等)；</span></li>\n<li><span style=\"font-size: 12pt;\">index.wxml (页面结构)；</span></li>\n<li><span style=\"font-size: 12pt;\">index.wxss (页面样式表)；</span></li>\n<li><span style=\"font-size: 12pt;\">index.js (页面的逻辑，请求和数据处理等)；</span></li>\n</ul>","rank_id":546,"createdAt":"2021-06-25T11:34:24.892Z","updatedAt":"2021-06-25T11:34:24.892Z","__v":0},{"_id":"60d5bf5fe976f19e5c71c11f","title":"请谈谈wxml与标准的html的异同？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><span style=\"font-size: 12pt;\">都是用来描述页面的结构；</span></li>\n<li><span style=\"font-size: 12pt;\">都由标签、属性等构成；</span></li>\n<li><span style=\"font-size: 12pt;\">标签名字不一样，且小程序标签更少，单一标签更多；</span></li>\n<li><span style=\"font-size: 12pt;\">多了一些 wx:if 这样的属性以及 {{ }} 这样的表达式</span></li>\n<li><span style=\"font-size: 12pt;\">WXML仅能在微信<a style=\"text-decoration-line: none; box-sizing: border-box; list-style: inherit; color: #00a4ff;\" href=\"https://cloud.tencent.com/solution/la?from=10680\" target=\"_blank\" rel=\"noopener\" data-text-link=\"47_1590621\" data-from=\"10680\">小程序开发</a>者工具中预览，而HTML可以在浏览器内预览</span></li>\n<li><span style=\"font-size: 12pt;\">组件封装不同， WXML对组件进行了重新封装，</span></li>\n<li><span style=\"font-size: 12pt;\">小程序运行在JS Core内，没有DOM树和window对象，小程序中无法使用window对象和document对象。</span></li>\n</ul>","rank_id":547,"createdAt":"2021-06-25T11:34:55.260Z","updatedAt":"2021-06-25T11:34:55.260Z","__v":0},{"_id":"60d5bf78e976f19e5c71c120","title":"请谈谈WXSS和CSS的异同？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><span style=\"font-size: 12pt;\">都是用来描述页面的样子；</span></li>\n<li><span style=\"font-size: 12pt;\">WXSS 具有 CSS 大部分的特性，也做了一些扩充和修改；</span></li>\n<li><span style=\"font-size: 12pt;\">WXSS新增了尺寸单位，WXSS 在底层支持新的尺寸单位 rpx；</span></li>\n<li><span style=\"font-size: 12pt;\">WXSS 仅支持部分 CSS 选择器；</span></li>\n<li><span style=\"font-size: 12pt;\">WXSS 提供全局样式与局部样式</span></li>\n</ul>","rank_id":548,"createdAt":"2021-06-25T11:35:20.320Z","updatedAt":"2021-06-25T11:35:20.320Z","__v":0},{"_id":"60d5bf91e976f19e5c71c121","title":"你是怎么封装微信小程序的数据请求的？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><span style=\"font-size: 12pt;\">在根目录下创建utils目录及api.js文件和apiConfig.js文件；</span></li>\n<li><span style=\"font-size: 12pt;\">在apiConfig.js 封装基础的get, post 和 put， upload等请求方法，设置请求体，带上token和异常处理等；</span></li>\n<li><span style=\"font-size: 12pt;\">在api中引入apiConfig.js封装好的请求方法，根据页面数据请求的urls, 设置对应的方法并导出；</span></li>\n<li><span style=\"font-size: 12pt;\">在具体的页面中导入；</span></li>\n</ul>","rank_id":549,"createdAt":"2021-06-25T11:35:45.459Z","updatedAt":"2021-06-25T11:35:45.459Z","__v":0},{"_id":"60d5bfaae976f19e5c71c122","title":"小程序页面间有哪些传递数据的方法？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><span style=\"font-size: 12pt;\">使用全局变量实现数据传递</span></li>\n<li><span style=\"font-size: 12pt;\">页面跳转或重定向时，使用url带参数传递数据</span></li>\n<li><span style=\"font-size: 12pt;\">使用组件模板 template传递参数</span></li>\n<li><span style=\"font-size: 12pt;\">使用缓存传递参数</span></li>\n<li><span style=\"font-size: 12pt;\">使用数据库传递数据</span></li>\n</ul>","rank_id":550,"createdAt":"2021-06-25T11:36:10.807Z","updatedAt":"2021-06-25T11:36:10.807Z","__v":0},{"_id":"60d5bfc3e976f19e5c71c123","title":"请谈谈小程序的双向绑定和vue的异同？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">大体相同，但小程序直接this.data的属性是不可以同步到视图的，必须调用this.setData()方法！</span></p>","rank_id":551,"createdAt":"2021-06-25T11:36:35.852Z","updatedAt":"2021-06-25T11:36:35.852Z","__v":0},{"_id":"60d5c009e976f19e5c71c124","title":"请谈谈小程序的生命周期函数？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><span style=\"font-size: 12pt;\">onLoad() 页面加载时触发，只会调用一次，可获取当前页面路径中的参数。</span></li>\n<li><span style=\"font-size: 12pt;\">onShow() 页面显示/切入前台时触发，一般用来发送数据请求；</span></li>\n<li><span style=\"font-size: 12pt;\">onReady() 页面初次渲染完成时触发, 只会调用一次，代表页面已可和视图层进行交互。</span></li>\n<li><span style=\"font-size: 12pt;\">onHide() 页面隐藏/切入后台时触发, 如底部 tab 切换到其他页面或小程序切入后台等。</span></li>\n<li><span style=\"font-size: 12pt;\">onUnload() 页面卸载时触发，如redirectTo或navigateBack到其他页面时。</span></li>\n</ul>","rank_id":552,"createdAt":"2021-06-25T11:37:45.518Z","updatedAt":"2021-06-25T11:37:45.518Z","__v":0},{"_id":"60d5c02ce976f19e5c71c125","title":"简述微信小程序原理？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><span style=\"font-size: 12pt;\">小程序本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种接口；</span></li>\n<li><span style=\"font-size: 12pt;\">它的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现；</span></li>\n<li><span style=\"font-size: 12pt;\">它从技术讲和现有的前端开发差不多，采用JavaScript、WXML、WXSS三种技术进行开发；</span></li>\n<li><span style=\"font-size: 12pt;\">功能可分为webview和appService两个部分；</span></li>\n<li><span style=\"font-size: 12pt;\">webview用来展现UI，appService有来处理业务逻辑、数据及接口调用；</span></li>\n<li><span style=\"font-size: 12pt;\">两个部分在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理等。</span></li>\n</ul>","rank_id":553,"createdAt":"2021-06-25T11:38:20.995Z","updatedAt":"2021-06-25T11:38:20.995Z","__v":0},{"_id":"60d5c04de976f19e5c71c126","title":"请谈谈原生开发小程序、wepy、mpvue 的对比？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul>\n<li><span style=\"font-size: 12pt;\">个人认为，如果是新项目，且没有旧的 h5 项目迁移，则考虑用小程序原生开发，好处是相比于第三方框架，坑少。</span></li>\n<li><span style=\"font-size: 12pt;\">而如果有 老的 h5 项目是 vue 开发 或者 也有 h5 项目也需要小程序开发，则比较适合 wepy 或者 mpvue 来做迁移或者开发，近期看wepy几乎不更新了，所以推荐美团的mpvue。</span></li>\n<li><span style=\"font-size: 12pt;\">而如果如果团队前端强大，自己做一套框架也没问题。</span></li>\n</ul>","rank_id":554,"createdAt":"2021-06-25T11:38:53.229Z","updatedAt":"2021-06-25T11:38:53.229Z","__v":0},{"_id":"60d5c08ae976f19e5c71c127","title":"简单描述下微信小程序的相关文件类型？","code":"","type":"html/css","frequency":"low","difficulty":"easy","answers":"<ol>\n<li><span style=\"font-size: 12pt;\">wxml 模板文件，是框架设计的一套标签语言，结合基础组件、事件系统、可以构建出页面的结构</span></li>\n<li><span style=\"font-size: 12pt;\">wxss 样式文件，是一套样式语言，用于描述WXML的组件样式</span></li>\n<li><span style=\"font-size: 12pt;\">js 脚本逻辑文件，逻辑处理网络请求</span></li>\n<li><span style=\"font-size: 12pt;\">json 配置文件，小程序设置，如页面注册，页面标题及tabBar</span></li>\n<li><span style=\"font-size: 12pt;\">app.json 整个小程序的全局配置，包括： </span>\n<ul>\n<li><span style=\"font-size: 12pt;\">pages:[所有页面路径]</span></li>\n<li><span style=\"font-size: 12pt;\">网络设置（网络超时时间）</span></li>\n<li><span style=\"font-size: 12pt;\">界面表现（页面注册）</span></li>\n<li><span style=\"font-size: 12pt;\">window:{背景色、导航样式、默认标题}</span></li>\n<li><span style=\"font-size: 12pt;\">底部tab等</span></li>\n</ul>\n</li>\n<li><span style=\"font-size: 12pt;\">app.js 监听并处理小程序的生命周期函数、声明全局变量</span></li>\n<li><span style=\"font-size: 12pt;\">app.wxss 全局配置的样式文件</span></li>\n</ol>","rank_id":555,"createdAt":"2021-06-25T11:39:54.135Z","updatedAt":"2021-06-25T11:39:54.135Z","__v":0},{"_id":"60d5c0a5e976f19e5c71c128","title":"怎么封装微信小程序的数据请求？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ol class=\"ol-level-0\" style=\"margin: 0px 0px 16px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\"><span style=\"font-size: 12pt;\">将所有的接口放在统一的js文件中并导出</span></li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\"><span style=\"font-size: 12pt;\">在app.js中创建封装请求数据的方法</span></li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\"><span style=\"font-size: 12pt;\">在子页面中调用封装的请求数据</span></li>\n</ol>\n<p style=\"margin: 0px 0px 8px; padding: 0px; box-sizing: border-box; list-style: inherit; min-height: 24px; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\"><span style=\"font-size: 12pt;\">或</span></p>\n<ol class=\"ol-level-0\" style=\"margin: 0px 0px 16px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\"><span style=\"font-size: 12pt;\">在根目录下创建utils目录及api.js文件和apiConfig.js文件；</span></li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\"><span style=\"font-size: 12pt;\">在appConfig.js封装基础的get\\post\\put\\upload等请求方法，设置请求体，带上token和异常处理等；</span></li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\"><span style=\"font-size: 12pt;\">在api.js中引入apiConfig.js封装好的请求方法，根据页面数据请求的urls，设置对应的方法并导出；</span></li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\"><span style=\"font-size: 12pt;\">在具体页面导入；</span></li>\n</ol>","rank_id":556,"createdAt":"2021-06-25T11:40:21.784Z","updatedAt":"2021-06-25T11:40:21.784Z","__v":0},{"_id":"60d5c0d5e976f19e5c71c129","title":"微信小程序有哪些传值(传递数据)方法？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ol class=\"ol-level-0\" style=\"margin: 0px 0px 16px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">给html元素添加data-*属性来传递值，然后通过e.currentTarget.dataset或onload的param参数获取。注：data-名称不能有大写字母、不可以存放对象</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">设置id的方法标识来传值，通过e.currentTarget.id获取设置的id的值，然后通过设置全局对象的方式来传递数值</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">在navigator中添加参数数值</li>\n</ol>\n<p style=\"margin: 0px 0px 8px; padding: 0px; box-sizing: border-box; list-style: inherit; min-height: 24px; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">或</p>\n<ol class=\"ol-level-0\" style=\"margin: 0px 0px 16px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">使用全局变量实现数据传递</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">页面跳转或重定向时，使用url带参数传递数据</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">使用组件模板template传递参数</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">使用缓存传递参数</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">使用数据库传递参数</li>\n</ol>","rank_id":557,"createdAt":"2021-06-25T11:41:09.161Z","updatedAt":"2021-06-25T11:41:09.161Z","__v":0},{"_id":"60d5c0f0e976f19e5c71c12a","title":"哪些方法来提高微信小程序的应用速度？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ol class=\"ol-level-0\" style=\"margin: 0px 0px 16px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">提高页面的加载速度</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">用户行为预测</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">减少默认data的大小</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">组件化方案</li>\n</ol>","rank_id":558,"createdAt":"2021-06-25T11:41:36.481Z","updatedAt":"2021-06-25T11:41:36.481Z","__v":0},{"_id":"60d5c103e976f19e5c71c12b","title":"微信小程序的原理？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ol class=\"ol-level-0\" style=\"margin: 0px 0px 16px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">微信小程序采用JavaScript、wxml、wxss三种技术进行开发，与现有前端开发的区别：\n<ul class=\"ul-level-1\" style=\"margin: 8px 0px; padding: 0px; box-sizing: border-box; list-style: none; color: #666666;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">JavaScript的代码是运行在微信APP中的，因此一些h5技术的应用需要微信APP提供对应的API支持；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">wxml微信自己基于xml语法开发的，因此在开发时只能使用微信提供的现有标签，html的标签是无法使用的；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">wxss具有css的大部分特性，但并不是所有都支持没有详细文档（wxss的图片引入需使用外链地址，没有body，样式可直接使用import导入）。</li>\n</ul>\n</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">微信的架构，是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现。</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">小程序功能分为webview和APPservice，webview主要用来展示UI，appservice用来处理业务逻辑、数据及接口调用。它们在两个进程中进行，通过系统层JSBridge实现通信，实现UI的渲染、事件处理。</li>\n</ol>","rank_id":559,"createdAt":"2021-06-25T11:41:55.734Z","updatedAt":"2021-06-25T11:41:55.734Z","__v":0},{"_id":"60d5c141e976f19e5c71c12c","title":"分析微信小程序的优劣势？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul class=\"ul-level-0\" style=\"margin: 0px 0px 16px; padding: 0px; box-sizing: border-box; list-style: none; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">优势：\n<ol class=\"ol-level-1\" style=\"margin: 8px 0px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; list-style-type: lower-roman;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">容易上手，基础组件库比较全，基本上不需要考虑兼容问题；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">开发文档比较完善，开发社区比较活跃，支持插件式开发；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">良好的用户体验：无需下载，通过搜索和扫一扫就可以打开，打开速度快，安卓上可以添加到桌面，与原生APP差不多；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">开发成本比APP要低；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">为用户提供良好的安全保障（小程序发布 严格的审查流程）</li>\n</ol>\n</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">劣势：\n<ol class=\"ol-level-1\" style=\"margin: 8px 0px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; list-style-type: lower-roman;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">限制较多，页面大小不能超过2M，不能打开超过5个层级的页面；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">样式单一，部分组件已经是成型了的，样式不可修改，例如：幻灯片、导航</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">依托于微信，无法开发后台管理功能</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">后台调试麻烦，因为api接口必须https请求且公网地址</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">真机测试，个别功能安卓和苹果表现迥异，例如安卓的定位功能加载很慢</li>\n</ol>\n</li>\n</ul>","rank_id":560,"createdAt":"2021-06-25T11:42:57.135Z","updatedAt":"2021-06-25T11:42:57.135Z","__v":0},{"_id":"60d5c183e976f19e5c71c12d","title":"小程序关联微信公众号如何确定用户的唯一性？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">使用wx.getUserInfo方法 withCredentials为true时，可获取encryptedData，里面有union_id.后端需要进行对称解密。</span></p>","rank_id":561,"createdAt":"2021-06-25T11:44:03.790Z","updatedAt":"2021-06-25T11:44:03.790Z","__v":0},{"_id":"60d5c199e976f19e5c71c12e","title":"使用webview直接加载要注意哪些事项？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ol class=\"ol-level-0\" style=\"margin: 0px 0px 16px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">必须要在小程序后台使用管理员添加业务域名；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">h5页面跳转至小程序的脚步必须是1.3.1以上；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">微信分享只可以是小程序的主名称，如要自定义分享内容，需小程序版本在1.7.1以上；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">h5的支付不可以是微信公众号的appid，必须是小程序的appid，而且用户的openid也必须是用户和小程序的</li>\n</ol>","rank_id":562,"createdAt":"2021-06-25T11:44:25.111Z","updatedAt":"2021-06-25T11:44:25.111Z","__v":0},{"_id":"60d5c1ace976f19e5c71c12f","title":"小程序调用后台接口遇到哪些问题？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ol class=\"ol-level-0\" style=\"margin: 0px 0px 16px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">数据的大小限制，超过范围会直接导致整个小程序崩溃，除非重启小程序；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">小程序不可以直接渲染文章内容这类型的html文本，显示需借助插件</li>\n</ol>\n<p style=\"margin: 0px 0px 8px; padding: 0px; box-sizing: border-box; list-style: inherit; min-height: 24px; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">注：插件渲染会导致页面加载变慢，建议在后台对文章内容的html进行过滤，后台直接处理批量替换p标签div标签为view标签。然后其他的标签让插件来做。</p>","rank_id":563,"createdAt":"2021-06-25T11:44:44.894Z","updatedAt":"2021-06-25T11:44:44.894Z","__v":0},{"_id":"60d5c1f5e976f19e5c71c130","title":"微信小程序如何实现下拉刷新？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px; margin: 1.4em 0px; display: table; color: #121212; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff;\">\n<li style=\"list-style: none; display: table-row;\"><span style=\"font-size: 12pt;\">通过在&nbsp;<code style=\"margin: 0px 2px; padding: 3px 4px; border-radius: 3px; font-family: Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace; background-color: #f6f6f6;\">app.json</code>&nbsp;中， 将&nbsp;<code style=\"margin: 0px 2px; padding: 3px 4px; border-radius: 3px; font-family: Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace; background-color: #f6f6f6;\">\"enablePullDownRefresh\": true,</code>&nbsp;开启全局下拉刷新。</span></li>\n<li style=\"list-style: none; display: table-row;\"><span style=\"font-size: 12pt;\">或者通过在&nbsp;<code style=\"margin: 0px 2px; padding: 3px 4px; border-radius: 3px; font-family: Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace; background-color: #f6f6f6;\">组件 .json</code>&nbsp;， 将&nbsp;<code style=\"margin: 0px 2px; padding: 3px 4px; border-radius: 3px; font-family: Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace; background-color: #f6f6f6;\">\"enablePullDownRefresh\": true,</code>&nbsp;单组件下拉刷新。</span></li>\n</ul>\n<p style=\"margin: 1.4em 0px; color: #121212; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff;\"><span style=\"font-weight: 600; font-size: 12pt;\">方案二：</span></p>\n<ul style=\"padding: 0px; margin: 1.4em 0px; display: table; color: #121212; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff;\">\n<li style=\"list-style: none; display: table-row;\"><span style=\"font-size: 12pt;\"><code style=\"margin: 0px 2px; padding: 3px 4px; border-radius: 3px; font-family: Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace; background-color: #f6f6f6;\">scroll-view</code>&nbsp;：使用该滚动组件 自定义刷新，通过&nbsp;<code style=\"margin: 0px 2px; padding: 3px 4px; border-radius: 3px; font-family: Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace; background-color: #f6f6f6;\">bindscrolltoupper</code>&nbsp;属性， 当滚动到顶部/左边，会触发&nbsp;<code style=\"margin: 0px 2px; padding: 3px 4px; border-radius: 3px; font-family: Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace; background-color: #f6f6f6;\">scrolltoupper</code>事件，所以我们可以利用这个属性，来实现下拉刷新功能。</span></li>\n</ul>","rank_id":564,"createdAt":"2021-06-25T11:45:57.769Z","updatedAt":"2021-06-25T11:45:57.769Z","__v":0},{"_id":"60d5c228e976f19e5c71c131","title":"bindtap和catchtap的区别？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ol class=\"ol-level-0\" style=\"margin: 0px 0px 16px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">bind事件绑定不会阻止冒泡事件向上冒泡</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">catch事件绑定可以阻止冒泡事件向上冒泡</li>\n</ol>","rank_id":565,"createdAt":"2021-06-25T11:46:48.719Z","updatedAt":"2021-06-25T11:46:48.719Z","__v":0},{"_id":"60d5c23de976f19e5c71c132","title":"简述wx.navigateTo(),wx.redirectTo(),wx.switchTab(),wx.navigateBack(),wx.reLaunch()的区别？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ol class=\"ol-level-0\" style=\"margin: 0px 0px 16px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">在wxml页面中：\n<ul class=\"ul-level-1\" style=\"margin: 8px 0px; padding: 0px; box-sizing: border-box; list-style: none; color: #666666;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">跳转新页面</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">在当前页打开</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">切换到首页Tab</li>\n</ul>\n</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">在js页面中：分为&lsquo;应用内的页面&rsquo;和&lsquo;tabBar页面&rsquo;；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">如果上述跳转遇到跳转失败或者无效的问题，请访问：wx.navigateTo/wx.redirectTo无效</li>\n</ol>","rank_id":566,"createdAt":"2021-06-25T11:47:09.985Z","updatedAt":"2021-06-25T11:47:09.985Z","__v":0},{"_id":"60d5c25ee976f19e5c71c133","title":"微信小程序与H5的区别？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ol class=\"ol-level-0\" style=\"margin: 0px 0px 16px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">运行环境不同（小程序在微信运行，h5在浏览器运行）；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">开发成本不同（h5需要兼容不同的浏览器）；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">获取系统权限不同（系统级权限可以和小程序无缝衔接）；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">应用在生产环境的运行流畅度（h5需不断对项目优化来提高用户体验）；</li>\n</ol>","rank_id":567,"createdAt":"2021-06-25T11:47:42.673Z","updatedAt":"2021-06-25T11:47:42.673Z","__v":0},{"_id":"60d5c28fe976f19e5c71c134","title":"小程序和Vue写法的区别？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ol class=\"ol-level-0\" style=\"margin: 0px 0px 16px; padding: 0px 0px 0px 18px; box-sizing: border-box; list-style-position: inherit; list-style-image: inherit; color: #333333; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">遍历的时候：\n<ul class=\"ul-level-1\" style=\"margin: 8px 0px; padding: 0px; box-sizing: border-box; list-style: none; color: #666666;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">小程序 wx:for = \"lists\"</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">Vue是 v-for = \"item in lists\"</li>\n</ul>\n</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px; list-style: inherit; box-sizing: border-box;\">调用data模型（赋值）的时候：\n<ul class=\"ul-level-1\" style=\"margin: 8px 0px; padding: 0px; box-sizing: border-box; list-style: none; color: #666666;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">小程序：this.data.item //调用 this.setData({item:1}) //赋值</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">vue: this.item //调用 this.item =1 //赋值</li>\n</ul>\n</li>\n</ol>","rank_id":568,"createdAt":"2021-06-25T11:48:31.159Z","updatedAt":"2021-06-25T11:48:31.159Z","__v":0},{"_id":"60d5c2c3e976f19e5c71c135","title":"rpx是什么？怎么定义的","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<p><span style=\"font-size: 12pt;\">rpx:小程序的尺寸单位，规定屏幕为750rpx，可适配不同分辨率的屏幕。</span></p>","rank_id":569,"createdAt":"2021-06-25T11:49:23.239Z","updatedAt":"2021-06-25T11:49:23.239Z","__v":0},{"_id":"60d5c2ece976f19e5c71c136","title":"本地资源无法通过wxss获取 ","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<p><span style=\"font-size: 12pt;\">&nbsp;RE： background-image：可以使用网络图片，或者base64，或者使用标签</span></p>","rank_id":570,"createdAt":"2021-06-25T11:50:04.174Z","updatedAt":"2021-06-25T11:50:04.174Z","__v":0},{"_id":"60d5c309e976f19e5c71c137","title":"wx.navigateTo无法打开页面","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul class=\"ul-level-1\" style=\"margin: 8px 0px; padding: 0px; box-sizing: border-box; list-style: none; color: #666666; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">一个应用同时只能打开5个页面，请避免多层级的交互方式，或使用wx.redirectTo</li>\n</ul>","rank_id":571,"createdAt":"2021-06-25T11:50:33.904Z","updatedAt":"2021-06-25T11:50:33.904Z","__v":0},{"_id":"60d5c32de976f19e5c71c138","title":"tabBar设置不显示","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul class=\"ul-level-1\" style=\"margin: 8px 0px; padding: 0px; box-sizing: border-box; list-style: none; color: #666666; font-family: 'pingfang SC', 'helvetica neue', arial, 'hiragino sans gb', 'microsoft yahei ui', 'microsoft yahei', simsun, sans-serif; font-size: 14px; white-space: pre-wrap; background-color: #ffffff;\">\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">abBar的数量少于2项或超过5项都不会显示；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">tabBar写法错误导致不显示；</li>\n<li style=\"margin: 0px 0px 4px; padding: 0px 0px 0px 18px; list-style: none; box-sizing: border-box; position: relative;\">tabBar没有写pagePath字段（程序启动后显示的第一个页面）</li>\n</ul>","rank_id":572,"createdAt":"2021-06-25T11:51:09.712Z","updatedAt":"2021-06-25T11:51:09.712Z","__v":0},{"_id":"60d5c347e976f19e5c71c139","title":"小程序 wx:if 和 hidden 的区别","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px; margin: 1.4em 0px; display: table; color: #121212; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff;\">\n<ul style=\"padding: 0px; margin: 1.4em 0px; display: table; color: #121212; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff;\">\n<li style=\"list-style: none; display: table-row;\"><span style=\"font-size: 12pt;\"><code style=\"margin: 0px 2px; padding: 3px 4px; border-radius: 3px; font-family: Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace; background-color: #f6f6f6;\">wx:if</code>&nbsp;: 有更高的切换消耗。</span></li>\n<li style=\"list-style: none; display: table-row;\"><span style=\"font-size: 12pt;\"><code style=\"margin: 0px 2px; padding: 3px 4px; border-radius: 3px; font-family: Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace; background-color: #f6f6f6;\">hidden</code>&nbsp;: 有更高的初始渲染消耗。</span></li>\n</ul>\n</ul>\n<p>&nbsp;</p>","rank_id":573,"createdAt":"2021-06-25T11:51:35.270Z","updatedAt":"2021-06-25T11:51:35.270Z","__v":0},{"_id":"60d5c36ee976f19e5c71c13a","title":"小程序运行机制","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<ul style=\"padding: 0px; margin: 1.4em 0px; display: table; color: #121212; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff;\">\n<li style=\"list-style: none; display: table-row;\"><span style=\"font-size: 12pt;\"><code style=\"margin: 0px 2px; padding: 3px 4px; border-radius: 3px; font-family: Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace; background-color: #f6f6f6;\">热启动</code>&nbsp;：假如用户已经打开了某个小程序，在一定时间内再次打开小程序的话，这个时候我们就不再需要重新启动了，这需要把我们的后台打开的小程序切换到前台来使用。</span></li>\n<li style=\"list-style: none; display: table-row;\"><span style=\"font-size: 12pt;\"><code style=\"margin: 0px 2px; padding: 3px 4px; border-radius: 3px; font-family: Menlo, Monaco, Consolas, 'Andale Mono', 'lucida console', 'Courier New', monospace; background-color: #f6f6f6;\">冷启动</code>：用户首次打开小程序或被微信主动销毁再次打开的情况，此时小程序需要重新加载启动。</span></li>\n</ul>","rank_id":574,"createdAt":"2021-06-25T11:52:14.328Z","updatedAt":"2021-06-25T11:52:14.328Z","__v":0},{"_id":"60d5c390e976f19e5c71c13b","title":"小程序什么时候会主动销毁？","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<p><span style=\"color: #646464; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff; font-size: 12pt;\">小程序在进入后台之后，客户端会帮我们在一定时间内维持我们的一个状态，超过五分钟后，会被微信主动销毁.</span><br style=\"color: #646464; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff;\" /><span style=\"font-weight: 600; color: #646464; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff; font-size: 12pt;\">官方也没有明确说明 什么时候销毁， 在不同机型表现也不一样，</span><br style=\"color: #646464; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff;\" /><span style=\"color: #646464; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff; font-size: 12pt;\">2019年开发时：时间官方文档没有说明，但是经过询问一般指5分钟内</span><br style=\"color: #646464; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff;\" /><span style=\"color: #646464; font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif; background-color: #ffffff; font-size: 12pt;\">2020年开发时：时间官方文档没有说明，实测安卓没有固定时间，内存足够情况下，有时候一天了还在，有时候几分钟就没了。</span></p>","rank_id":575,"createdAt":"2021-06-25T11:52:48.464Z","updatedAt":"2021-06-25T11:52:48.464Z","__v":0},{"_id":"60d5c4d5e976f19e5c71c13c","title":"小程序调用后台接口遇到过哪些问题","code":"","type":"miniprogram","frequency":"low","difficulty":"easy","answers":"<div><span style=\"font-size: 12pt;\">数据的大小有限制，超过范围会直接导致整个小程序崩溃，除非重启小程序；2、小程序不可以直接渲染文章内容页这类型的html文本内容，若需显示要借住插件，但插件渲染会导致页面加载变慢，所以最好在后台对文章内容的html进行过滤，后台直接处理批量替换p标签div标签为view标签，然后其它的标签让插件来做，减轻前端的时间</span></div>\n<p>&nbsp;</p>","rank_id":576,"createdAt":"2021-06-25T11:58:13.909Z","updatedAt":"2021-06-25T11:58:13.909Z","__v":0}]